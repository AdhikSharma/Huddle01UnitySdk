var HuddleWebCore = (function (exports) {
  'use strict';

  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    __defProp(target, "default", { value: mod, enumerable: true }) ,
    mod
  ));

  // ../../node_modules/ms/index.js
  var require_ms = __commonJS({
    "../../node_modules/ms/index.js"(exports, module) {
      var s = 1e3;
      var m = s * 60;
      var h = m * 60;
      var d = h * 24;
      var w = d * 7;
      var y = d * 365.25;
      module.exports = function(val, options) {
        options = options || {};
        var type = typeof val;
        if (type === "string" && val.length > 0) {
          return parse(val);
        } else if (type === "number" && isFinite(val)) {
          return options.long ? fmtLong(val) : fmtShort(val);
        }
        throw new Error(
          "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
        );
      };
      function parse(str) {
        str = String(str);
        if (str.length > 100) {
          return;
        }
        var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
          str
        );
        if (!match) {
          return;
        }
        var n = parseFloat(match[1]);
        var type = (match[2] || "ms").toLowerCase();
        switch (type) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return n * y;
          case "weeks":
          case "week":
          case "w":
            return n * w;
          case "days":
          case "day":
          case "d":
            return n * d;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return n * h;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return n * m;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return n * s;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return n;
          default:
            return void 0;
        }
      }
      function fmtShort(ms) {
        var msAbs = Math.abs(ms);
        if (msAbs >= d) {
          return Math.round(ms / d) + "d";
        }
        if (msAbs >= h) {
          return Math.round(ms / h) + "h";
        }
        if (msAbs >= m) {
          return Math.round(ms / m) + "m";
        }
        if (msAbs >= s) {
          return Math.round(ms / s) + "s";
        }
        return ms + "ms";
      }
      function fmtLong(ms) {
        var msAbs = Math.abs(ms);
        if (msAbs >= d) {
          return plural(ms, msAbs, d, "day");
        }
        if (msAbs >= h) {
          return plural(ms, msAbs, h, "hour");
        }
        if (msAbs >= m) {
          return plural(ms, msAbs, m, "minute");
        }
        if (msAbs >= s) {
          return plural(ms, msAbs, s, "second");
        }
        return ms + " ms";
      }
      function plural(ms, msAbs, n, name) {
        var isPlural = msAbs >= n * 1.5;
        return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
      }
    }
  });

  // ../../node_modules/mediasoup-client/node_modules/debug/src/common.js
  var require_common = __commonJS({
    "../../node_modules/mediasoup-client/node_modules/debug/src/common.js"(exports, module) {
      function setup(env) {
        createDebug.debug = createDebug;
        createDebug.default = createDebug;
        createDebug.coerce = coerce2;
        createDebug.disable = disable;
        createDebug.enable = enable;
        createDebug.enabled = enabled;
        createDebug.humanize = require_ms();
        createDebug.destroy = destroy;
        Object.keys(env).forEach((key) => {
          createDebug[key] = env[key];
        });
        createDebug.names = [];
        createDebug.skips = [];
        createDebug.formatters = {};
        function selectColor(namespace) {
          let hash = 0;
          for (let i = 0; i < namespace.length; i++) {
            hash = (hash << 5) - hash + namespace.charCodeAt(i);
            hash |= 0;
          }
          return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
        }
        createDebug.selectColor = selectColor;
        function createDebug(namespace) {
          let prevTime;
          let enableOverride = null;
          let namespacesCache;
          let enabledCache;
          function debug(...args) {
            if (!debug.enabled) {
              return;
            }
            const self = debug;
            const curr = Number(/* @__PURE__ */ new Date());
            const ms = curr - (prevTime || curr);
            self.diff = ms;
            self.prev = prevTime;
            self.curr = curr;
            prevTime = curr;
            args[0] = createDebug.coerce(args[0]);
            if (typeof args[0] !== "string") {
              args.unshift("%O");
            }
            let index = 0;
            args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
              if (match === "%%") {
                return "%";
              }
              index++;
              const formatter = createDebug.formatters[format];
              if (typeof formatter === "function") {
                const val = args[index];
                match = formatter.call(self, val);
                args.splice(index, 1);
                index--;
              }
              return match;
            });
            createDebug.formatArgs.call(self, args);
            const logFn = self.log || createDebug.log;
            logFn.apply(self, args);
          }
          debug.namespace = namespace;
          debug.useColors = createDebug.useColors();
          debug.color = createDebug.selectColor(namespace);
          debug.extend = extend;
          debug.destroy = createDebug.destroy;
          Object.defineProperty(debug, "enabled", {
            enumerable: true,
            configurable: false,
            get: () => {
              if (enableOverride !== null) {
                return enableOverride;
              }
              if (namespacesCache !== createDebug.namespaces) {
                namespacesCache = createDebug.namespaces;
                enabledCache = createDebug.enabled(namespace);
              }
              return enabledCache;
            },
            set: (v) => {
              enableOverride = v;
            }
          });
          if (typeof createDebug.init === "function") {
            createDebug.init(debug);
          }
          return debug;
        }
        function extend(namespace, delimiter) {
          const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
          newDebug.log = this.log;
          return newDebug;
        }
        function enable(namespaces) {
          createDebug.save(namespaces);
          createDebug.namespaces = namespaces;
          createDebug.names = [];
          createDebug.skips = [];
          let i;
          const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
          const len = split.length;
          for (i = 0; i < len; i++) {
            if (!split[i]) {
              continue;
            }
            namespaces = split[i].replace(/\*/g, ".*?");
            if (namespaces[0] === "-") {
              createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
            } else {
              createDebug.names.push(new RegExp("^" + namespaces + "$"));
            }
          }
        }
        function disable() {
          const namespaces = [
            ...createDebug.names.map(toNamespace),
            ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
          ].join(",");
          createDebug.enable("");
          return namespaces;
        }
        function enabled(name) {
          if (name[name.length - 1] === "*") {
            return true;
          }
          let i;
          let len;
          for (i = 0, len = createDebug.skips.length; i < len; i++) {
            if (createDebug.skips[i].test(name)) {
              return false;
            }
          }
          for (i = 0, len = createDebug.names.length; i < len; i++) {
            if (createDebug.names[i].test(name)) {
              return true;
            }
          }
          return false;
        }
        function toNamespace(regexp) {
          return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
        }
        function coerce2(val) {
          if (val instanceof Error) {
            return val.stack || val.message;
          }
          return val;
        }
        function destroy() {
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
        createDebug.enable(createDebug.load());
        return createDebug;
      }
      module.exports = setup;
    }
  });

  // ../../node_modules/mediasoup-client/node_modules/debug/src/browser.js
  var require_browser = __commonJS({
    "../../node_modules/mediasoup-client/node_modules/debug/src/browser.js"(exports, module) {
      exports.formatArgs = formatArgs;
      exports.save = save;
      exports.load = load;
      exports.useColors = useColors;
      exports.storage = localstorage();
      exports.destroy = /* @__PURE__ */ (() => {
        let warned = false;
        return () => {
          if (!warned) {
            warned = true;
            console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
          }
        };
      })();
      exports.colors = [
        "#0000CC",
        "#0000FF",
        "#0033CC",
        "#0033FF",
        "#0066CC",
        "#0066FF",
        "#0099CC",
        "#0099FF",
        "#00CC00",
        "#00CC33",
        "#00CC66",
        "#00CC99",
        "#00CCCC",
        "#00CCFF",
        "#3300CC",
        "#3300FF",
        "#3333CC",
        "#3333FF",
        "#3366CC",
        "#3366FF",
        "#3399CC",
        "#3399FF",
        "#33CC00",
        "#33CC33",
        "#33CC66",
        "#33CC99",
        "#33CCCC",
        "#33CCFF",
        "#6600CC",
        "#6600FF",
        "#6633CC",
        "#6633FF",
        "#66CC00",
        "#66CC33",
        "#9900CC",
        "#9900FF",
        "#9933CC",
        "#9933FF",
        "#99CC00",
        "#99CC33",
        "#CC0000",
        "#CC0033",
        "#CC0066",
        "#CC0099",
        "#CC00CC",
        "#CC00FF",
        "#CC3300",
        "#CC3333",
        "#CC3366",
        "#CC3399",
        "#CC33CC",
        "#CC33FF",
        "#CC6600",
        "#CC6633",
        "#CC9900",
        "#CC9933",
        "#CCCC00",
        "#CCCC33",
        "#FF0000",
        "#FF0033",
        "#FF0066",
        "#FF0099",
        "#FF00CC",
        "#FF00FF",
        "#FF3300",
        "#FF3333",
        "#FF3366",
        "#FF3399",
        "#FF33CC",
        "#FF33FF",
        "#FF6600",
        "#FF6633",
        "#FF9900",
        "#FF9933",
        "#FFCC00",
        "#FFCC33"
      ];
      function useColors() {
        if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
          return true;
        }
        if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
          return false;
        }
        let m;
        return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
        typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
        // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
        typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
        typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
      }
      function formatArgs(args) {
        args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
        if (!this.useColors) {
          return;
        }
        const c = "color: " + this.color;
        args.splice(1, 0, c, "color: inherit");
        let index = 0;
        let lastC = 0;
        args[0].replace(/%[a-zA-Z%]/g, (match) => {
          if (match === "%%") {
            return;
          }
          index++;
          if (match === "%c") {
            lastC = index;
          }
        });
        args.splice(lastC, 0, c);
      }
      exports.log = console.debug || console.log || (() => {
      });
      function save(namespaces) {
        try {
          if (namespaces) {
            exports.storage.setItem("debug", namespaces);
          } else {
            exports.storage.removeItem("debug");
          }
        } catch (error) {
        }
      }
      function load() {
        let r;
        try {
          r = exports.storage.getItem("debug");
        } catch (error) {
        }
        if (!r && typeof process !== "undefined" && "env" in process) {
          r = process.env.DEBUG;
        }
        return r;
      }
      function localstorage() {
        try {
          return localStorage;
        } catch (error) {
        }
      }
      module.exports = require_common()(exports);
      var { formatters } = module.exports;
      formatters.j = function(v) {
        try {
          return JSON.stringify(v);
        } catch (error) {
          return "[UnexpectedJSONParseError]: " + error.message;
        }
      };
    }
  });

  // ../../node_modules/mediasoup-client/node_modules/ua-parser-js/src/ua-parser.js
  var require_ua_parser = __commonJS({
    "../../node_modules/mediasoup-client/node_modules/ua-parser-js/src/ua-parser.js"(exports, module) {
      (function(window2, undefined2) {
        var LIBVERSION = "1.0.38", EMPTY = "", UNKNOWN = "?", FUNC_TYPE = "function", UNDEF_TYPE = "undefined", OBJ_TYPE = "object", STR_TYPE = "string", MAJOR = "major", MODEL = "model", NAME = "name", TYPE = "type", VENDOR = "vendor", VERSION = "version", ARCHITECTURE = "architecture", CONSOLE = "console", MOBILE = "mobile", TABLET = "tablet", SMARTTV = "smarttv", WEARABLE = "wearable", EMBEDDED = "embedded", UA_MAX_LENGTH = 500;
        var AMAZON = "Amazon", APPLE = "Apple", ASUS = "ASUS", BLACKBERRY = "BlackBerry", BROWSER = "Browser", CHROME = "Chrome", EDGE = "Edge", FIREFOX = "Firefox", GOOGLE = "Google", HUAWEI = "Huawei", LG = "LG", MICROSOFT = "Microsoft", MOTOROLA = "Motorola", OPERA = "Opera", SAMSUNG = "Samsung", SHARP = "Sharp", SONY = "Sony", XIAOMI = "Xiaomi", ZEBRA = "Zebra", FACEBOOK = "Facebook", CHROMIUM_OS = "Chromium OS", MAC_OS = "Mac OS";
        var extend = function(regexes2, extensions) {
          var mergedRegexes = {};
          for (var i in regexes2) {
            if (extensions[i] && extensions[i].length % 2 === 0) {
              mergedRegexes[i] = extensions[i].concat(regexes2[i]);
            } else {
              mergedRegexes[i] = regexes2[i];
            }
          }
          return mergedRegexes;
        }, enumerize = function(arr) {
          var enums = {};
          for (var i = 0; i < arr.length; i++) {
            enums[arr[i].toUpperCase()] = arr[i];
          }
          return enums;
        }, has = function(str1, str2) {
          return typeof str1 === STR_TYPE ? lowerize(str2).indexOf(lowerize(str1)) !== -1 : false;
        }, lowerize = function(str) {
          return str.toLowerCase();
        }, majorize = function(version) {
          return typeof version === STR_TYPE ? version.replace(/[^\d\.]/g, EMPTY).split(".")[0] : undefined2;
        }, trim = function(str, len) {
          if (typeof str === STR_TYPE) {
            str = str.replace(/^\s\s*/, EMPTY);
            return typeof len === UNDEF_TYPE ? str : str.substring(0, UA_MAX_LENGTH);
          }
        };
        var rgxMapper = function(ua, arrays) {
          var i = 0, j, k, p, q, matches, match;
          while (i < arrays.length && !matches) {
            var regex = arrays[i], props = arrays[i + 1];
            j = k = 0;
            while (j < regex.length && !matches) {
              if (!regex[j]) {
                break;
              }
              matches = regex[j++].exec(ua);
              if (!!matches) {
                for (p = 0; p < props.length; p++) {
                  match = matches[++k];
                  q = props[p];
                  if (typeof q === OBJ_TYPE && q.length > 0) {
                    if (q.length === 2) {
                      if (typeof q[1] == FUNC_TYPE) {
                        this[q[0]] = q[1].call(this, match);
                      } else {
                        this[q[0]] = q[1];
                      }
                    } else if (q.length === 3) {
                      if (typeof q[1] === FUNC_TYPE && !(q[1].exec && q[1].test)) {
                        this[q[0]] = match ? q[1].call(this, match, q[2]) : undefined2;
                      } else {
                        this[q[0]] = match ? match.replace(q[1], q[2]) : undefined2;
                      }
                    } else if (q.length === 4) {
                      this[q[0]] = match ? q[3].call(this, match.replace(q[1], q[2])) : undefined2;
                    }
                  } else {
                    this[q] = match ? match : undefined2;
                  }
                }
              }
            }
            i += 2;
          }
        }, strMapper = function(str, map) {
          for (var i in map) {
            if (typeof map[i] === OBJ_TYPE && map[i].length > 0) {
              for (var j = 0; j < map[i].length; j++) {
                if (has(map[i][j], str)) {
                  return i === UNKNOWN ? undefined2 : i;
                }
              }
            } else if (has(map[i], str)) {
              return i === UNKNOWN ? undefined2 : i;
            }
          }
          return str;
        };
        var oldSafariMap = {
          "1.0": "/8",
          "1.2": "/1",
          "1.3": "/3",
          "2.0": "/412",
          "2.0.2": "/416",
          "2.0.3": "/417",
          "2.0.4": "/419",
          "?": "/"
        }, windowsVersionMap = {
          "ME": "4.90",
          "NT 3.11": "NT3.51",
          "NT 4.0": "NT4.0",
          "2000": "NT 5.0",
          "XP": ["NT 5.1", "NT 5.2"],
          "Vista": "NT 6.0",
          "7": "NT 6.1",
          "8": "NT 6.2",
          "8.1": "NT 6.3",
          "10": ["NT 6.4", "NT 10.0"],
          "RT": "ARM"
        };
        var regexes = {
          browser: [
            [
              /\b(?:crmo|crios)\/([\w\.]+)/i
              // Chrome for Android/iOS
            ],
            [VERSION, [NAME, "Chrome"]],
            [
              /edg(?:e|ios|a)?\/([\w\.]+)/i
              // Microsoft Edge
            ],
            [VERSION, [NAME, "Edge"]],
            [
              // Presto based
              /(opera mini)\/([-\w\.]+)/i,
              // Opera Mini
              /(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i,
              // Opera Mobi/Tablet
              /(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i
              // Opera
            ],
            [NAME, VERSION],
            [
              /opios[\/ ]+([\w\.]+)/i
              // Opera mini on iphone >= 8.0
            ],
            [VERSION, [NAME, OPERA + " Mini"]],
            [
              /\bop(?:rg)?x\/([\w\.]+)/i
              // Opera GX
            ],
            [VERSION, [NAME, OPERA + " GX"]],
            [
              /\bopr\/([\w\.]+)/i
              // Opera Webkit
            ],
            [VERSION, [NAME, OPERA]],
            [
              // Mixed
              /\bb[ai]*d(?:uhd|[ub]*[aekoprswx]{5,6})[\/ ]?([\w\.]+)/i
              // Baidu
            ],
            [VERSION, [NAME, "Baidu"]],
            [
              /(kindle)\/([\w\.]+)/i,
              // Kindle
              /(lunascape|maxthon|netfront|jasmine|blazer)[\/ ]?([\w\.]*)/i,
              // Lunascape/Maxthon/Netfront/Jasmine/Blazer
              // Trident based
              /(avant|iemobile|slim)\s?(?:browser)?[\/ ]?([\w\.]*)/i,
              // Avant/IEMobile/SlimBrowser
              /(?:ms|\()(ie) ([\w\.]+)/i,
              // Internet Explorer
              // Webkit/KHTML based                                               // Flock/RockMelt/Midori/Epiphany/Silk/Skyfire/Bolt/Iron/Iridium/PhantomJS/Bowser/QupZilla/Falkon
              /(flock|rockmelt|midori|epiphany|silk|skyfire|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark|qupzilla|falkon|rekonq|puffin|brave|whale(?!.+naver)|qqbrowserlite|qq|duckduckgo)\/([-\w\.]+)/i,
              // Rekonq/Puffin/Brave/Whale/QQBrowserLite/QQ, aka ShouQ
              /(heytap|ovi)browser\/([\d\.]+)/i,
              // Heytap/Ovi
              /(weibo)__([\d\.]+)/i
              // Weibo
            ],
            [NAME, VERSION],
            [
              /\bddg\/([\w\.]+)/i
              // DuckDuckGo
            ],
            [VERSION, [NAME, "DuckDuckGo"]],
            [
              /(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i
              // UCBrowser
            ],
            [VERSION, [NAME, "UC" + BROWSER]],
            [
              /microm.+\bqbcore\/([\w\.]+)/i,
              // WeChat Desktop for Windows Built-in Browser
              /\bqbcore\/([\w\.]+).+microm/i,
              /micromessenger\/([\w\.]+)/i
              // WeChat
            ],
            [VERSION, [NAME, "WeChat"]],
            [
              /konqueror\/([\w\.]+)/i
              // Konqueror
            ],
            [VERSION, [NAME, "Konqueror"]],
            [
              /trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i
              // IE11
            ],
            [VERSION, [NAME, "IE"]],
            [
              /ya(?:search)?browser\/([\w\.]+)/i
              // Yandex
            ],
            [VERSION, [NAME, "Yandex"]],
            [
              /slbrowser\/([\w\.]+)/i
              // Smart Lenovo Browser
            ],
            [VERSION, [NAME, "Smart Lenovo " + BROWSER]],
            [
              /(avast|avg)\/([\w\.]+)/i
              // Avast/AVG Secure Browser
            ],
            [[NAME, /(.+)/, "$1 Secure " + BROWSER], VERSION],
            [
              /\bfocus\/([\w\.]+)/i
              // Firefox Focus
            ],
            [VERSION, [NAME, FIREFOX + " Focus"]],
            [
              /\bopt\/([\w\.]+)/i
              // Opera Touch
            ],
            [VERSION, [NAME, OPERA + " Touch"]],
            [
              /coc_coc\w+\/([\w\.]+)/i
              // Coc Coc Browser
            ],
            [VERSION, [NAME, "Coc Coc"]],
            [
              /dolfin\/([\w\.]+)/i
              // Dolphin
            ],
            [VERSION, [NAME, "Dolphin"]],
            [
              /coast\/([\w\.]+)/i
              // Opera Coast
            ],
            [VERSION, [NAME, OPERA + " Coast"]],
            [
              /miuibrowser\/([\w\.]+)/i
              // MIUI Browser
            ],
            [VERSION, [NAME, "MIUI " + BROWSER]],
            [
              /fxios\/([-\w\.]+)/i
              // Firefox for iOS
            ],
            [VERSION, [NAME, FIREFOX]],
            [
              /\bqihu|(qi?ho?o?|360)browser/i
              // 360
            ],
            [[NAME, "360 " + BROWSER]],
            [
              /(oculus|sailfish|huawei|vivo)browser\/([\w\.]+)/i
            ],
            [[NAME, /(.+)/, "$1 " + BROWSER], VERSION],
            [
              // Oculus/Sailfish/HuaweiBrowser/VivoBrowser
              /samsungbrowser\/([\w\.]+)/i
              // Samsung Internet
            ],
            [VERSION, [NAME, SAMSUNG + " Internet"]],
            [
              /(comodo_dragon)\/([\w\.]+)/i
              // Comodo Dragon
            ],
            [[NAME, /_/g, " "], VERSION],
            [
              /metasr[\/ ]?([\d\.]+)/i
              // Sogou Explorer
            ],
            [VERSION, [NAME, "Sogou Explorer"]],
            [
              /(sogou)mo\w+\/([\d\.]+)/i
              // Sogou Mobile
            ],
            [[NAME, "Sogou Mobile"], VERSION],
            [
              /(electron)\/([\w\.]+) safari/i,
              // Electron-based App
              /(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i,
              // Tesla
              /m?(qqbrowser|2345Explorer)[\/ ]?([\w\.]+)/i
              // QQBrowser/2345 Browser
            ],
            [NAME, VERSION],
            [
              /(lbbrowser)/i,
              // LieBao Browser
              /\[(linkedin)app\]/i
              // LinkedIn App for iOS & Android
            ],
            [NAME],
            [
              // WebView
              /((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i
              // Facebook App for iOS & Android
            ],
            [[NAME, FACEBOOK], VERSION],
            [
              /(Klarna)\/([\w\.]+)/i,
              // Klarna Shopping Browser for iOS & Android
              /(kakao(?:talk|story))[\/ ]([\w\.]+)/i,
              // Kakao App
              /(naver)\(.*?(\d+\.[\w\.]+).*\)/i,
              // Naver InApp
              /safari (line)\/([\w\.]+)/i,
              // Line App for iOS
              /\b(line)\/([\w\.]+)\/iab/i,
              // Line App for Android
              /(alipay)client\/([\w\.]+)/i,
              // Alipay
              /(twitter)(?:and| f.+e\/([\w\.]+))/i,
              // Twitter
              /(chromium|instagram|snapchat)[\/ ]([-\w\.]+)/i
              // Chromium/Instagram/Snapchat
            ],
            [NAME, VERSION],
            [
              /\bgsa\/([\w\.]+) .*safari\//i
              // Google Search Appliance on iOS
            ],
            [VERSION, [NAME, "GSA"]],
            [
              /musical_ly(?:.+app_?version\/|_)([\w\.]+)/i
              // TikTok
            ],
            [VERSION, [NAME, "TikTok"]],
            [
              /headlesschrome(?:\/([\w\.]+)| )/i
              // Chrome Headless
            ],
            [VERSION, [NAME, CHROME + " Headless"]],
            [
              / wv\).+(chrome)\/([\w\.]+)/i
              // Chrome WebView
            ],
            [[NAME, CHROME + " WebView"], VERSION],
            [
              /droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i
              // Android Browser
            ],
            [VERSION, [NAME, "Android " + BROWSER]],
            [
              /(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i
              // Chrome/OmniWeb/Arora/Tizen/Nokia
            ],
            [NAME, VERSION],
            [
              /version\/([\w\.\,]+) .*mobile\/\w+ (safari)/i
              // Mobile Safari
            ],
            [VERSION, [NAME, "Mobile Safari"]],
            [
              /version\/([\w(\.|\,)]+) .*(mobile ?safari|safari)/i
              // Safari & Safari Mobile
            ],
            [VERSION, NAME],
            [
              /webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i
              // Safari < 3.0
            ],
            [NAME, [VERSION, strMapper, oldSafariMap]],
            [
              /(webkit|khtml)\/([\w\.]+)/i
            ],
            [NAME, VERSION],
            [
              // Gecko based
              /(navigator|netscape\d?)\/([-\w\.]+)/i
              // Netscape
            ],
            [[NAME, "Netscape"], VERSION],
            [
              /mobile vr; rv:([\w\.]+)\).+firefox/i
              // Firefox Reality
            ],
            [VERSION, [NAME, FIREFOX + " Reality"]],
            [
              /ekiohf.+(flow)\/([\w\.]+)/i,
              // Flow
              /(swiftfox)/i,
              // Swiftfox
              /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror|klar)[\/ ]?([\w\.\+]+)/i,
              // IceDragon/Iceweasel/Camino/Chimera/Fennec/Maemo/Minimo/Conkeror/Klar
              /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([-\w\.]+)$/i,
              // Firefox/SeaMonkey/K-Meleon/IceCat/IceApe/Firebird/Phoenix
              /(firefox)\/([\w\.]+)/i,
              // Other Firefox-based
              /(mozilla)\/([\w\.]+) .+rv\:.+gecko\/\d+/i,
              // Mozilla
              // Other
              /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir|obigo|mosaic|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i,
              // Polaris/Lynx/Dillo/iCab/Doris/Amaya/w3m/NetSurf/Sleipnir/Obigo/Mosaic/Go/ICE/UP.Browser
              /(links) \(([\w\.]+)/i,
              // Links
              /panasonic;(viera)/i
              // Panasonic Viera
            ],
            [NAME, VERSION],
            [
              /(cobalt)\/([\w\.]+)/i
              // Cobalt
            ],
            [NAME, [VERSION, /master.|lts./, ""]]
          ],
          cpu: [
            [
              /(?:(amd|x(?:(?:86|64)[-_])?|wow|win)64)[;\)]/i
              // AMD64 (x64)
            ],
            [[ARCHITECTURE, "amd64"]],
            [
              /(ia32(?=;))/i
              // IA32 (quicktime)
            ],
            [[ARCHITECTURE, lowerize]],
            [
              /((?:i[346]|x)86)[;\)]/i
              // IA32 (x86)
            ],
            [[ARCHITECTURE, "ia32"]],
            [
              /\b(aarch64|arm(v?8e?l?|_?64))\b/i
              // ARM64
            ],
            [[ARCHITECTURE, "arm64"]],
            [
              /\b(arm(?:v[67])?ht?n?[fl]p?)\b/i
              // ARMHF
            ],
            [[ARCHITECTURE, "armhf"]],
            [
              // PocketPC mistakenly identified as PowerPC
              /windows (ce|mobile); ppc;/i
            ],
            [[ARCHITECTURE, "arm"]],
            [
              /((?:ppc|powerpc)(?:64)?)(?: mac|;|\))/i
              // PowerPC
            ],
            [[ARCHITECTURE, /ower/, EMPTY, lowerize]],
            [
              /(sun4\w)[;\)]/i
              // SPARC
            ],
            [[ARCHITECTURE, "sparc"]],
            [
              /((?:avr32|ia64(?=;))|68k(?=\))|\barm(?=v(?:[1-7]|[5-7]1)l?|;|eabi)|(?=atmel )avr|(?:irix|mips|sparc)(?:64)?\b|pa-risc)/i
              // IA64, 68K, ARM/64, AVR/32, IRIX/64, MIPS/64, SPARC/64, PA-RISC
            ],
            [[ARCHITECTURE, lowerize]]
          ],
          device: [
            [
              //////////////////////////
              // MOBILES & TABLETS
              /////////////////////////
              // Samsung
              /\b(sch-i[89]0\d|shw-m380s|sm-[ptx]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i
            ],
            [MODEL, [VENDOR, SAMSUNG], [TYPE, TABLET]],
            [
              /\b((?:s[cgp]h|gt|sm)-\w+|sc[g-]?[\d]+a?|galaxy nexus)/i,
              /samsung[- ]([-\w]+)/i,
              /sec-(sgh\w+)/i
            ],
            [MODEL, [VENDOR, SAMSUNG], [TYPE, MOBILE]],
            [
              // Apple
              /(?:\/|\()(ip(?:hone|od)[\w, ]*)(?:\/|;)/i
              // iPod/iPhone
            ],
            [MODEL, [VENDOR, APPLE], [TYPE, MOBILE]],
            [
              /\((ipad);[-\w\),; ]+apple/i,
              // iPad
              /applecoremedia\/[\w\.]+ \((ipad)/i,
              /\b(ipad)\d\d?,\d\d?[;\]].+ios/i
            ],
            [MODEL, [VENDOR, APPLE], [TYPE, TABLET]],
            [
              /(macintosh);/i
            ],
            [MODEL, [VENDOR, APPLE]],
            [
              // Sharp
              /\b(sh-?[altvz]?\d\d[a-ekm]?)/i
            ],
            [MODEL, [VENDOR, SHARP], [TYPE, MOBILE]],
            [
              // Huawei
              /\b((?:ag[rs][23]?|bah2?|sht?|btv)-a?[lw]\d{2})\b(?!.+d\/s)/i
            ],
            [MODEL, [VENDOR, HUAWEI], [TYPE, TABLET]],
            [
              /(?:huawei|honor)([-\w ]+)[;\)]/i,
              /\b(nexus 6p|\w{2,4}e?-[atu]?[ln][\dx][012359c][adn]?)\b(?!.+d\/s)/i
            ],
            [MODEL, [VENDOR, HUAWEI], [TYPE, MOBILE]],
            [
              // Xiaomi
              /\b(poco[\w ]+|m2\d{3}j\d\d[a-z]{2})(?: bui|\))/i,
              // Xiaomi POCO
              /\b; (\w+) build\/hm\1/i,
              // Xiaomi Hongmi 'numeric' models
              /\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i,
              // Xiaomi Hongmi
              /\b(redmi[\-_ ]?(?:note|k)?[\w_ ]+)(?: bui|\))/i,
              // Xiaomi Redmi
              /oid[^\)]+; (m?[12][0-389][01]\w{3,6}[c-y])( bui|; wv|\))/i,
              // Xiaomi Redmi 'numeric' models
              /\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note lte|max|cc)?[_ ]?(?:\d?\w?)[_ ]?(?:plus|se|lite)?)(?: bui|\))/i
              // Xiaomi Mi
            ],
            [[MODEL, /_/g, " "], [VENDOR, XIAOMI], [TYPE, MOBILE]],
            [
              /oid[^\)]+; (2\d{4}(283|rpbf)[cgl])( bui|\))/i,
              // Redmi Pad
              /\b(mi[-_ ]?(?:pad)(?:[\w_ ]+))(?: bui|\))/i
              // Mi Pad tablets
            ],
            [[MODEL, /_/g, " "], [VENDOR, XIAOMI], [TYPE, TABLET]],
            [
              // OPPO
              /; (\w+) bui.+ oppo/i,
              /\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007|a101op)\b/i
            ],
            [MODEL, [VENDOR, "OPPO"], [TYPE, MOBILE]],
            [
              /\b(opd2\d{3}a?) bui/i
            ],
            [MODEL, [VENDOR, "OPPO"], [TYPE, TABLET]],
            [
              // Vivo
              /vivo (\w+)(?: bui|\))/i,
              /\b(v[12]\d{3}\w?[at])(?: bui|;)/i
            ],
            [MODEL, [VENDOR, "Vivo"], [TYPE, MOBILE]],
            [
              // Realme
              /\b(rmx[1-3]\d{3})(?: bui|;|\))/i
            ],
            [MODEL, [VENDOR, "Realme"], [TYPE, MOBILE]],
            [
              // Motorola
              /\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i,
              /\bmot(?:orola)?[- ](\w*)/i,
              /((?:moto[\w\(\) ]+|xt\d{3,4}|nexus 6)(?= bui|\)))/i
            ],
            [MODEL, [VENDOR, MOTOROLA], [TYPE, MOBILE]],
            [
              /\b(mz60\d|xoom[2 ]{0,2}) build\//i
            ],
            [MODEL, [VENDOR, MOTOROLA], [TYPE, TABLET]],
            [
              // LG
              /((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i
            ],
            [MODEL, [VENDOR, LG], [TYPE, TABLET]],
            [
              /(lm(?:-?f100[nv]?|-[\w\.]+)(?= bui|\))|nexus [45])/i,
              /\blg[-e;\/ ]+((?!browser|netcast|android tv)\w+)/i,
              /\blg-?([\d\w]+) bui/i
            ],
            [MODEL, [VENDOR, LG], [TYPE, MOBILE]],
            [
              // Lenovo
              /(ideatab[-\w ]+)/i,
              /lenovo ?(s[56]000[-\w]+|tab(?:[\w ]+)|yt[-\d\w]{6}|tb[-\d\w]{6})/i
            ],
            [MODEL, [VENDOR, "Lenovo"], [TYPE, TABLET]],
            [
              // Nokia
              /(?:maemo|nokia).*(n900|lumia \d+)/i,
              /nokia[-_ ]?([-\w\.]*)/i
            ],
            [[MODEL, /_/g, " "], [VENDOR, "Nokia"], [TYPE, MOBILE]],
            [
              // Google
              /(pixel c)\b/i
              // Google Pixel C
            ],
            [MODEL, [VENDOR, GOOGLE], [TYPE, TABLET]],
            [
              /droid.+; (pixel[\daxl ]{0,6})(?: bui|\))/i
              // Google Pixel
            ],
            [MODEL, [VENDOR, GOOGLE], [TYPE, MOBILE]],
            [
              // Sony
              /droid.+ (a?\d[0-2]{2}so|[c-g]\d{4}|so[-gl]\w+|xq-a\w[4-7][12])(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i
            ],
            [MODEL, [VENDOR, SONY], [TYPE, MOBILE]],
            [
              /sony tablet [ps]/i,
              /\b(?:sony)?sgp\w+(?: bui|\))/i
            ],
            [[MODEL, "Xperia Tablet"], [VENDOR, SONY], [TYPE, TABLET]],
            [
              // OnePlus
              / (kb2005|in20[12]5|be20[12][59])\b/i,
              /(?:one)?(?:plus)? (a\d0\d\d)(?: b|\))/i
            ],
            [MODEL, [VENDOR, "OnePlus"], [TYPE, MOBILE]],
            [
              // Amazon
              /(alexa)webm/i,
              /(kf[a-z]{2}wi|aeo[c-r]{2})( bui|\))/i,
              // Kindle Fire without Silk / Echo Show
              /(kf[a-z]+)( bui|\)).+silk\//i
              // Kindle Fire HD
            ],
            [MODEL, [VENDOR, AMAZON], [TYPE, TABLET]],
            [
              /((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i
              // Fire Phone
            ],
            [[MODEL, /(.+)/g, "Fire Phone $1"], [VENDOR, AMAZON], [TYPE, MOBILE]],
            [
              // BlackBerry
              /(playbook);[-\w\),; ]+(rim)/i
              // BlackBerry PlayBook
            ],
            [MODEL, VENDOR, [TYPE, TABLET]],
            [
              /\b((?:bb[a-f]|st[hv])100-\d)/i,
              /\(bb10; (\w+)/i
              // BlackBerry 10
            ],
            [MODEL, [VENDOR, BLACKBERRY], [TYPE, MOBILE]],
            [
              // Asus
              /(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i
            ],
            [MODEL, [VENDOR, ASUS], [TYPE, TABLET]],
            [
              / (z[bes]6[027][012][km][ls]|zenfone \d\w?)\b/i
            ],
            [MODEL, [VENDOR, ASUS], [TYPE, MOBILE]],
            [
              // HTC
              /(nexus 9)/i
              // HTC Nexus 9
            ],
            [MODEL, [VENDOR, "HTC"], [TYPE, TABLET]],
            [
              /(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i,
              // HTC
              // ZTE
              /(zte)[- ]([\w ]+?)(?: bui|\/|\))/i,
              /(alcatel|geeksphone|nexian|panasonic(?!(?:;|\.))|sony(?!-bra))[-_ ]?([-\w]*)/i
              // Alcatel/GeeksPhone/Nexian/Panasonic/Sony
            ],
            [VENDOR, [MODEL, /_/g, " "], [TYPE, MOBILE]],
            [
              // Acer
              /droid.+; ([ab][1-7]-?[0178a]\d\d?)/i
            ],
            [MODEL, [VENDOR, "Acer"], [TYPE, TABLET]],
            [
              // Meizu
              /droid.+; (m[1-5] note) bui/i,
              /\bmz-([-\w]{2,})/i
            ],
            [MODEL, [VENDOR, "Meizu"], [TYPE, MOBILE]],
            [
              // Ulefone
              /; ((?:power )?armor(?:[\w ]{0,8}))(?: bui|\))/i
            ],
            [MODEL, [VENDOR, "Ulefone"], [TYPE, MOBILE]],
            [
              // MIXED
              /(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron|infinix|tecno)[-_ ]?([-\w]*)/i,
              // BlackBerry/BenQ/Palm/Sony-Ericsson/Acer/Asus/Dell/Meizu/Motorola/Polytron
              /(hp) ([\w ]+\w)/i,
              // HP iPAQ
              /(asus)-?(\w+)/i,
              // Asus
              /(microsoft); (lumia[\w ]+)/i,
              // Microsoft Lumia
              /(lenovo)[-_ ]?([-\w]+)/i,
              // Lenovo
              /(jolla)/i,
              // Jolla
              /(oppo) ?([\w ]+) bui/i
              // OPPO
            ],
            [VENDOR, MODEL, [TYPE, MOBILE]],
            [
              /(kobo)\s(ereader|touch)/i,
              // Kobo
              /(archos) (gamepad2?)/i,
              // Archos
              /(hp).+(touchpad(?!.+tablet)|tablet)/i,
              // HP TouchPad
              /(kindle)\/([\w\.]+)/i,
              // Kindle
              /(nook)[\w ]+build\/(\w+)/i,
              // Nook
              /(dell) (strea[kpr\d ]*[\dko])/i,
              // Dell Streak
              /(le[- ]+pan)[- ]+(\w{1,9}) bui/i,
              // Le Pan Tablets
              /(trinity)[- ]*(t\d{3}) bui/i,
              // Trinity Tablets
              /(gigaset)[- ]+(q\w{1,9}) bui/i,
              // Gigaset Tablets
              /(vodafone) ([\w ]+)(?:\)| bui)/i
              // Vodafone
            ],
            [VENDOR, MODEL, [TYPE, TABLET]],
            [
              /(surface duo)/i
              // Surface Duo
            ],
            [MODEL, [VENDOR, MICROSOFT], [TYPE, TABLET]],
            [
              /droid [\d\.]+; (fp\du?)(?: b|\))/i
              // Fairphone
            ],
            [MODEL, [VENDOR, "Fairphone"], [TYPE, MOBILE]],
            [
              /(u304aa)/i
              // AT&T
            ],
            [MODEL, [VENDOR, "AT&T"], [TYPE, MOBILE]],
            [
              /\bsie-(\w*)/i
              // Siemens
            ],
            [MODEL, [VENDOR, "Siemens"], [TYPE, MOBILE]],
            [
              /\b(rct\w+) b/i
              // RCA Tablets
            ],
            [MODEL, [VENDOR, "RCA"], [TYPE, TABLET]],
            [
              /\b(venue[\d ]{2,7}) b/i
              // Dell Venue Tablets
            ],
            [MODEL, [VENDOR, "Dell"], [TYPE, TABLET]],
            [
              /\b(q(?:mv|ta)\w+) b/i
              // Verizon Tablet
            ],
            [MODEL, [VENDOR, "Verizon"], [TYPE, TABLET]],
            [
              /\b(?:barnes[& ]+noble |bn[rt])([\w\+ ]*) b/i
              // Barnes & Noble Tablet
            ],
            [MODEL, [VENDOR, "Barnes & Noble"], [TYPE, TABLET]],
            [
              /\b(tm\d{3}\w+) b/i
            ],
            [MODEL, [VENDOR, "NuVision"], [TYPE, TABLET]],
            [
              /\b(k88) b/i
              // ZTE K Series Tablet
            ],
            [MODEL, [VENDOR, "ZTE"], [TYPE, TABLET]],
            [
              /\b(nx\d{3}j) b/i
              // ZTE Nubia
            ],
            [MODEL, [VENDOR, "ZTE"], [TYPE, MOBILE]],
            [
              /\b(gen\d{3}) b.+49h/i
              // Swiss GEN Mobile
            ],
            [MODEL, [VENDOR, "Swiss"], [TYPE, MOBILE]],
            [
              /\b(zur\d{3}) b/i
              // Swiss ZUR Tablet
            ],
            [MODEL, [VENDOR, "Swiss"], [TYPE, TABLET]],
            [
              /\b((zeki)?tb.*\b) b/i
              // Zeki Tablets
            ],
            [MODEL, [VENDOR, "Zeki"], [TYPE, TABLET]],
            [
              /\b([yr]\d{2}) b/i,
              /\b(dragon[- ]+touch |dt)(\w{5}) b/i
              // Dragon Touch Tablet
            ],
            [[VENDOR, "Dragon Touch"], MODEL, [TYPE, TABLET]],
            [
              /\b(ns-?\w{0,9}) b/i
              // Insignia Tablets
            ],
            [MODEL, [VENDOR, "Insignia"], [TYPE, TABLET]],
            [
              /\b((nxa|next)-?\w{0,9}) b/i
              // NextBook Tablets
            ],
            [MODEL, [VENDOR, "NextBook"], [TYPE, TABLET]],
            [
              /\b(xtreme\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i
              // Voice Xtreme Phones
            ],
            [[VENDOR, "Voice"], MODEL, [TYPE, MOBILE]],
            [
              /\b(lvtel\-)?(v1[12]) b/i
              // LvTel Phones
            ],
            [[VENDOR, "LvTel"], MODEL, [TYPE, MOBILE]],
            [
              /\b(ph-1) /i
              // Essential PH-1
            ],
            [MODEL, [VENDOR, "Essential"], [TYPE, MOBILE]],
            [
              /\b(v(100md|700na|7011|917g).*\b) b/i
              // Envizen Tablets
            ],
            [MODEL, [VENDOR, "Envizen"], [TYPE, TABLET]],
            [
              /\b(trio[-\w\. ]+) b/i
              // MachSpeed Tablets
            ],
            [MODEL, [VENDOR, "MachSpeed"], [TYPE, TABLET]],
            [
              /\btu_(1491) b/i
              // Rotor Tablets
            ],
            [MODEL, [VENDOR, "Rotor"], [TYPE, TABLET]],
            [
              /(shield[\w ]+) b/i
              // Nvidia Shield Tablets
            ],
            [MODEL, [VENDOR, "Nvidia"], [TYPE, TABLET]],
            [
              /(sprint) (\w+)/i
              // Sprint Phones
            ],
            [VENDOR, MODEL, [TYPE, MOBILE]],
            [
              /(kin\.[onetw]{3})/i
              // Microsoft Kin
            ],
            [[MODEL, /\./g, " "], [VENDOR, MICROSOFT], [TYPE, MOBILE]],
            [
              /droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i
              // Zebra
            ],
            [MODEL, [VENDOR, ZEBRA], [TYPE, TABLET]],
            [
              /droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i
            ],
            [MODEL, [VENDOR, ZEBRA], [TYPE, MOBILE]],
            [
              ///////////////////
              // SMARTTVS
              ///////////////////
              /smart-tv.+(samsung)/i
              // Samsung
            ],
            [VENDOR, [TYPE, SMARTTV]],
            [
              /hbbtv.+maple;(\d+)/i
            ],
            [[MODEL, /^/, "SmartTV"], [VENDOR, SAMSUNG], [TYPE, SMARTTV]],
            [
              /(nux; netcast.+smarttv|lg (netcast\.tv-201\d|android tv))/i
              // LG SmartTV
            ],
            [[VENDOR, LG], [TYPE, SMARTTV]],
            [
              /(apple) ?tv/i
              // Apple TV
            ],
            [VENDOR, [MODEL, APPLE + " TV"], [TYPE, SMARTTV]],
            [
              /crkey/i
              // Google Chromecast
            ],
            [[MODEL, CHROME + "cast"], [VENDOR, GOOGLE], [TYPE, SMARTTV]],
            [
              /droid.+aft(\w+)( bui|\))/i
              // Fire TV
            ],
            [MODEL, [VENDOR, AMAZON], [TYPE, SMARTTV]],
            [
              /\(dtv[\);].+(aquos)/i,
              /(aquos-tv[\w ]+)\)/i
              // Sharp
            ],
            [MODEL, [VENDOR, SHARP], [TYPE, SMARTTV]],
            [
              /(bravia[\w ]+)( bui|\))/i
              // Sony
            ],
            [MODEL, [VENDOR, SONY], [TYPE, SMARTTV]],
            [
              /(mitv-\w{5}) bui/i
              // Xiaomi
            ],
            [MODEL, [VENDOR, XIAOMI], [TYPE, SMARTTV]],
            [
              /Hbbtv.*(technisat) (.*);/i
              // TechniSAT
            ],
            [VENDOR, MODEL, [TYPE, SMARTTV]],
            [
              /\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i,
              // Roku
              /hbbtv\/\d+\.\d+\.\d+ +\([\w\+ ]*; *([\w\d][^;]*);([^;]*)/i
              // HbbTV devices
            ],
            [[VENDOR, trim], [MODEL, trim], [TYPE, SMARTTV]],
            [
              /\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\b/i
              // SmartTV from Unidentified Vendors
            ],
            [[TYPE, SMARTTV]],
            [
              ///////////////////
              // CONSOLES
              ///////////////////
              /(ouya)/i,
              // Ouya
              /(nintendo) ([wids3utch]+)/i
              // Nintendo
            ],
            [VENDOR, MODEL, [TYPE, CONSOLE]],
            [
              /droid.+; (shield) bui/i
              // Nvidia
            ],
            [MODEL, [VENDOR, "Nvidia"], [TYPE, CONSOLE]],
            [
              /(playstation [345portablevi]+)/i
              // Playstation
            ],
            [MODEL, [VENDOR, SONY], [TYPE, CONSOLE]],
            [
              /\b(xbox(?: one)?(?!; xbox))[\); ]/i
              // Microsoft Xbox
            ],
            [MODEL, [VENDOR, MICROSOFT], [TYPE, CONSOLE]],
            [
              ///////////////////
              // WEARABLES
              ///////////////////
              /((pebble))app/i
              // Pebble
            ],
            [VENDOR, MODEL, [TYPE, WEARABLE]],
            [
              /(watch)(?: ?os[,\/]|\d,\d\/)[\d\.]+/i
              // Apple Watch
            ],
            [MODEL, [VENDOR, APPLE], [TYPE, WEARABLE]],
            [
              /droid.+; (glass) \d/i
              // Google Glass
            ],
            [MODEL, [VENDOR, GOOGLE], [TYPE, WEARABLE]],
            [
              /droid.+; (wt63?0{2,3})\)/i
            ],
            [MODEL, [VENDOR, ZEBRA], [TYPE, WEARABLE]],
            [
              /(quest( \d| pro)?)/i
              // Oculus Quest
            ],
            [MODEL, [VENDOR, FACEBOOK], [TYPE, WEARABLE]],
            [
              ///////////////////
              // EMBEDDED
              ///////////////////
              /(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i
              // Tesla
            ],
            [VENDOR, [TYPE, EMBEDDED]],
            [
              /(aeobc)\b/i
              // Echo Dot
            ],
            [MODEL, [VENDOR, AMAZON], [TYPE, EMBEDDED]],
            [
              ////////////////////
              // MIXED (GENERIC)
              ///////////////////
              /droid .+?; ([^;]+?)(?: bui|; wv\)|\) applew).+? mobile safari/i
              // Android Phones from Unidentified Vendors
            ],
            [MODEL, [TYPE, MOBILE]],
            [
              /droid .+?; ([^;]+?)(?: bui|\) applew).+?(?! mobile) safari/i
              // Android Tablets from Unidentified Vendors
            ],
            [MODEL, [TYPE, TABLET]],
            [
              /\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i
              // Unidentifiable Tablet
            ],
            [[TYPE, TABLET]],
            [
              /(phone|mobile(?:[;\/]| [ \w\/\.]*safari)|pda(?=.+windows ce))/i
              // Unidentifiable Mobile
            ],
            [[TYPE, MOBILE]],
            [
              /(android[-\w\. ]{0,9});.+buil/i
              // Generic Android Device
            ],
            [MODEL, [VENDOR, "Generic"]]
          ],
          engine: [
            [
              /windows.+ edge\/([\w\.]+)/i
              // EdgeHTML
            ],
            [VERSION, [NAME, EDGE + "HTML"]],
            [
              /webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i
              // Blink
            ],
            [VERSION, [NAME, "Blink"]],
            [
              /(presto)\/([\w\.]+)/i,
              // Presto
              /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna)\/([\w\.]+)/i,
              // WebKit/Trident/NetFront/NetSurf/Amaya/Lynx/w3m/Goanna
              /ekioh(flow)\/([\w\.]+)/i,
              // Flow
              /(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i,
              // KHTML/Tasman/Links
              /(icab)[\/ ]([23]\.[\d\.]+)/i,
              // iCab
              /\b(libweb)/i
            ],
            [NAME, VERSION],
            [
              /rv\:([\w\.]{1,9})\b.+(gecko)/i
              // Gecko
            ],
            [VERSION, NAME]
          ],
          os: [
            [
              // Windows
              /microsoft (windows) (vista|xp)/i
              // Windows (iTunes)
            ],
            [NAME, VERSION],
            [
              /(windows (?:phone(?: os)?|mobile))[\/ ]?([\d\.\w ]*)/i
              // Windows Phone
            ],
            [NAME, [VERSION, strMapper, windowsVersionMap]],
            [
              /windows nt 6\.2; (arm)/i,
              // Windows RT
              /windows[\/ ]?([ntce\d\. ]+\w)(?!.+xbox)/i,
              /(?:win(?=3|9|n)|win 9x )([nt\d\.]+)/i
            ],
            [[VERSION, strMapper, windowsVersionMap], [NAME, "Windows"]],
            [
              // iOS/macOS
              /ip[honead]{2,4}\b(?:.*os ([\w]+) like mac|; opera)/i,
              // iOS
              /(?:ios;fbsv\/|iphone.+ios[\/ ])([\d\.]+)/i,
              /cfnetwork\/.+darwin/i
            ],
            [[VERSION, /_/g, "."], [NAME, "iOS"]],
            [
              /(mac os x) ?([\w\. ]*)/i,
              /(macintosh|mac_powerpc\b)(?!.+haiku)/i
              // Mac OS
            ],
            [[NAME, MAC_OS], [VERSION, /_/g, "."]],
            [
              // Mobile OSes
              /droid ([\w\.]+)\b.+(android[- ]x86|harmonyos)/i
              // Android-x86/HarmonyOS
            ],
            [VERSION, NAME],
            [
              // Android/WebOS/QNX/Bada/RIM/Maemo/MeeGo/Sailfish OS
              /(android|webos|qnx|bada|rim tablet os|maemo|meego|sailfish)[-\/ ]?([\w\.]*)/i,
              /(blackberry)\w*\/([\w\.]*)/i,
              // Blackberry
              /(tizen|kaios)[\/ ]([\w\.]+)/i,
              // Tizen/KaiOS
              /\((series40);/i
              // Series 40
            ],
            [NAME, VERSION],
            [
              /\(bb(10);/i
              // BlackBerry 10
            ],
            [VERSION, [NAME, BLACKBERRY]],
            [
              /(?:symbian ?os|symbos|s60(?=;)|series60)[-\/ ]?([\w\.]*)/i
              // Symbian
            ],
            [VERSION, [NAME, "Symbian"]],
            [
              /mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i
              // Firefox OS
            ],
            [VERSION, [NAME, FIREFOX + " OS"]],
            [
              /web0s;.+rt(tv)/i,
              /\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i
              // WebOS
            ],
            [VERSION, [NAME, "webOS"]],
            [
              /watch(?: ?os[,\/]|\d,\d\/)([\d\.]+)/i
              // watchOS
            ],
            [VERSION, [NAME, "watchOS"]],
            [
              // Google Chromecast
              /crkey\/([\d\.]+)/i
              // Google Chromecast
            ],
            [VERSION, [NAME, CHROME + "cast"]],
            [
              /(cros) [\w]+(?:\)| ([\w\.]+)\b)/i
              // Chromium OS
            ],
            [[NAME, CHROMIUM_OS], VERSION],
            [
              // Smart TVs
              /panasonic;(viera)/i,
              // Panasonic Viera
              /(netrange)mmh/i,
              // Netrange
              /(nettv)\/(\d+\.[\w\.]+)/i,
              // NetTV
              // Console
              /(nintendo|playstation) ([wids345portablevuch]+)/i,
              // Nintendo/Playstation
              /(xbox); +xbox ([^\);]+)/i,
              // Microsoft Xbox (360, One, X, S, Series X, Series S)
              // Other
              /\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i,
              // Joli/Palm
              /(mint)[\/\(\) ]?(\w*)/i,
              // Mint
              /(mageia|vectorlinux)[; ]/i,
              // Mageia/VectorLinux
              /([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i,
              // Ubuntu/Debian/SUSE/Gentoo/Arch/Slackware/Fedora/Mandriva/CentOS/PCLinuxOS/RedHat/Zenwalk/Linpus/Raspbian/Plan9/Minix/RISCOS/Contiki/Deepin/Manjaro/elementary/Sabayon/Linspire
              /(hurd|linux) ?([\w\.]*)/i,
              // Hurd/Linux
              /(gnu) ?([\w\.]*)/i,
              // GNU
              /\b([-frentopcghs]{0,5}bsd|dragonfly)[\/ ]?(?!amd|[ix346]{1,2}86)([\w\.]*)/i,
              // FreeBSD/NetBSD/OpenBSD/PC-BSD/GhostBSD/DragonFly
              /(haiku) (\w+)/i
              // Haiku
            ],
            [NAME, VERSION],
            [
              /(sunos) ?([\w\.\d]*)/i
              // Solaris
            ],
            [[NAME, "Solaris"], VERSION],
            [
              /((?:open)?solaris)[-\/ ]?([\w\.]*)/i,
              // Solaris
              /(aix) ((\d)(?=\.|\)| )[\w\.])*/i,
              // AIX
              /\b(beos|os\/2|amigaos|morphos|openvms|fuchsia|hp-ux|serenityos)/i,
              // BeOS/OS2/AmigaOS/MorphOS/OpenVMS/Fuchsia/HP-UX/SerenityOS
              /(unix) ?([\w\.]*)/i
              // UNIX
            ],
            [NAME, VERSION]
          ]
        };
        var UAParser = function(ua, extensions) {
          if (typeof ua === OBJ_TYPE) {
            extensions = ua;
            ua = undefined2;
          }
          if (!(this instanceof UAParser)) {
            return new UAParser(ua, extensions).getResult();
          }
          var _navigator = typeof window2 !== UNDEF_TYPE && window2.navigator ? window2.navigator : undefined2;
          var _ua = ua || (_navigator && _navigator.userAgent ? _navigator.userAgent : EMPTY);
          var _uach = _navigator && _navigator.userAgentData ? _navigator.userAgentData : undefined2;
          var _rgxmap = extensions ? extend(regexes, extensions) : regexes;
          var _isSelfNav = _navigator && _navigator.userAgent == _ua;
          this.getBrowser = function() {
            var _browser = {};
            _browser[NAME] = undefined2;
            _browser[VERSION] = undefined2;
            rgxMapper.call(_browser, _ua, _rgxmap.browser);
            _browser[MAJOR] = majorize(_browser[VERSION]);
            if (_isSelfNav && _navigator && _navigator.brave && typeof _navigator.brave.isBrave == FUNC_TYPE) {
              _browser[NAME] = "Brave";
            }
            return _browser;
          };
          this.getCPU = function() {
            var _cpu = {};
            _cpu[ARCHITECTURE] = undefined2;
            rgxMapper.call(_cpu, _ua, _rgxmap.cpu);
            return _cpu;
          };
          this.getDevice = function() {
            var _device = {};
            _device[VENDOR] = undefined2;
            _device[MODEL] = undefined2;
            _device[TYPE] = undefined2;
            rgxMapper.call(_device, _ua, _rgxmap.device);
            if (_isSelfNav && !_device[TYPE] && _uach && _uach.mobile) {
              _device[TYPE] = MOBILE;
            }
            if (_isSelfNav && _device[MODEL] == "Macintosh" && _navigator && typeof _navigator.standalone !== UNDEF_TYPE && _navigator.maxTouchPoints && _navigator.maxTouchPoints > 2) {
              _device[MODEL] = "iPad";
              _device[TYPE] = TABLET;
            }
            return _device;
          };
          this.getEngine = function() {
            var _engine = {};
            _engine[NAME] = undefined2;
            _engine[VERSION] = undefined2;
            rgxMapper.call(_engine, _ua, _rgxmap.engine);
            return _engine;
          };
          this.getOS = function() {
            var _os = {};
            _os[NAME] = undefined2;
            _os[VERSION] = undefined2;
            rgxMapper.call(_os, _ua, _rgxmap.os);
            if (_isSelfNav && !_os[NAME] && _uach && _uach.platform && _uach.platform != "Unknown") {
              _os[NAME] = _uach.platform.replace(/chrome os/i, CHROMIUM_OS).replace(/macos/i, MAC_OS);
            }
            return _os;
          };
          this.getResult = function() {
            return {
              ua: this.getUA(),
              browser: this.getBrowser(),
              engine: this.getEngine(),
              os: this.getOS(),
              device: this.getDevice(),
              cpu: this.getCPU()
            };
          };
          this.getUA = function() {
            return _ua;
          };
          this.setUA = function(ua2) {
            _ua = typeof ua2 === STR_TYPE && ua2.length > UA_MAX_LENGTH ? trim(ua2, UA_MAX_LENGTH) : ua2;
            return this;
          };
          this.setUA(_ua);
          return this;
        };
        UAParser.VERSION = LIBVERSION;
        UAParser.BROWSER = enumerize([NAME, VERSION, MAJOR]);
        UAParser.CPU = enumerize([ARCHITECTURE]);
        UAParser.DEVICE = enumerize([MODEL, VENDOR, TYPE, CONSOLE, MOBILE, SMARTTV, TABLET, WEARABLE, EMBEDDED]);
        UAParser.ENGINE = UAParser.OS = enumerize([NAME, VERSION]);
        if (typeof exports !== UNDEF_TYPE) {
          if (typeof module !== UNDEF_TYPE && module.exports) {
            exports = module.exports = UAParser;
          }
          exports.UAParser = UAParser;
        } else {
          if (typeof define === FUNC_TYPE && define.amd) {
            define(function() {
              return UAParser;
            });
          } else if (typeof window2 !== UNDEF_TYPE) {
            window2.UAParser = UAParser;
          }
        }
        var $ = typeof window2 !== UNDEF_TYPE && (window2.jQuery || window2.Zepto);
        if ($ && !$.ua) {
          var parser = new UAParser();
          $.ua = parser.getResult();
          $.ua.get = function() {
            return parser.getUA();
          };
          $.ua.set = function(ua) {
            parser.setUA(ua);
            var result = parser.getResult();
            for (var prop in result) {
              $.ua[prop] = result[prop];
            }
          };
        }
      })(typeof window === "object" ? window : exports);
    }
  });

  // ../../node_modules/mediasoup-client/lib/Logger.js
  var require_Logger = __commonJS({
    "../../node_modules/mediasoup-client/lib/Logger.js"(exports) {
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Logger = void 0;
      var debug_1 = __importDefault(require_browser());
      var APP_NAME = "mediasoup-client";
      var Logger = class {
        constructor(prefix) {
          if (prefix) {
            this._debug = (0, debug_1.default)(`${APP_NAME}:${prefix}`);
            this._warn = (0, debug_1.default)(`${APP_NAME}:WARN:${prefix}`);
            this._error = (0, debug_1.default)(`${APP_NAME}:ERROR:${prefix}`);
          } else {
            this._debug = (0, debug_1.default)(APP_NAME);
            this._warn = (0, debug_1.default)(`${APP_NAME}:WARN`);
            this._error = (0, debug_1.default)(`${APP_NAME}:ERROR`);
          }
          this._debug.log = console.info.bind(console);
          this._warn.log = console.warn.bind(console);
          this._error.log = console.error.bind(console);
        }
        get debug() {
          return this._debug;
        }
        get warn() {
          return this._warn;
        }
        get error() {
          return this._error;
        }
      };
      exports.Logger = Logger;
    }
  });

  // ../../node_modules/npm-events-package/events.js
  var require_events = __commonJS({
    "../../node_modules/npm-events-package/events.js"(exports, module) {
      var R = typeof Reflect === "object" ? Reflect : null;
      var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
        return Function.prototype.apply.call(target, receiver, args);
      };
      var ReflectOwnKeys;
      if (R && typeof R.ownKeys === "function") {
        ReflectOwnKeys = R.ownKeys;
      } else if (Object.getOwnPropertySymbols) {
        ReflectOwnKeys = function ReflectOwnKeys2(target) {
          return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
        };
      } else {
        ReflectOwnKeys = function ReflectOwnKeys2(target) {
          return Object.getOwnPropertyNames(target);
        };
      }
      function ProcessEmitWarning(warning) {
        if (console && console.warn) console.warn(warning);
      }
      var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
        return value !== value;
      };
      function EventEmitter2() {
        EventEmitter2.init.call(this);
      }
      module.exports = EventEmitter2;
      module.exports.once = once;
      EventEmitter2.EventEmitter = EventEmitter2;
      EventEmitter2.prototype._events = void 0;
      EventEmitter2.prototype._eventsCount = 0;
      EventEmitter2.prototype._maxListeners = void 0;
      var defaultMaxListeners = 10;
      function checkListener(listener) {
        if (typeof listener !== "function") {
          throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
        }
      }
      Object.defineProperty(EventEmitter2, "defaultMaxListeners", {
        enumerable: true,
        get: function() {
          return defaultMaxListeners;
        },
        set: function(arg) {
          if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
            throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
          }
          defaultMaxListeners = arg;
        }
      });
      EventEmitter2.init = function() {
        if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        }
        this._maxListeners = this._maxListeners || void 0;
      };
      EventEmitter2.prototype.setMaxListeners = function setMaxListeners(n) {
        if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
          throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
        }
        this._maxListeners = n;
        return this;
      };
      function _getMaxListeners(that) {
        if (that._maxListeners === void 0)
          return EventEmitter2.defaultMaxListeners;
        return that._maxListeners;
      }
      EventEmitter2.prototype.getMaxListeners = function getMaxListeners() {
        return _getMaxListeners(this);
      };
      EventEmitter2.prototype.emit = function emit(type) {
        var args = [];
        for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
        var doError = type === "error";
        var events = this._events;
        if (events !== void 0)
          doError = doError && events.error === void 0;
        else if (!doError)
          return false;
        if (doError) {
          var er;
          if (args.length > 0)
            er = args[0];
          if (er instanceof Error) {
            throw er;
          }
          var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
          err.context = er;
          throw err;
        }
        var handler = events[type];
        if (handler === void 0)
          return false;
        if (typeof handler === "function") {
          ReflectApply(handler, this, args);
        } else {
          var len = handler.length;
          var listeners = arrayClone(handler, len);
          for (var i = 0; i < len; ++i)
            ReflectApply(listeners[i], this, args);
        }
        return true;
      };
      function _addListener(target, type, listener, prepend) {
        var m;
        var events;
        var existing;
        checkListener(listener);
        events = target._events;
        if (events === void 0) {
          events = target._events = /* @__PURE__ */ Object.create(null);
          target._eventsCount = 0;
        } else {
          if (events.newListener !== void 0) {
            target.emit(
              "newListener",
              type,
              listener.listener ? listener.listener : listener
            );
            events = target._events;
          }
          existing = events[type];
        }
        if (existing === void 0) {
          existing = events[type] = listener;
          ++target._eventsCount;
        } else {
          if (typeof existing === "function") {
            existing = events[type] = prepend ? [listener, existing] : [existing, listener];
          } else if (prepend) {
            existing.unshift(listener);
          } else {
            existing.push(listener);
          }
          m = _getMaxListeners(target);
          if (m > 0 && existing.length > m && !existing.warned) {
            existing.warned = true;
            var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
            w.name = "MaxListenersExceededWarning";
            w.emitter = target;
            w.type = type;
            w.count = existing.length;
            ProcessEmitWarning(w);
          }
        }
        return target;
      }
      EventEmitter2.prototype.addListener = function addListener(type, listener) {
        return _addListener(this, type, listener, false);
      };
      EventEmitter2.prototype.on = EventEmitter2.prototype.addListener;
      EventEmitter2.prototype.prependListener = function prependListener(type, listener) {
        return _addListener(this, type, listener, true);
      };
      function onceWrapper() {
        if (!this.fired) {
          this.target.removeListener(this.type, this.wrapFn);
          this.fired = true;
          if (arguments.length === 0)
            return this.listener.call(this.target);
          return this.listener.apply(this.target, arguments);
        }
      }
      function _onceWrap(target, type, listener) {
        var state = { fired: false, wrapFn: void 0, target, type, listener };
        var wrapped = onceWrapper.bind(state);
        wrapped.listener = listener;
        state.wrapFn = wrapped;
        return wrapped;
      }
      EventEmitter2.prototype.once = function once2(type, listener) {
        checkListener(listener);
        this.on(type, _onceWrap(this, type, listener));
        return this;
      };
      EventEmitter2.prototype.prependOnceListener = function prependOnceListener(type, listener) {
        checkListener(listener);
        this.prependListener(type, _onceWrap(this, type, listener));
        return this;
      };
      EventEmitter2.prototype.removeListener = function removeListener(type, listener) {
        var list, events, position, i, originalListener;
        checkListener(listener);
        events = this._events;
        if (events === void 0)
          return this;
        list = events[type];
        if (list === void 0)
          return this;
        if (list === listener || list.listener === listener) {
          if (--this._eventsCount === 0)
            this._events = /* @__PURE__ */ Object.create(null);
          else {
            delete events[type];
            if (events.removeListener)
              this.emit("removeListener", type, list.listener || listener);
          }
        } else if (typeof list !== "function") {
          position = -1;
          for (i = list.length - 1; i >= 0; i--) {
            if (list[i] === listener || list[i].listener === listener) {
              originalListener = list[i].listener;
              position = i;
              break;
            }
          }
          if (position < 0)
            return this;
          if (position === 0)
            list.shift();
          else {
            spliceOne(list, position);
          }
          if (list.length === 1)
            events[type] = list[0];
          if (events.removeListener !== void 0)
            this.emit("removeListener", type, originalListener || listener);
        }
        return this;
      };
      EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
      EventEmitter2.prototype.removeAllListeners = function removeAllListeners(type) {
        var listeners, events, i;
        events = this._events;
        if (events === void 0)
          return this;
        if (events.removeListener === void 0) {
          if (arguments.length === 0) {
            this._events = /* @__PURE__ */ Object.create(null);
            this._eventsCount = 0;
          } else if (events[type] !== void 0) {
            if (--this._eventsCount === 0)
              this._events = /* @__PURE__ */ Object.create(null);
            else
              delete events[type];
          }
          return this;
        }
        if (arguments.length === 0) {
          var keys = Object.keys(events);
          var key;
          for (i = 0; i < keys.length; ++i) {
            key = keys[i];
            if (key === "removeListener") continue;
            this.removeAllListeners(key);
          }
          this.removeAllListeners("removeListener");
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
          return this;
        }
        listeners = events[type];
        if (typeof listeners === "function") {
          this.removeListener(type, listeners);
        } else if (listeners !== void 0) {
          for (i = listeners.length - 1; i >= 0; i--) {
            this.removeListener(type, listeners[i]);
          }
        }
        return this;
      };
      function _listeners(target, type, unwrap) {
        var events = target._events;
        if (events === void 0)
          return [];
        var evlistener = events[type];
        if (evlistener === void 0)
          return [];
        if (typeof evlistener === "function")
          return unwrap ? [evlistener.listener || evlistener] : [evlistener];
        return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
      }
      EventEmitter2.prototype.listeners = function listeners(type) {
        return _listeners(this, type, true);
      };
      EventEmitter2.prototype.rawListeners = function rawListeners(type) {
        return _listeners(this, type, false);
      };
      EventEmitter2.listenerCount = function(emitter, type) {
        if (typeof emitter.listenerCount === "function") {
          return emitter.listenerCount(type);
        } else {
          return listenerCount.call(emitter, type);
        }
      };
      EventEmitter2.prototype.listenerCount = listenerCount;
      function listenerCount(type) {
        var events = this._events;
        if (events !== void 0) {
          var evlistener = events[type];
          if (typeof evlistener === "function") {
            return 1;
          } else if (evlistener !== void 0) {
            return evlistener.length;
          }
        }
        return 0;
      }
      EventEmitter2.prototype.eventNames = function eventNames() {
        return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
      };
      function arrayClone(arr, n) {
        var copy = new Array(n);
        for (var i = 0; i < n; ++i)
          copy[i] = arr[i];
        return copy;
      }
      function spliceOne(list, index) {
        for (; index + 1 < list.length; index++)
          list[index] = list[index + 1];
        list.pop();
      }
      function unwrapListeners(arr) {
        var ret = new Array(arr.length);
        for (var i = 0; i < ret.length; ++i) {
          ret[i] = arr[i].listener || arr[i];
        }
        return ret;
      }
      function once(emitter, name) {
        return new Promise(function(resolve, reject) {
          function errorListener(err) {
            emitter.removeListener(name, resolver);
            reject(err);
          }
          function resolver() {
            if (typeof emitter.removeListener === "function") {
              emitter.removeListener("error", errorListener);
            }
            resolve([].slice.call(arguments));
          }
          eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
          if (name !== "error") {
            addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
          }
        });
      }
      function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
        if (typeof emitter.on === "function") {
          eventTargetAgnosticAddListener(emitter, "error", handler, flags);
        }
      }
      function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
        if (typeof emitter.on === "function") {
          if (flags.once) {
            emitter.once(name, listener);
          } else {
            emitter.on(name, listener);
          }
        } else if (typeof emitter.addEventListener === "function") {
          emitter.addEventListener(name, function wrapListener(arg) {
            if (flags.once) {
              emitter.removeEventListener(name, wrapListener);
            }
            listener(arg);
          });
        } else {
          throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
        }
      }
    }
  });

  // ../../node_modules/mediasoup-client/lib/enhancedEvents.js
  var require_enhancedEvents = __commonJS({
    "../../node_modules/mediasoup-client/lib/enhancedEvents.js"(exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.EnhancedEventEmitter = void 0;
      var npm_events_package_1 = require_events();
      var Logger_1 = require_Logger();
      var enhancedEventEmitterLogger = new Logger_1.Logger("EnhancedEventEmitter");
      var EnhancedEventEmitter2 = class extends npm_events_package_1.EventEmitter {
        constructor() {
          super();
          this.setMaxListeners(Infinity);
        }
        emit(eventName, ...args) {
          return super.emit(eventName, ...args);
        }
        /**
         * Special addition to the EventEmitter API.
         */
        safeEmit(eventName, ...args) {
          try {
            return super.emit(eventName, ...args);
          } catch (error) {
            enhancedEventEmitterLogger.error("safeEmit() | event listener threw an error [eventName:%s]:%o", eventName, error);
            try {
              super.emit("listenererror", eventName, error);
            } catch (error2) {
            }
            return Boolean(super.listenerCount(eventName));
          }
        }
        on(eventName, listener) {
          super.on(eventName, listener);
          return this;
        }
        off(eventName, listener) {
          super.off(eventName, listener);
          return this;
        }
        addListener(eventName, listener) {
          super.on(eventName, listener);
          return this;
        }
        prependListener(eventName, listener) {
          super.prependListener(eventName, listener);
          return this;
        }
        once(eventName, listener) {
          super.once(eventName, listener);
          return this;
        }
        prependOnceListener(eventName, listener) {
          super.prependOnceListener(eventName, listener);
          return this;
        }
        removeListener(eventName, listener) {
          super.off(eventName, listener);
          return this;
        }
        removeAllListeners(eventName) {
          super.removeAllListeners(eventName);
          return this;
        }
        listenerCount(eventName) {
          return super.listenerCount(eventName);
        }
        listeners(eventName) {
          return super.listeners(eventName);
        }
        rawListeners(eventName) {
          return super.rawListeners(eventName);
        }
      };
      exports.EnhancedEventEmitter = EnhancedEventEmitter2;
    }
  });

  // ../../node_modules/mediasoup-client/lib/errors.js
  var require_errors = __commonJS({
    "../../node_modules/mediasoup-client/lib/errors.js"(exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.InvalidStateError = exports.UnsupportedError = void 0;
      var UnsupportedError = class _UnsupportedError extends Error {
        constructor(message) {
          super(message);
          this.name = "UnsupportedError";
          if (Error.hasOwnProperty("captureStackTrace")) {
            Error.captureStackTrace(this, _UnsupportedError);
          } else {
            this.stack = new Error(message).stack;
          }
        }
      };
      exports.UnsupportedError = UnsupportedError;
      var InvalidStateError = class _InvalidStateError extends Error {
        constructor(message) {
          super(message);
          this.name = "InvalidStateError";
          if (Error.hasOwnProperty("captureStackTrace")) {
            Error.captureStackTrace(this, _InvalidStateError);
          } else {
            this.stack = new Error(message).stack;
          }
        }
      };
      exports.InvalidStateError = InvalidStateError;
    }
  });

  // ../../node_modules/mediasoup-client/lib/utils.js
  var require_utils = __commonJS({
    "../../node_modules/mediasoup-client/lib/utils.js"(exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.clone = clone;
      exports.generateRandomNumber = generateRandomNumber;
      exports.deepFreeze = deepFreeze;
      function clone(value) {
        if (value === void 0) {
          return void 0;
        } else if (Number.isNaN(value)) {
          return NaN;
        } else if (typeof structuredClone === "function") {
          return structuredClone(value);
        } else {
          return JSON.parse(JSON.stringify(value));
        }
      }
      function generateRandomNumber() {
        return Math.round(Math.random() * 1e7);
      }
      function deepFreeze(object) {
        const propNames = Reflect.ownKeys(object);
        for (const name of propNames) {
          const value = object[name];
          if (value && typeof value === "object" || typeof value === "function") {
            deepFreeze(value);
          }
        }
        return Object.freeze(object);
      }
    }
  });

  // ../../node_modules/debug/src/common.js
  var require_common2 = __commonJS({
    "../../node_modules/debug/src/common.js"(exports, module) {
      function setup(env) {
        createDebug.debug = createDebug;
        createDebug.default = createDebug;
        createDebug.coerce = coerce2;
        createDebug.disable = disable;
        createDebug.enable = enable;
        createDebug.enabled = enabled;
        createDebug.humanize = require_ms();
        createDebug.destroy = destroy;
        Object.keys(env).forEach((key) => {
          createDebug[key] = env[key];
        });
        createDebug.names = [];
        createDebug.skips = [];
        createDebug.formatters = {};
        function selectColor(namespace) {
          let hash = 0;
          for (let i = 0; i < namespace.length; i++) {
            hash = (hash << 5) - hash + namespace.charCodeAt(i);
            hash |= 0;
          }
          return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
        }
        createDebug.selectColor = selectColor;
        function createDebug(namespace) {
          let prevTime;
          let enableOverride = null;
          let namespacesCache;
          let enabledCache;
          function debug(...args) {
            if (!debug.enabled) {
              return;
            }
            const self = debug;
            const curr = Number(/* @__PURE__ */ new Date());
            const ms = curr - (prevTime || curr);
            self.diff = ms;
            self.prev = prevTime;
            self.curr = curr;
            prevTime = curr;
            args[0] = createDebug.coerce(args[0]);
            if (typeof args[0] !== "string") {
              args.unshift("%O");
            }
            let index = 0;
            args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
              if (match === "%%") {
                return "%";
              }
              index++;
              const formatter = createDebug.formatters[format];
              if (typeof formatter === "function") {
                const val = args[index];
                match = formatter.call(self, val);
                args.splice(index, 1);
                index--;
              }
              return match;
            });
            createDebug.formatArgs.call(self, args);
            const logFn = self.log || createDebug.log;
            logFn.apply(self, args);
          }
          debug.namespace = namespace;
          debug.useColors = createDebug.useColors();
          debug.color = createDebug.selectColor(namespace);
          debug.extend = extend;
          debug.destroy = createDebug.destroy;
          Object.defineProperty(debug, "enabled", {
            enumerable: true,
            configurable: false,
            get: () => {
              if (enableOverride !== null) {
                return enableOverride;
              }
              if (namespacesCache !== createDebug.namespaces) {
                namespacesCache = createDebug.namespaces;
                enabledCache = createDebug.enabled(namespace);
              }
              return enabledCache;
            },
            set: (v) => {
              enableOverride = v;
            }
          });
          if (typeof createDebug.init === "function") {
            createDebug.init(debug);
          }
          return debug;
        }
        function extend(namespace, delimiter) {
          const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
          newDebug.log = this.log;
          return newDebug;
        }
        function enable(namespaces) {
          createDebug.save(namespaces);
          createDebug.namespaces = namespaces;
          createDebug.names = [];
          createDebug.skips = [];
          let i;
          const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
          const len = split.length;
          for (i = 0; i < len; i++) {
            if (!split[i]) {
              continue;
            }
            namespaces = split[i].replace(/\*/g, ".*?");
            if (namespaces[0] === "-") {
              createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
            } else {
              createDebug.names.push(new RegExp("^" + namespaces + "$"));
            }
          }
        }
        function disable() {
          const namespaces = [
            ...createDebug.names.map(toNamespace),
            ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
          ].join(",");
          createDebug.enable("");
          return namespaces;
        }
        function enabled(name) {
          if (name[name.length - 1] === "*") {
            return true;
          }
          let i;
          let len;
          for (i = 0, len = createDebug.skips.length; i < len; i++) {
            if (createDebug.skips[i].test(name)) {
              return false;
            }
          }
          for (i = 0, len = createDebug.names.length; i < len; i++) {
            if (createDebug.names[i].test(name)) {
              return true;
            }
          }
          return false;
        }
        function toNamespace(regexp) {
          return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
        }
        function coerce2(val) {
          if (val instanceof Error) {
            return val.stack || val.message;
          }
          return val;
        }
        function destroy() {
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
        createDebug.enable(createDebug.load());
        return createDebug;
      }
      module.exports = setup;
    }
  });

  // ../../node_modules/debug/src/browser.js
  var require_browser2 = __commonJS({
    "../../node_modules/debug/src/browser.js"(exports, module) {
      exports.formatArgs = formatArgs;
      exports.save = save;
      exports.load = load;
      exports.useColors = useColors;
      exports.storage = localstorage();
      exports.destroy = /* @__PURE__ */ (() => {
        let warned = false;
        return () => {
          if (!warned) {
            warned = true;
            console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
          }
        };
      })();
      exports.colors = [
        "#0000CC",
        "#0000FF",
        "#0033CC",
        "#0033FF",
        "#0066CC",
        "#0066FF",
        "#0099CC",
        "#0099FF",
        "#00CC00",
        "#00CC33",
        "#00CC66",
        "#00CC99",
        "#00CCCC",
        "#00CCFF",
        "#3300CC",
        "#3300FF",
        "#3333CC",
        "#3333FF",
        "#3366CC",
        "#3366FF",
        "#3399CC",
        "#3399FF",
        "#33CC00",
        "#33CC33",
        "#33CC66",
        "#33CC99",
        "#33CCCC",
        "#33CCFF",
        "#6600CC",
        "#6600FF",
        "#6633CC",
        "#6633FF",
        "#66CC00",
        "#66CC33",
        "#9900CC",
        "#9900FF",
        "#9933CC",
        "#9933FF",
        "#99CC00",
        "#99CC33",
        "#CC0000",
        "#CC0033",
        "#CC0066",
        "#CC0099",
        "#CC00CC",
        "#CC00FF",
        "#CC3300",
        "#CC3333",
        "#CC3366",
        "#CC3399",
        "#CC33CC",
        "#CC33FF",
        "#CC6600",
        "#CC6633",
        "#CC9900",
        "#CC9933",
        "#CCCC00",
        "#CCCC33",
        "#FF0000",
        "#FF0033",
        "#FF0066",
        "#FF0099",
        "#FF00CC",
        "#FF00FF",
        "#FF3300",
        "#FF3333",
        "#FF3366",
        "#FF3399",
        "#FF33CC",
        "#FF33FF",
        "#FF6600",
        "#FF6633",
        "#FF9900",
        "#FF9933",
        "#FFCC00",
        "#FFCC33"
      ];
      function useColors() {
        if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
          return true;
        }
        if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
          return false;
        }
        return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
        typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
        // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
        typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
        typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
      }
      function formatArgs(args) {
        args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
        if (!this.useColors) {
          return;
        }
        const c = "color: " + this.color;
        args.splice(1, 0, c, "color: inherit");
        let index = 0;
        let lastC = 0;
        args[0].replace(/%[a-zA-Z%]/g, (match) => {
          if (match === "%%") {
            return;
          }
          index++;
          if (match === "%c") {
            lastC = index;
          }
        });
        args.splice(lastC, 0, c);
      }
      exports.log = console.debug || console.log || (() => {
      });
      function save(namespaces) {
        try {
          if (namespaces) {
            exports.storage.setItem("debug", namespaces);
          } else {
            exports.storage.removeItem("debug");
          }
        } catch (error) {
        }
      }
      function load() {
        let r;
        try {
          r = exports.storage.getItem("debug");
        } catch (error) {
        }
        if (!r && typeof process !== "undefined" && "env" in process) {
          r = process.env.DEBUG;
        }
        return r;
      }
      function localstorage() {
        try {
          return localStorage;
        } catch (error) {
        }
      }
      module.exports = require_common2()(exports);
      var { formatters } = module.exports;
      formatters.j = function(v) {
        try {
          return JSON.stringify(v);
        } catch (error) {
          return "[UnexpectedJSONParseError]: " + error.message;
        }
      };
    }
  });

  // ../../node_modules/h264-profile-level-id/lib/Logger.js
  var require_Logger2 = __commonJS({
    "../../node_modules/h264-profile-level-id/lib/Logger.js"(exports) {
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Logger = void 0;
      var debug_1 = __importDefault(require_browser2());
      var APP_NAME = "h264-profile-level-id";
      var Logger = class {
        constructor(prefix) {
          if (prefix) {
            this._debug = (0, debug_1.default)(`${APP_NAME}:${prefix}`);
            this._warn = (0, debug_1.default)(`${APP_NAME}:WARN:${prefix}`);
            this._error = (0, debug_1.default)(`${APP_NAME}:ERROR:${prefix}`);
          } else {
            this._debug = (0, debug_1.default)(APP_NAME);
            this._warn = (0, debug_1.default)(`${APP_NAME}:WARN`);
            this._error = (0, debug_1.default)(`${APP_NAME}:ERROR`);
          }
          this._debug.log = console.info.bind(console);
          this._warn.log = console.warn.bind(console);
          this._error.log = console.error.bind(console);
        }
        get debug() {
          return this._debug;
        }
        get warn() {
          return this._warn;
        }
        get error() {
          return this._error;
        }
      };
      exports.Logger = Logger;
    }
  });

  // ../../node_modules/h264-profile-level-id/lib/index.js
  var require_lib = __commonJS({
    "../../node_modules/h264-profile-level-id/lib/index.js"(exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.generateProfileLevelIdStringForAnswer = exports.isSameProfile = exports.parseSdpProfileLevelId = exports.levelToString = exports.profileToString = exports.profileLevelIdToString = exports.parseProfileLevelId = exports.ProfileLevelId = exports.Level = exports.Profile = void 0;
      var Logger_1 = require_Logger2();
      var logger13 = new Logger_1.Logger();
      var Profile;
      (function(Profile2) {
        Profile2[Profile2["ConstrainedBaseline"] = 1] = "ConstrainedBaseline";
        Profile2[Profile2["Baseline"] = 2] = "Baseline";
        Profile2[Profile2["Main"] = 3] = "Main";
        Profile2[Profile2["ConstrainedHigh"] = 4] = "ConstrainedHigh";
        Profile2[Profile2["High"] = 5] = "High";
        Profile2[Profile2["PredictiveHigh444"] = 6] = "PredictiveHigh444";
      })(Profile || (exports.Profile = Profile = {}));
      var Level;
      (function(Level2) {
        Level2[Level2["L1_b"] = 0] = "L1_b";
        Level2[Level2["L1"] = 10] = "L1";
        Level2[Level2["L1_1"] = 11] = "L1_1";
        Level2[Level2["L1_2"] = 12] = "L1_2";
        Level2[Level2["L1_3"] = 13] = "L1_3";
        Level2[Level2["L2"] = 20] = "L2";
        Level2[Level2["L2_1"] = 21] = "L2_1";
        Level2[Level2["L2_2"] = 22] = "L2_2";
        Level2[Level2["L3"] = 30] = "L3";
        Level2[Level2["L3_1"] = 31] = "L3_1";
        Level2[Level2["L3_2"] = 32] = "L3_2";
        Level2[Level2["L4"] = 40] = "L4";
        Level2[Level2["L4_1"] = 41] = "L4_1";
        Level2[Level2["L4_2"] = 42] = "L4_2";
        Level2[Level2["L5"] = 50] = "L5";
        Level2[Level2["L5_1"] = 51] = "L5_1";
        Level2[Level2["L5_2"] = 52] = "L5_2";
      })(Level || (exports.Level = Level = {}));
      var ProfileLevelId = class {
        constructor(profile, level) {
          this.profile = profile;
          this.level = level;
        }
      };
      exports.ProfileLevelId = ProfileLevelId;
      var DefaultProfileLevelId = new ProfileLevelId(Profile.ConstrainedBaseline, Level.L3_1);
      var BitPattern = class {
        constructor(str) {
          this.mask = ~byteMaskString("x", str);
          this.masked_value = byteMaskString("1", str);
        }
        isMatch(value) {
          return this.masked_value === (value & this.mask);
        }
      };
      var ProfilePattern = class {
        constructor(profile_idc, profile_iop, profile) {
          this.profile_idc = profile_idc;
          this.profile_iop = profile_iop;
          this.profile = profile;
        }
      };
      var ProfilePatterns = [
        new ProfilePattern(66, new BitPattern("x1xx0000"), Profile.ConstrainedBaseline),
        new ProfilePattern(77, new BitPattern("1xxx0000"), Profile.ConstrainedBaseline),
        new ProfilePattern(88, new BitPattern("11xx0000"), Profile.ConstrainedBaseline),
        new ProfilePattern(66, new BitPattern("x0xx0000"), Profile.Baseline),
        new ProfilePattern(88, new BitPattern("10xx0000"), Profile.Baseline),
        new ProfilePattern(77, new BitPattern("0x0x0000"), Profile.Main),
        new ProfilePattern(100, new BitPattern("00000000"), Profile.High),
        new ProfilePattern(100, new BitPattern("00001100"), Profile.ConstrainedHigh),
        new ProfilePattern(244, new BitPattern("00000000"), Profile.PredictiveHigh444)
      ];
      function parseProfileLevelId(str) {
        const ConstraintSet3Flag = 16;
        if (typeof str !== "string" || str.length !== 6) {
          return void 0;
        }
        const profile_level_id_numeric = parseInt(str, 16);
        if (profile_level_id_numeric === 0) {
          return void 0;
        }
        const level_idc = profile_level_id_numeric & 255;
        const profile_iop = profile_level_id_numeric >> 8 & 255;
        const profile_idc = profile_level_id_numeric >> 16 & 255;
        let level;
        switch (level_idc) {
          case Level.L1_1: {
            level = (profile_iop & ConstraintSet3Flag) !== 0 ? Level.L1_b : Level.L1_1;
            break;
          }
          case Level.L1:
          case Level.L1_2:
          case Level.L1_3:
          case Level.L2:
          case Level.L2_1:
          case Level.L2_2:
          case Level.L3:
          case Level.L3_1:
          case Level.L3_2:
          case Level.L4:
          case Level.L4_1:
          case Level.L4_2:
          case Level.L5:
          case Level.L5_1:
          case Level.L5_2: {
            level = level_idc;
            break;
          }
          // Unrecognized level_idc.
          default: {
            logger13.warn(`parseProfileLevelId() | unrecognized level_idc [str:${str}, level_idc:${level_idc}]`);
            return void 0;
          }
        }
        for (const pattern of ProfilePatterns) {
          if (profile_idc === pattern.profile_idc && pattern.profile_iop.isMatch(profile_iop)) {
            return new ProfileLevelId(pattern.profile, level);
          }
        }
        logger13.warn(`parseProfileLevelId() | unrecognized profile_idc/profile_iop combination [str:${str}, profile_idc:${profile_idc}, profile_iop:${profile_iop}]`);
        return void 0;
      }
      exports.parseProfileLevelId = parseProfileLevelId;
      function profileLevelIdToString(profile_level_id) {
        if (profile_level_id.level == Level.L1_b) {
          switch (profile_level_id.profile) {
            case Profile.ConstrainedBaseline: {
              return "42f00b";
            }
            case Profile.Baseline: {
              return "42100b";
            }
            case Profile.Main: {
              return "4d100b";
            }
            // Level 1_b is not allowed for other profiles.
            default: {
              logger13.warn(`profileLevelIdToString() | Level 1_b not is allowed for profile ${profile_level_id.profile}`);
              return void 0;
            }
          }
        }
        let profile_idc_iop_string;
        switch (profile_level_id.profile) {
          case Profile.ConstrainedBaseline: {
            profile_idc_iop_string = "42e0";
            break;
          }
          case Profile.Baseline: {
            profile_idc_iop_string = "4200";
            break;
          }
          case Profile.Main: {
            profile_idc_iop_string = "4d00";
            break;
          }
          case Profile.ConstrainedHigh: {
            profile_idc_iop_string = "640c";
            break;
          }
          case Profile.High: {
            profile_idc_iop_string = "6400";
            break;
          }
          case Profile.PredictiveHigh444: {
            profile_idc_iop_string = "f400";
            break;
          }
          default: {
            logger13.warn(`profileLevelIdToString() | unrecognized profile ${profile_level_id.profile}`);
            return void 0;
          }
        }
        let levelStr = profile_level_id.level.toString(16);
        if (levelStr.length === 1) {
          levelStr = `0${levelStr}`;
        }
        return `${profile_idc_iop_string}${levelStr}`;
      }
      exports.profileLevelIdToString = profileLevelIdToString;
      function profileToString(profile) {
        switch (profile) {
          case Profile.ConstrainedBaseline: {
            return "ConstrainedBaseline";
          }
          case Profile.Baseline: {
            return "Baseline";
          }
          case Profile.Main: {
            return "Main";
          }
          case Profile.ConstrainedHigh: {
            return "ConstrainedHigh";
          }
          case Profile.High: {
            return "High";
          }
          case Profile.PredictiveHigh444: {
            return "PredictiveHigh444";
          }
          default: {
            logger13.warn(`profileToString() | unrecognized profile ${profile}`);
            return void 0;
          }
        }
      }
      exports.profileToString = profileToString;
      function levelToString(level) {
        switch (level) {
          case Level.L1_b: {
            return "1b";
          }
          case Level.L1: {
            return "1";
          }
          case Level.L1_1: {
            return "1.1";
          }
          case Level.L1_2: {
            return "1.2";
          }
          case Level.L1_3: {
            return "1.3";
          }
          case Level.L2: {
            return "2";
          }
          case Level.L2_1: {
            return "2.1";
          }
          case Level.L2_2: {
            return "2.2";
          }
          case Level.L3: {
            return "3";
          }
          case Level.L3_1: {
            return "3.1";
          }
          case Level.L3_2: {
            return "3.2";
          }
          case Level.L4: {
            return "4";
          }
          case Level.L4_1: {
            return "4.1";
          }
          case Level.L4_2: {
            return "4.2";
          }
          case Level.L5: {
            return "5";
          }
          case Level.L5_1: {
            return "5.1";
          }
          case Level.L5_2: {
            return "5.2";
          }
          default: {
            logger13.warn(`levelToString() | unrecognized level ${level}`);
            return void 0;
          }
        }
      }
      exports.levelToString = levelToString;
      function parseSdpProfileLevelId(params = {}) {
        const profile_level_id = params["profile-level-id"];
        return profile_level_id ? parseProfileLevelId(profile_level_id) : DefaultProfileLevelId;
      }
      exports.parseSdpProfileLevelId = parseSdpProfileLevelId;
      function isSameProfile(params1 = {}, params2 = {}) {
        const profile_level_id_1 = parseSdpProfileLevelId(params1);
        const profile_level_id_2 = parseSdpProfileLevelId(params2);
        return Boolean(profile_level_id_1 && profile_level_id_2 && profile_level_id_1.profile === profile_level_id_2.profile);
      }
      exports.isSameProfile = isSameProfile;
      function generateProfileLevelIdStringForAnswer(local_supported_params = {}, remote_offered_params = {}) {
        if (!local_supported_params["profile-level-id"] && !remote_offered_params["profile-level-id"]) {
          logger13.warn("generateProfileLevelIdStringForAnswer() | profile-level-id missing in local and remote params");
          return void 0;
        }
        const local_profile_level_id = parseSdpProfileLevelId(local_supported_params);
        const remote_profile_level_id = parseSdpProfileLevelId(remote_offered_params);
        if (!local_profile_level_id) {
          throw new TypeError("invalid local_profile_level_id");
        }
        if (!remote_profile_level_id) {
          throw new TypeError("invalid remote_profile_level_id");
        }
        if (local_profile_level_id.profile !== remote_profile_level_id.profile) {
          throw new TypeError("H264 Profile mismatch");
        }
        const level_asymmetry_allowed = isLevelAsymmetryAllowed(local_supported_params) && isLevelAsymmetryAllowed(remote_offered_params);
        const local_level = local_profile_level_id.level;
        const remote_level = remote_profile_level_id.level;
        const min_level = minLevel(local_level, remote_level);
        const answer_level = level_asymmetry_allowed ? local_level : min_level;
        logger13.debug(`generateProfileLevelIdStringForAnswer() | result [profile:${local_profile_level_id.profile}, level:${answer_level}]`);
        return profileLevelIdToString(new ProfileLevelId(local_profile_level_id.profile, answer_level));
      }
      exports.generateProfileLevelIdStringForAnswer = generateProfileLevelIdStringForAnswer;
      function byteMaskString(c, str) {
        return Number(str[0] === c) << 7 | Number(str[1] === c) << 6 | Number(str[2] === c) << 5 | Number(str[3] === c) << 4 | Number(str[4] === c) << 3 | Number(str[5] === c) << 2 | Number(str[6] === c) << 1 | Number(str[7] === c) << 0;
      }
      function isLessLevel(a, b) {
        if (a === Level.L1_b) {
          return b !== Level.L1 && b !== Level.L1_b;
        }
        if (b === Level.L1_b) {
          return a !== Level.L1;
        }
        return a < b;
      }
      function minLevel(a, b) {
        return isLessLevel(a, b) ? a : b;
      }
      function isLevelAsymmetryAllowed(params = {}) {
        const level_asymmetry_allowed = params["level-asymmetry-allowed"];
        return level_asymmetry_allowed === true || level_asymmetry_allowed === 1 || level_asymmetry_allowed === "1";
      }
    }
  });

  // ../../node_modules/mediasoup-client/lib/ortc.js
  var require_ortc = __commonJS({
    "../../node_modules/mediasoup-client/lib/ortc.js"(exports) {
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.validateRtpCapabilities = validateRtpCapabilities;
      exports.validateRtpParameters = validateRtpParameters;
      exports.validateSctpStreamParameters = validateSctpStreamParameters;
      exports.validateSctpCapabilities = validateSctpCapabilities;
      exports.getExtendedRtpCapabilities = getExtendedRtpCapabilities;
      exports.getRecvRtpCapabilities = getRecvRtpCapabilities;
      exports.getSendingRtpParameters = getSendingRtpParameters;
      exports.getSendingRemoteRtpParameters = getSendingRemoteRtpParameters;
      exports.reduceCodecs = reduceCodecs;
      exports.generateProbatorRtpParameters = generateProbatorRtpParameters;
      exports.canSend = canSend;
      exports.canReceive = canReceive;
      var h264 = __importStar(require_lib());
      var utils = __importStar(require_utils());
      var RTP_PROBATOR_MID = "probator";
      var RTP_PROBATOR_SSRC = 1234;
      var RTP_PROBATOR_CODEC_PAYLOAD_TYPE = 127;
      function validateRtpCapabilities(caps) {
        if (typeof caps !== "object") {
          throw new TypeError("caps is not an object");
        }
        if (caps.codecs && !Array.isArray(caps.codecs)) {
          throw new TypeError("caps.codecs is not an array");
        } else if (!caps.codecs) {
          caps.codecs = [];
        }
        for (const codec of caps.codecs) {
          validateRtpCodecCapability(codec);
        }
        if (caps.headerExtensions && !Array.isArray(caps.headerExtensions)) {
          throw new TypeError("caps.headerExtensions is not an array");
        } else if (!caps.headerExtensions) {
          caps.headerExtensions = [];
        }
        for (const ext of caps.headerExtensions) {
          validateRtpHeaderExtension(ext);
        }
      }
      function validateRtpParameters(params) {
        if (typeof params !== "object") {
          throw new TypeError("params is not an object");
        }
        if (params.mid && typeof params.mid !== "string") {
          throw new TypeError("params.mid is not a string");
        }
        if (!Array.isArray(params.codecs)) {
          throw new TypeError("missing params.codecs");
        }
        for (const codec of params.codecs) {
          validateRtpCodecParameters(codec);
        }
        if (params.headerExtensions && !Array.isArray(params.headerExtensions)) {
          throw new TypeError("params.headerExtensions is not an array");
        } else if (!params.headerExtensions) {
          params.headerExtensions = [];
        }
        for (const ext of params.headerExtensions) {
          validateRtpHeaderExtensionParameters(ext);
        }
        if (params.encodings && !Array.isArray(params.encodings)) {
          throw new TypeError("params.encodings is not an array");
        } else if (!params.encodings) {
          params.encodings = [];
        }
        for (const encoding of params.encodings) {
          validateRtpEncodingParameters(encoding);
        }
        if (params.rtcp && typeof params.rtcp !== "object") {
          throw new TypeError("params.rtcp is not an object");
        } else if (!params.rtcp) {
          params.rtcp = {};
        }
        validateRtcpParameters(params.rtcp);
      }
      function validateSctpStreamParameters(params) {
        if (typeof params !== "object") {
          throw new TypeError("params is not an object");
        }
        if (typeof params.streamId !== "number") {
          throw new TypeError("missing params.streamId");
        }
        let orderedGiven = false;
        if (typeof params.ordered === "boolean") {
          orderedGiven = true;
        } else {
          params.ordered = true;
        }
        if (params.maxPacketLifeTime && typeof params.maxPacketLifeTime !== "number") {
          throw new TypeError("invalid params.maxPacketLifeTime");
        }
        if (params.maxRetransmits && typeof params.maxRetransmits !== "number") {
          throw new TypeError("invalid params.maxRetransmits");
        }
        if (params.maxPacketLifeTime && params.maxRetransmits) {
          throw new TypeError("cannot provide both maxPacketLifeTime and maxRetransmits");
        }
        if (orderedGiven && params.ordered && (params.maxPacketLifeTime || params.maxRetransmits)) {
          throw new TypeError("cannot be ordered with maxPacketLifeTime or maxRetransmits");
        } else if (!orderedGiven && (params.maxPacketLifeTime || params.maxRetransmits)) {
          params.ordered = false;
        }
        if (params.label && typeof params.label !== "string") {
          throw new TypeError("invalid params.label");
        }
        if (params.protocol && typeof params.protocol !== "string") {
          throw new TypeError("invalid params.protocol");
        }
      }
      function validateSctpCapabilities(caps) {
        if (typeof caps !== "object") {
          throw new TypeError("caps is not an object");
        }
        if (!caps.numStreams || typeof caps.numStreams !== "object") {
          throw new TypeError("missing caps.numStreams");
        }
        validateNumSctpStreams(caps.numStreams);
      }
      function getExtendedRtpCapabilities(localCaps, remoteCaps) {
        const extendedRtpCapabilities = {
          codecs: [],
          headerExtensions: []
        };
        for (const remoteCodec of remoteCaps.codecs ?? []) {
          if (isRtxCodec(remoteCodec)) {
            continue;
          }
          const matchingLocalCodec = (localCaps.codecs ?? []).find((localCodec) => matchCodecs(localCodec, remoteCodec, { strict: true, modify: true }));
          if (!matchingLocalCodec) {
            continue;
          }
          const extendedCodec = {
            mimeType: matchingLocalCodec.mimeType,
            kind: matchingLocalCodec.kind,
            clockRate: matchingLocalCodec.clockRate,
            channels: matchingLocalCodec.channels,
            localPayloadType: matchingLocalCodec.preferredPayloadType,
            localRtxPayloadType: void 0,
            remotePayloadType: remoteCodec.preferredPayloadType,
            remoteRtxPayloadType: void 0,
            localParameters: matchingLocalCodec.parameters,
            remoteParameters: remoteCodec.parameters,
            rtcpFeedback: reduceRtcpFeedback(matchingLocalCodec, remoteCodec)
          };
          extendedRtpCapabilities.codecs.push(extendedCodec);
        }
        for (const extendedCodec of extendedRtpCapabilities.codecs) {
          const matchingLocalRtxCodec = localCaps.codecs.find((localCodec) => isRtxCodec(localCodec) && localCodec.parameters.apt === extendedCodec.localPayloadType);
          const matchingRemoteRtxCodec = remoteCaps.codecs.find((remoteCodec) => isRtxCodec(remoteCodec) && remoteCodec.parameters.apt === extendedCodec.remotePayloadType);
          if (matchingLocalRtxCodec && matchingRemoteRtxCodec) {
            extendedCodec.localRtxPayloadType = matchingLocalRtxCodec.preferredPayloadType;
            extendedCodec.remoteRtxPayloadType = matchingRemoteRtxCodec.preferredPayloadType;
          }
        }
        for (const remoteExt of remoteCaps.headerExtensions) {
          const matchingLocalExt = localCaps.headerExtensions.find((localExt) => matchHeaderExtensions(localExt, remoteExt));
          if (!matchingLocalExt) {
            continue;
          }
          const extendedExt = {
            kind: remoteExt.kind,
            uri: remoteExt.uri,
            sendId: matchingLocalExt.preferredId,
            recvId: remoteExt.preferredId,
            encrypt: matchingLocalExt.preferredEncrypt,
            direction: "sendrecv"
          };
          switch (remoteExt.direction) {
            case "sendrecv": {
              extendedExt.direction = "sendrecv";
              break;
            }
            case "recvonly": {
              extendedExt.direction = "sendonly";
              break;
            }
            case "sendonly": {
              extendedExt.direction = "recvonly";
              break;
            }
            case "inactive": {
              extendedExt.direction = "inactive";
              break;
            }
          }
          extendedRtpCapabilities.headerExtensions.push(extendedExt);
        }
        return extendedRtpCapabilities;
      }
      function getRecvRtpCapabilities(extendedRtpCapabilities) {
        const rtpCapabilities = {
          codecs: [],
          headerExtensions: []
        };
        for (const extendedCodec of extendedRtpCapabilities.codecs) {
          const codec = {
            mimeType: extendedCodec.mimeType,
            kind: extendedCodec.kind,
            preferredPayloadType: extendedCodec.remotePayloadType,
            clockRate: extendedCodec.clockRate,
            channels: extendedCodec.channels,
            parameters: extendedCodec.localParameters,
            rtcpFeedback: extendedCodec.rtcpFeedback
          };
          rtpCapabilities.codecs.push(codec);
          if (!extendedCodec.remoteRtxPayloadType) {
            continue;
          }
          const rtxCodec = {
            mimeType: `${extendedCodec.kind}/rtx`,
            kind: extendedCodec.kind,
            preferredPayloadType: extendedCodec.remoteRtxPayloadType,
            clockRate: extendedCodec.clockRate,
            parameters: {
              apt: extendedCodec.remotePayloadType
            },
            rtcpFeedback: []
          };
          rtpCapabilities.codecs.push(rtxCodec);
        }
        for (const extendedExtension of extendedRtpCapabilities.headerExtensions) {
          if (extendedExtension.direction !== "sendrecv" && extendedExtension.direction !== "recvonly") {
            continue;
          }
          const ext = {
            kind: extendedExtension.kind,
            uri: extendedExtension.uri,
            preferredId: extendedExtension.recvId,
            preferredEncrypt: extendedExtension.encrypt,
            direction: extendedExtension.direction
          };
          rtpCapabilities.headerExtensions.push(ext);
        }
        return rtpCapabilities;
      }
      function getSendingRtpParameters(kind, extendedRtpCapabilities) {
        const rtpParameters = {
          mid: void 0,
          codecs: [],
          headerExtensions: [],
          encodings: [],
          rtcp: {}
        };
        for (const extendedCodec of extendedRtpCapabilities.codecs) {
          if (extendedCodec.kind !== kind) {
            continue;
          }
          const codec = {
            mimeType: extendedCodec.mimeType,
            payloadType: extendedCodec.localPayloadType,
            clockRate: extendedCodec.clockRate,
            channels: extendedCodec.channels,
            parameters: extendedCodec.localParameters,
            rtcpFeedback: extendedCodec.rtcpFeedback
          };
          rtpParameters.codecs.push(codec);
          if (extendedCodec.localRtxPayloadType) {
            const rtxCodec = {
              mimeType: `${extendedCodec.kind}/rtx`,
              payloadType: extendedCodec.localRtxPayloadType,
              clockRate: extendedCodec.clockRate,
              parameters: {
                apt: extendedCodec.localPayloadType
              },
              rtcpFeedback: []
            };
            rtpParameters.codecs.push(rtxCodec);
          }
        }
        for (const extendedExtension of extendedRtpCapabilities.headerExtensions) {
          if (extendedExtension.kind && extendedExtension.kind !== kind || extendedExtension.direction !== "sendrecv" && extendedExtension.direction !== "sendonly") {
            continue;
          }
          const ext = {
            uri: extendedExtension.uri,
            id: extendedExtension.sendId,
            encrypt: extendedExtension.encrypt,
            parameters: {}
          };
          rtpParameters.headerExtensions.push(ext);
        }
        return rtpParameters;
      }
      function getSendingRemoteRtpParameters(kind, extendedRtpCapabilities) {
        const rtpParameters = {
          mid: void 0,
          codecs: [],
          headerExtensions: [],
          encodings: [],
          rtcp: {}
        };
        for (const extendedCodec of extendedRtpCapabilities.codecs) {
          if (extendedCodec.kind !== kind) {
            continue;
          }
          const codec = {
            mimeType: extendedCodec.mimeType,
            payloadType: extendedCodec.localPayloadType,
            clockRate: extendedCodec.clockRate,
            channels: extendedCodec.channels,
            parameters: extendedCodec.remoteParameters,
            rtcpFeedback: extendedCodec.rtcpFeedback
          };
          rtpParameters.codecs.push(codec);
          if (extendedCodec.localRtxPayloadType) {
            const rtxCodec = {
              mimeType: `${extendedCodec.kind}/rtx`,
              payloadType: extendedCodec.localRtxPayloadType,
              clockRate: extendedCodec.clockRate,
              parameters: {
                apt: extendedCodec.localPayloadType
              },
              rtcpFeedback: []
            };
            rtpParameters.codecs.push(rtxCodec);
          }
        }
        for (const extendedExtension of extendedRtpCapabilities.headerExtensions) {
          if (extendedExtension.kind && extendedExtension.kind !== kind || extendedExtension.direction !== "sendrecv" && extendedExtension.direction !== "sendonly") {
            continue;
          }
          const ext = {
            uri: extendedExtension.uri,
            id: extendedExtension.sendId,
            encrypt: extendedExtension.encrypt,
            parameters: {}
          };
          rtpParameters.headerExtensions.push(ext);
        }
        if (rtpParameters.headerExtensions.some((ext) => ext.uri === "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01")) {
          for (const codec of rtpParameters.codecs) {
            codec.rtcpFeedback = (codec.rtcpFeedback ?? []).filter((fb) => fb.type !== "goog-remb");
          }
        } else if (rtpParameters.headerExtensions.some((ext) => ext.uri === "http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time")) {
          for (const codec of rtpParameters.codecs) {
            codec.rtcpFeedback = (codec.rtcpFeedback ?? []).filter((fb) => fb.type !== "transport-cc");
          }
        } else {
          for (const codec of rtpParameters.codecs) {
            codec.rtcpFeedback = (codec.rtcpFeedback ?? []).filter((fb) => fb.type !== "transport-cc" && fb.type !== "goog-remb");
          }
        }
        return rtpParameters;
      }
      function reduceCodecs(codecs, capCodec) {
        const filteredCodecs = [];
        if (!capCodec) {
          filteredCodecs.push(codecs[0]);
          if (isRtxCodec(codecs[1])) {
            filteredCodecs.push(codecs[1]);
          }
        } else {
          for (let idx = 0; idx < codecs.length; ++idx) {
            if (matchCodecs(codecs[idx], capCodec, { strict: true })) {
              filteredCodecs.push(codecs[idx]);
              if (isRtxCodec(codecs[idx + 1])) {
                filteredCodecs.push(codecs[idx + 1]);
              }
              break;
            }
          }
          if (filteredCodecs.length === 0) {
            throw new TypeError("no matching codec found");
          }
        }
        return filteredCodecs;
      }
      function generateProbatorRtpParameters(videoRtpParameters) {
        videoRtpParameters = utils.clone(videoRtpParameters);
        validateRtpParameters(videoRtpParameters);
        const rtpParameters = {
          mid: RTP_PROBATOR_MID,
          codecs: [],
          headerExtensions: [],
          encodings: [{ ssrc: RTP_PROBATOR_SSRC }],
          rtcp: { cname: "probator" }
        };
        rtpParameters.codecs.push(videoRtpParameters.codecs[0]);
        rtpParameters.codecs[0].payloadType = RTP_PROBATOR_CODEC_PAYLOAD_TYPE;
        rtpParameters.headerExtensions = videoRtpParameters.headerExtensions;
        return rtpParameters;
      }
      function canSend(kind, extendedRtpCapabilities) {
        return extendedRtpCapabilities.codecs.some((codec) => codec.kind === kind);
      }
      function canReceive(rtpParameters, extendedRtpCapabilities) {
        validateRtpParameters(rtpParameters);
        if (rtpParameters.codecs.length === 0) {
          return false;
        }
        const firstMediaCodec = rtpParameters.codecs[0];
        return extendedRtpCapabilities.codecs.some((codec) => codec.remotePayloadType === firstMediaCodec.payloadType);
      }
      function validateRtpCodecCapability(codec) {
        const MimeTypeRegex = new RegExp("^(audio|video)/(.+)", "i");
        if (typeof codec !== "object") {
          throw new TypeError("codec is not an object");
        }
        if (!codec.mimeType || typeof codec.mimeType !== "string") {
          throw new TypeError("missing codec.mimeType");
        }
        const mimeTypeMatch = MimeTypeRegex.exec(codec.mimeType);
        if (!mimeTypeMatch) {
          throw new TypeError("invalid codec.mimeType");
        }
        codec.kind = mimeTypeMatch[1].toLowerCase();
        if (codec.preferredPayloadType && typeof codec.preferredPayloadType !== "number") {
          throw new TypeError("invalid codec.preferredPayloadType");
        }
        if (typeof codec.clockRate !== "number") {
          throw new TypeError("missing codec.clockRate");
        }
        if (codec.kind === "audio") {
          if (typeof codec.channels !== "number") {
            codec.channels = 1;
          }
        } else {
          delete codec.channels;
        }
        if (!codec.parameters || typeof codec.parameters !== "object") {
          codec.parameters = {};
        }
        for (const key of Object.keys(codec.parameters)) {
          let value = codec.parameters[key];
          if (value === void 0) {
            codec.parameters[key] = "";
            value = "";
          }
          if (typeof value !== "string" && typeof value !== "number") {
            throw new TypeError(`invalid codec parameter [key:${key}s, value:${value}]`);
          }
          if (key === "apt") {
            if (typeof value !== "number") {
              throw new TypeError("invalid codec apt parameter");
            }
          }
        }
        if (!codec.rtcpFeedback || !Array.isArray(codec.rtcpFeedback)) {
          codec.rtcpFeedback = [];
        }
        for (const fb of codec.rtcpFeedback) {
          validateRtcpFeedback(fb);
        }
      }
      function validateRtcpFeedback(fb) {
        if (typeof fb !== "object") {
          throw new TypeError("fb is not an object");
        }
        if (!fb.type || typeof fb.type !== "string") {
          throw new TypeError("missing fb.type");
        }
        if (!fb.parameter || typeof fb.parameter !== "string") {
          fb.parameter = "";
        }
      }
      function validateRtpHeaderExtension(ext) {
        if (typeof ext !== "object") {
          throw new TypeError("ext is not an object");
        }
        if (ext.kind !== "audio" && ext.kind !== "video") {
          throw new TypeError("invalid ext.kind");
        }
        if (!ext.uri || typeof ext.uri !== "string") {
          throw new TypeError("missing ext.uri");
        }
        if (typeof ext.preferredId !== "number") {
          throw new TypeError("missing ext.preferredId");
        }
        if (ext.preferredEncrypt && typeof ext.preferredEncrypt !== "boolean") {
          throw new TypeError("invalid ext.preferredEncrypt");
        } else if (!ext.preferredEncrypt) {
          ext.preferredEncrypt = false;
        }
        if (ext.direction && typeof ext.direction !== "string") {
          throw new TypeError("invalid ext.direction");
        } else if (!ext.direction) {
          ext.direction = "sendrecv";
        }
      }
      function validateRtpCodecParameters(codec) {
        const MimeTypeRegex = new RegExp("^(audio|video)/(.+)", "i");
        if (typeof codec !== "object") {
          throw new TypeError("codec is not an object");
        }
        if (!codec.mimeType || typeof codec.mimeType !== "string") {
          throw new TypeError("missing codec.mimeType");
        }
        const mimeTypeMatch = MimeTypeRegex.exec(codec.mimeType);
        if (!mimeTypeMatch) {
          throw new TypeError("invalid codec.mimeType");
        }
        if (typeof codec.payloadType !== "number") {
          throw new TypeError("missing codec.payloadType");
        }
        if (typeof codec.clockRate !== "number") {
          throw new TypeError("missing codec.clockRate");
        }
        const kind = mimeTypeMatch[1].toLowerCase();
        if (kind === "audio") {
          if (typeof codec.channels !== "number") {
            codec.channels = 1;
          }
        } else {
          delete codec.channels;
        }
        if (!codec.parameters || typeof codec.parameters !== "object") {
          codec.parameters = {};
        }
        for (const key of Object.keys(codec.parameters)) {
          let value = codec.parameters[key];
          if (value === void 0) {
            codec.parameters[key] = "";
            value = "";
          }
          if (typeof value !== "string" && typeof value !== "number") {
            throw new TypeError(`invalid codec parameter [key:${key}s, value:${value}]`);
          }
          if (key === "apt") {
            if (typeof value !== "number") {
              throw new TypeError("invalid codec apt parameter");
            }
          }
        }
        if (!codec.rtcpFeedback || !Array.isArray(codec.rtcpFeedback)) {
          codec.rtcpFeedback = [];
        }
        for (const fb of codec.rtcpFeedback) {
          validateRtcpFeedback(fb);
        }
      }
      function validateRtpHeaderExtensionParameters(ext) {
        if (typeof ext !== "object") {
          throw new TypeError("ext is not an object");
        }
        if (!ext.uri || typeof ext.uri !== "string") {
          throw new TypeError("missing ext.uri");
        }
        if (typeof ext.id !== "number") {
          throw new TypeError("missing ext.id");
        }
        if (ext.encrypt && typeof ext.encrypt !== "boolean") {
          throw new TypeError("invalid ext.encrypt");
        } else if (!ext.encrypt) {
          ext.encrypt = false;
        }
        if (!ext.parameters || typeof ext.parameters !== "object") {
          ext.parameters = {};
        }
        for (const key of Object.keys(ext.parameters)) {
          let value = ext.parameters[key];
          if (value === void 0) {
            ext.parameters[key] = "";
            value = "";
          }
          if (typeof value !== "string" && typeof value !== "number") {
            throw new TypeError("invalid header extension parameter");
          }
        }
      }
      function validateRtpEncodingParameters(encoding) {
        if (typeof encoding !== "object") {
          throw new TypeError("encoding is not an object");
        }
        if (encoding.ssrc && typeof encoding.ssrc !== "number") {
          throw new TypeError("invalid encoding.ssrc");
        }
        if (encoding.rid && typeof encoding.rid !== "string") {
          throw new TypeError("invalid encoding.rid");
        }
        if (encoding.rtx && typeof encoding.rtx !== "object") {
          throw new TypeError("invalid encoding.rtx");
        } else if (encoding.rtx) {
          if (typeof encoding.rtx.ssrc !== "number") {
            throw new TypeError("missing encoding.rtx.ssrc");
          }
        }
        if (!encoding.dtx || typeof encoding.dtx !== "boolean") {
          encoding.dtx = false;
        }
        if (encoding.scalabilityMode && typeof encoding.scalabilityMode !== "string") {
          throw new TypeError("invalid encoding.scalabilityMode");
        }
      }
      function validateRtcpParameters(rtcp) {
        if (typeof rtcp !== "object") {
          throw new TypeError("rtcp is not an object");
        }
        if (rtcp.cname && typeof rtcp.cname !== "string") {
          throw new TypeError("invalid rtcp.cname");
        }
        if (!rtcp.reducedSize || typeof rtcp.reducedSize !== "boolean") {
          rtcp.reducedSize = true;
        }
      }
      function validateNumSctpStreams(numStreams) {
        if (typeof numStreams !== "object") {
          throw new TypeError("numStreams is not an object");
        }
        if (typeof numStreams.OS !== "number") {
          throw new TypeError("missing numStreams.OS");
        }
        if (typeof numStreams.MIS !== "number") {
          throw new TypeError("missing numStreams.MIS");
        }
      }
      function isRtxCodec(codec) {
        if (!codec) {
          return false;
        }
        return /.+\/rtx$/i.test(codec.mimeType);
      }
      function matchCodecs(aCodec, bCodec, { strict = false, modify = false } = {}) {
        const aMimeType = aCodec.mimeType.toLowerCase();
        const bMimeType = bCodec.mimeType.toLowerCase();
        if (aMimeType !== bMimeType) {
          return false;
        }
        if (aCodec.clockRate !== bCodec.clockRate) {
          return false;
        }
        if (aCodec.channels !== bCodec.channels) {
          return false;
        }
        switch (aMimeType) {
          case "video/h264": {
            if (strict) {
              const aPacketizationMode = aCodec.parameters["packetization-mode"] || 0;
              const bPacketizationMode = bCodec.parameters["packetization-mode"] || 0;
              if (aPacketizationMode !== bPacketizationMode) {
                return false;
              }
              if (!h264.isSameProfile(aCodec.parameters, bCodec.parameters)) {
                return false;
              }
              let selectedProfileLevelId;
              try {
                selectedProfileLevelId = h264.generateProfileLevelIdStringForAnswer(aCodec.parameters, bCodec.parameters);
              } catch (error) {
                return false;
              }
              if (modify) {
                if (selectedProfileLevelId) {
                  aCodec.parameters["profile-level-id"] = selectedProfileLevelId;
                  bCodec.parameters["profile-level-id"] = selectedProfileLevelId;
                } else {
                  delete aCodec.parameters["profile-level-id"];
                  delete bCodec.parameters["profile-level-id"];
                }
              }
            }
            break;
          }
          case "video/vp9": {
            if (strict) {
              const aProfileId = aCodec.parameters["profile-id"] || 0;
              const bProfileId = bCodec.parameters["profile-id"] || 0;
              if (aProfileId !== bProfileId) {
                return false;
              }
            }
            break;
          }
        }
        return true;
      }
      function matchHeaderExtensions(aExt, bExt) {
        if (aExt.kind && bExt.kind && aExt.kind !== bExt.kind) {
          return false;
        }
        if (aExt.uri !== bExt.uri) {
          return false;
        }
        return true;
      }
      function reduceRtcpFeedback(codecA, codecB) {
        const reducedRtcpFeedback = [];
        for (const aFb of codecA.rtcpFeedback ?? []) {
          const matchingBFb = (codecB.rtcpFeedback ?? []).find((bFb) => bFb.type === aFb.type && (bFb.parameter === aFb.parameter || !bFb.parameter && !aFb.parameter));
          if (matchingBFb) {
            reducedRtcpFeedback.push(matchingBFb);
          }
        }
        return reducedRtcpFeedback;
      }
    }
  });

  // ../../node_modules/awaitqueue/lib/Logger.js
  var require_Logger3 = __commonJS({
    "../../node_modules/awaitqueue/lib/Logger.js"(exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Logger = void 0;
      var debug_1 = require_browser2();
      var LIB_NAME = "awaitqueue";
      var Logger = class {
        constructor(prefix) {
          if (prefix) {
            this._debug = (0, debug_1.default)(`${LIB_NAME}:${prefix}`);
            this._warn = (0, debug_1.default)(`${LIB_NAME}:WARN:${prefix}`);
            this._error = (0, debug_1.default)(`${LIB_NAME}:ERROR:${prefix}`);
          } else {
            this._debug = (0, debug_1.default)(LIB_NAME);
            this._warn = (0, debug_1.default)(`${LIB_NAME}:WARN`);
            this._error = (0, debug_1.default)(`${LIB_NAME}:ERROR`);
          }
          this._debug.log = console.info.bind(console);
          this._warn.log = console.warn.bind(console);
          this._error.log = console.error.bind(console);
        }
        get debug() {
          return this._debug;
        }
        get warn() {
          return this._warn;
        }
        get error() {
          return this._error;
        }
      };
      exports.Logger = Logger;
    }
  });

  // ../../node_modules/awaitqueue/lib/index.js
  var require_lib2 = __commonJS({
    "../../node_modules/awaitqueue/lib/index.js"(exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.AwaitQueue = exports.AwaitQueueRemovedTaskError = exports.AwaitQueueStoppedError = void 0;
      var Logger_1 = require_Logger3();
      var logger13 = new Logger_1.Logger();
      var AwaitQueueStoppedError = class _AwaitQueueStoppedError extends Error {
        constructor(message) {
          super(message ?? "AwaitQueue stopped");
          this.name = "AwaitQueueStoppedError";
          if (typeof Error.captureStackTrace === "function") {
            Error.captureStackTrace(this, _AwaitQueueStoppedError);
          }
        }
      };
      exports.AwaitQueueStoppedError = AwaitQueueStoppedError;
      var AwaitQueueRemovedTaskError = class _AwaitQueueRemovedTaskError extends Error {
        constructor(message) {
          super(message ?? "AwaitQueue task removed");
          this.name = "AwaitQueueRemovedTaskError";
          if (typeof Error.captureStackTrace === "function") {
            Error.captureStackTrace(this, _AwaitQueueRemovedTaskError);
          }
        }
      };
      exports.AwaitQueueRemovedTaskError = AwaitQueueRemovedTaskError;
      var AwaitQueue = class {
        constructor() {
          this.pendingTasks = /* @__PURE__ */ new Map();
          this.nextTaskId = 0;
          this.stopping = false;
        }
        get size() {
          return this.pendingTasks.size;
        }
        async push(task, name) {
          name = name ?? task.name;
          logger13.debug(`push() [name:${name}]`);
          if (typeof task !== "function") {
            throw new TypeError("given task is not a function");
          }
          if (name) {
            try {
              Object.defineProperty(task, "name", { value: name });
            } catch (error) {
            }
          }
          return new Promise((resolve, reject) => {
            const pendingTask = {
              id: this.nextTaskId++,
              task,
              name,
              enqueuedAt: Date.now(),
              executedAt: void 0,
              completed: false,
              resolve: (result) => {
                if (pendingTask.completed) {
                  return;
                }
                pendingTask.completed = true;
                this.pendingTasks.delete(pendingTask.id);
                logger13.debug(`resolving task [name:${pendingTask.name}]`);
                resolve(result);
                const [nextPendingTask] = this.pendingTasks.values();
                if (nextPendingTask && !nextPendingTask.executedAt) {
                  void this.execute(nextPendingTask);
                }
              },
              reject: (error) => {
                if (pendingTask.completed) {
                  return;
                }
                pendingTask.completed = true;
                this.pendingTasks.delete(pendingTask.id);
                logger13.debug(`rejecting task [name:${pendingTask.name}]: %s`, String(error));
                reject(error);
                if (!this.stopping) {
                  const [nextPendingTask] = this.pendingTasks.values();
                  if (nextPendingTask && !nextPendingTask.executedAt) {
                    void this.execute(nextPendingTask);
                  }
                }
              }
            };
            this.pendingTasks.set(pendingTask.id, pendingTask);
            if (this.pendingTasks.size === 1) {
              void this.execute(pendingTask);
            }
          });
        }
        stop() {
          logger13.debug("stop()");
          this.stopping = true;
          for (const pendingTask of this.pendingTasks.values()) {
            logger13.debug(`stop() | stopping task [name:${pendingTask.name}]`);
            pendingTask.reject(new AwaitQueueStoppedError());
          }
          this.stopping = false;
        }
        remove(taskIdx) {
          logger13.debug(`remove() [taskIdx:${taskIdx}]`);
          const pendingTask = Array.from(this.pendingTasks.values())[taskIdx];
          if (!pendingTask) {
            logger13.debug(`stop() | no task with given idx [taskIdx:${taskIdx}]`);
            return;
          }
          pendingTask.reject(new AwaitQueueRemovedTaskError());
        }
        dump() {
          const now = Date.now();
          let idx = 0;
          return Array.from(this.pendingTasks.values()).map((pendingTask) => ({
            idx: idx++,
            task: pendingTask.task,
            name: pendingTask.name,
            enqueuedTime: pendingTask.executedAt ? pendingTask.executedAt - pendingTask.enqueuedAt : now - pendingTask.enqueuedAt,
            executionTime: pendingTask.executedAt ? now - pendingTask.executedAt : 0
          }));
        }
        async execute(pendingTask) {
          logger13.debug(`execute() [name:${pendingTask.name}]`);
          if (pendingTask.executedAt) {
            throw new Error("task already being executed");
          }
          pendingTask.executedAt = Date.now();
          try {
            const result = await pendingTask.task();
            pendingTask.resolve(result);
          } catch (error) {
            pendingTask.reject(error);
          }
        }
      };
      exports.AwaitQueue = AwaitQueue;
    }
  });

  // ../../node_modules/queue-microtask/index.js
  var require_queue_microtask = __commonJS({
    "../../node_modules/queue-microtask/index.js"(exports, module) {
      var promise;
      module.exports = typeof queueMicrotask === "function" ? queueMicrotask.bind(typeof window !== "undefined" ? window : global) : (cb) => (promise || (promise = Promise.resolve())).then(cb).catch((err) => setTimeout(() => {
        throw err;
      }, 0));
    }
  });

  // ../../node_modules/mediasoup-client/lib/Producer.js
  var require_Producer = __commonJS({
    "../../node_modules/mediasoup-client/lib/Producer.js"(exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Producer = void 0;
      var Logger_1 = require_Logger();
      var enhancedEvents_1 = require_enhancedEvents();
      var errors_1 = require_errors();
      var logger13 = new Logger_1.Logger("Producer");
      var Producer = class extends enhancedEvents_1.EnhancedEventEmitter {
        constructor({ id, localId, rtpSender, track, rtpParameters, stopTracks, disableTrackOnPause, zeroRtpOnPause, appData }) {
          super();
          this._closed = false;
          this._observer = new enhancedEvents_1.EnhancedEventEmitter();
          logger13.debug("constructor()");
          this._id = id;
          this._localId = localId;
          this._rtpSender = rtpSender;
          this._track = track;
          this._kind = track.kind;
          this._rtpParameters = rtpParameters;
          this._paused = disableTrackOnPause ? !track.enabled : false;
          this._maxSpatialLayer = void 0;
          this._stopTracks = stopTracks;
          this._disableTrackOnPause = disableTrackOnPause;
          this._zeroRtpOnPause = zeroRtpOnPause;
          this._appData = appData ?? {};
          this.onTrackEnded = this.onTrackEnded.bind(this);
          this.handleTrack();
        }
        /**
         * Producer id.
         */
        get id() {
          return this._id;
        }
        /**
         * Local id.
         */
        get localId() {
          return this._localId;
        }
        /**
         * Whether the Producer is closed.
         */
        get closed() {
          return this._closed;
        }
        /**
         * Media kind.
         */
        get kind() {
          return this._kind;
        }
        /**
         * Associated RTCRtpSender.
         */
        get rtpSender() {
          return this._rtpSender;
        }
        /**
         * The associated track.
         */
        get track() {
          return this._track;
        }
        /**
         * RTP parameters.
         */
        get rtpParameters() {
          return this._rtpParameters;
        }
        /**
         * Whether the Producer is paused.
         */
        get paused() {
          return this._paused;
        }
        /**
         * Max spatial layer.
         *
         * @type {Number | undefined}
         */
        get maxSpatialLayer() {
          return this._maxSpatialLayer;
        }
        /**
         * App custom data.
         */
        get appData() {
          return this._appData;
        }
        /**
         * App custom data setter.
         */
        set appData(appData) {
          this._appData = appData;
        }
        get observer() {
          return this._observer;
        }
        /**
         * Closes the Producer.
         */
        close() {
          if (this._closed) {
            return;
          }
          logger13.debug("close()");
          this._closed = true;
          this.destroyTrack();
          this.emit("@close");
          this._observer.safeEmit("close");
        }
        /**
         * Transport was closed.
         */
        transportClosed() {
          if (this._closed) {
            return;
          }
          logger13.debug("transportClosed()");
          this._closed = true;
          this.destroyTrack();
          this.safeEmit("transportclose");
          this._observer.safeEmit("close");
        }
        /**
         * Get associated RTCRtpSender stats.
         */
        async getStats() {
          if (this._closed) {
            throw new errors_1.InvalidStateError("closed");
          }
          return new Promise((resolve, reject) => {
            this.safeEmit("@getstats", resolve, reject);
          });
        }
        /**
         * Pauses sending media.
         */
        pause() {
          logger13.debug("pause()");
          if (this._closed) {
            logger13.error("pause() | Producer closed");
            return;
          }
          this._paused = true;
          if (this._track && this._disableTrackOnPause) {
            this._track.enabled = false;
          }
          if (this._zeroRtpOnPause) {
            new Promise((resolve, reject) => {
              this.safeEmit("@pause", resolve, reject);
            }).catch(() => {
            });
          }
          this._observer.safeEmit("pause");
        }
        /**
         * Resumes sending media.
         */
        resume() {
          logger13.debug("resume()");
          if (this._closed) {
            logger13.error("resume() | Producer closed");
            return;
          }
          this._paused = false;
          if (this._track && this._disableTrackOnPause) {
            this._track.enabled = true;
          }
          if (this._zeroRtpOnPause) {
            new Promise((resolve, reject) => {
              this.safeEmit("@resume", resolve, reject);
            }).catch(() => {
            });
          }
          this._observer.safeEmit("resume");
        }
        /**
         * Replaces the current track with a new one or null.
         */
        async replaceTrack({ track }) {
          logger13.debug("replaceTrack() [track:%o]", track);
          if (this._closed) {
            if (track && this._stopTracks) {
              try {
                track.stop();
              } catch (error) {
              }
            }
            throw new errors_1.InvalidStateError("closed");
          } else if (track && track.readyState === "ended") {
            throw new errors_1.InvalidStateError("track ended");
          }
          if (track === this._track) {
            logger13.debug("replaceTrack() | same track, ignored");
            return;
          }
          await new Promise((resolve, reject) => {
            this.safeEmit("@replacetrack", track, resolve, reject);
          });
          this.destroyTrack();
          this._track = track;
          if (this._track && this._disableTrackOnPause) {
            if (!this._paused) {
              this._track.enabled = true;
            } else if (this._paused) {
              this._track.enabled = false;
            }
          }
          this.handleTrack();
        }
        /**
         * Sets the video max spatial layer to be sent.
         */
        async setMaxSpatialLayer(spatialLayer) {
          if (this._closed) {
            throw new errors_1.InvalidStateError("closed");
          } else if (this._kind !== "video") {
            throw new errors_1.UnsupportedError("not a video Producer");
          } else if (typeof spatialLayer !== "number") {
            throw new TypeError("invalid spatialLayer");
          }
          if (spatialLayer === this._maxSpatialLayer) {
            return;
          }
          await new Promise((resolve, reject) => {
            this.safeEmit("@setmaxspatiallayer", spatialLayer, resolve, reject);
          }).catch(() => {
          });
          this._maxSpatialLayer = spatialLayer;
        }
        async setRtpEncodingParameters(params) {
          if (this._closed) {
            throw new errors_1.InvalidStateError("closed");
          } else if (typeof params !== "object") {
            throw new TypeError("invalid params");
          }
          await new Promise((resolve, reject) => {
            this.safeEmit("@setrtpencodingparameters", params, resolve, reject);
          });
        }
        onTrackEnded() {
          logger13.debug('track "ended" event');
          this.safeEmit("trackended");
          this._observer.safeEmit("trackended");
        }
        handleTrack() {
          if (!this._track) {
            return;
          }
          this._track.addEventListener("ended", this.onTrackEnded);
        }
        destroyTrack() {
          if (!this._track) {
            return;
          }
          try {
            this._track.removeEventListener("ended", this.onTrackEnded);
            if (this._stopTracks) {
              this._track.stop();
            }
          } catch (error) {
          }
        }
      };
      exports.Producer = Producer;
    }
  });

  // ../../node_modules/mediasoup-client/lib/Consumer.js
  var require_Consumer = __commonJS({
    "../../node_modules/mediasoup-client/lib/Consumer.js"(exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Consumer = void 0;
      var Logger_1 = require_Logger();
      var enhancedEvents_1 = require_enhancedEvents();
      var errors_1 = require_errors();
      var logger13 = new Logger_1.Logger("Consumer");
      var Consumer2 = class extends enhancedEvents_1.EnhancedEventEmitter {
        constructor({ id, localId, producerId, rtpReceiver, track, rtpParameters, appData }) {
          super();
          this._closed = false;
          this._observer = new enhancedEvents_1.EnhancedEventEmitter();
          logger13.debug("constructor()");
          this._id = id;
          this._localId = localId;
          this._producerId = producerId;
          this._rtpReceiver = rtpReceiver;
          this._track = track;
          this._rtpParameters = rtpParameters;
          this._paused = !track.enabled;
          this._appData = appData ?? {};
          this.onTrackEnded = this.onTrackEnded.bind(this);
          this.handleTrack();
        }
        /**
         * Consumer id.
         */
        get id() {
          return this._id;
        }
        /**
         * Local id.
         */
        get localId() {
          return this._localId;
        }
        /**
         * Associated Producer id.
         */
        get producerId() {
          return this._producerId;
        }
        /**
         * Whether the Consumer is closed.
         */
        get closed() {
          return this._closed;
        }
        /**
         * Media kind.
         */
        get kind() {
          return this._track.kind;
        }
        /**
         * Associated RTCRtpReceiver.
         */
        get rtpReceiver() {
          return this._rtpReceiver;
        }
        /**
         * The associated track.
         */
        get track() {
          return this._track;
        }
        /**
         * RTP parameters.
         */
        get rtpParameters() {
          return this._rtpParameters;
        }
        /**
         * Whether the Consumer is paused.
         */
        get paused() {
          return this._paused;
        }
        /**
         * App custom data.
         */
        get appData() {
          return this._appData;
        }
        /**
         * App custom data setter.
         */
        set appData(appData) {
          this._appData = appData;
        }
        get observer() {
          return this._observer;
        }
        /**
         * Closes the Consumer.
         */
        close() {
          if (this._closed) {
            return;
          }
          logger13.debug("close()");
          this._closed = true;
          this.destroyTrack();
          this.emit("@close");
          this._observer.safeEmit("close");
        }
        /**
         * Transport was closed.
         */
        transportClosed() {
          if (this._closed) {
            return;
          }
          logger13.debug("transportClosed()");
          this._closed = true;
          this.destroyTrack();
          this.safeEmit("transportclose");
          this._observer.safeEmit("close");
        }
        /**
         * Get associated RTCRtpReceiver stats.
         */
        async getStats() {
          if (this._closed) {
            throw new errors_1.InvalidStateError("closed");
          }
          return new Promise((resolve, reject) => {
            this.safeEmit("@getstats", resolve, reject);
          });
        }
        /**
         * Pauses receiving media.
         */
        pause() {
          logger13.debug("pause()");
          if (this._closed) {
            logger13.error("pause() | Consumer closed");
            return;
          }
          if (this._paused) {
            logger13.debug("pause() | Consumer is already paused");
            return;
          }
          this._paused = true;
          this._track.enabled = false;
          this.emit("@pause");
          this._observer.safeEmit("pause");
        }
        /**
         * Resumes receiving media.
         */
        resume() {
          logger13.debug("resume()");
          if (this._closed) {
            logger13.error("resume() | Consumer closed");
            return;
          }
          if (!this._paused) {
            logger13.debug("resume() | Consumer is already resumed");
            return;
          }
          this._paused = false;
          this._track.enabled = true;
          this.emit("@resume");
          this._observer.safeEmit("resume");
        }
        onTrackEnded() {
          logger13.debug('track "ended" event');
          this.safeEmit("trackended");
          this._observer.safeEmit("trackended");
        }
        handleTrack() {
          this._track.addEventListener("ended", this.onTrackEnded);
        }
        destroyTrack() {
          try {
            this._track.removeEventListener("ended", this.onTrackEnded);
            this._track.stop();
          } catch (error) {
          }
        }
      };
      exports.Consumer = Consumer2;
    }
  });

  // ../../node_modules/mediasoup-client/lib/DataProducer.js
  var require_DataProducer = __commonJS({
    "../../node_modules/mediasoup-client/lib/DataProducer.js"(exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DataProducer = void 0;
      var Logger_1 = require_Logger();
      var enhancedEvents_1 = require_enhancedEvents();
      var errors_1 = require_errors();
      var logger13 = new Logger_1.Logger("DataProducer");
      var DataProducer = class extends enhancedEvents_1.EnhancedEventEmitter {
        constructor({ id, dataChannel, sctpStreamParameters, appData }) {
          super();
          this._closed = false;
          this._observer = new enhancedEvents_1.EnhancedEventEmitter();
          logger13.debug("constructor()");
          this._id = id;
          this._dataChannel = dataChannel;
          this._sctpStreamParameters = sctpStreamParameters;
          this._appData = appData ?? {};
          this.handleDataChannel();
        }
        /**
         * DataProducer id.
         */
        get id() {
          return this._id;
        }
        /**
         * Whether the DataProducer is closed.
         */
        get closed() {
          return this._closed;
        }
        /**
         * SCTP stream parameters.
         */
        get sctpStreamParameters() {
          return this._sctpStreamParameters;
        }
        /**
         * DataChannel readyState.
         */
        get readyState() {
          return this._dataChannel.readyState;
        }
        /**
         * DataChannel label.
         */
        get label() {
          return this._dataChannel.label;
        }
        /**
         * DataChannel protocol.
         */
        get protocol() {
          return this._dataChannel.protocol;
        }
        /**
         * DataChannel bufferedAmount.
         */
        get bufferedAmount() {
          return this._dataChannel.bufferedAmount;
        }
        /**
         * DataChannel bufferedAmountLowThreshold.
         */
        get bufferedAmountLowThreshold() {
          return this._dataChannel.bufferedAmountLowThreshold;
        }
        /**
         * Set DataChannel bufferedAmountLowThreshold.
         */
        set bufferedAmountLowThreshold(bufferedAmountLowThreshold) {
          this._dataChannel.bufferedAmountLowThreshold = bufferedAmountLowThreshold;
        }
        /**
         * App custom data.
         */
        get appData() {
          return this._appData;
        }
        /**
         * App custom data setter.
         */
        set appData(appData) {
          this._appData = appData;
        }
        get observer() {
          return this._observer;
        }
        /**
         * Closes the DataProducer.
         */
        close() {
          if (this._closed) {
            return;
          }
          logger13.debug("close()");
          this._closed = true;
          this._dataChannel.close();
          this.emit("@close");
          this._observer.safeEmit("close");
        }
        /**
         * Transport was closed.
         */
        transportClosed() {
          if (this._closed) {
            return;
          }
          logger13.debug("transportClosed()");
          this._closed = true;
          this._dataChannel.close();
          this.safeEmit("transportclose");
          this._observer.safeEmit("close");
        }
        /**
         * Send a message.
         *
         * @param {String|Blob|ArrayBuffer|ArrayBufferView} data.
         */
        send(data) {
          logger13.debug("send()");
          if (this._closed) {
            throw new errors_1.InvalidStateError("closed");
          }
          this._dataChannel.send(data);
        }
        handleDataChannel() {
          this._dataChannel.addEventListener("open", () => {
            if (this._closed) {
              return;
            }
            logger13.debug('DataChannel "open" event');
            this.safeEmit("open");
          });
          this._dataChannel.addEventListener("error", (event) => {
            if (this._closed) {
              return;
            }
            let { error } = event;
            if (!error) {
              error = new Error("unknown DataChannel error");
            }
            if (error.errorDetail === "sctp-failure") {
              logger13.error("DataChannel SCTP error [sctpCauseCode:%s]: %s", error.sctpCauseCode, error.message);
            } else {
              logger13.error('DataChannel "error" event: %o', error);
            }
            this.safeEmit("error", error);
          });
          this._dataChannel.addEventListener("close", () => {
            if (this._closed) {
              return;
            }
            logger13.warn('DataChannel "close" event');
            this._closed = true;
            this.emit("@close");
            this.safeEmit("close");
            this._observer.safeEmit("close");
          });
          this._dataChannel.addEventListener("message", () => {
            if (this._closed) {
              return;
            }
            logger13.warn('DataChannel "message" event in a DataProducer, message discarded');
          });
          this._dataChannel.addEventListener("bufferedamountlow", () => {
            if (this._closed) {
              return;
            }
            this.safeEmit("bufferedamountlow");
          });
        }
      };
      exports.DataProducer = DataProducer;
    }
  });

  // ../../node_modules/mediasoup-client/lib/DataConsumer.js
  var require_DataConsumer = __commonJS({
    "../../node_modules/mediasoup-client/lib/DataConsumer.js"(exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DataConsumer = void 0;
      var Logger_1 = require_Logger();
      var enhancedEvents_1 = require_enhancedEvents();
      var logger13 = new Logger_1.Logger("DataConsumer");
      var DataConsumer = class extends enhancedEvents_1.EnhancedEventEmitter {
        constructor({ id, dataProducerId, dataChannel, sctpStreamParameters, appData }) {
          super();
          this._closed = false;
          this._observer = new enhancedEvents_1.EnhancedEventEmitter();
          logger13.debug("constructor()");
          this._id = id;
          this._dataProducerId = dataProducerId;
          this._dataChannel = dataChannel;
          this._sctpStreamParameters = sctpStreamParameters;
          this._appData = appData ?? {};
          this.handleDataChannel();
        }
        /**
         * DataConsumer id.
         */
        get id() {
          return this._id;
        }
        /**
         * Associated DataProducer id.
         */
        get dataProducerId() {
          return this._dataProducerId;
        }
        /**
         * Whether the DataConsumer is closed.
         */
        get closed() {
          return this._closed;
        }
        /**
         * SCTP stream parameters.
         */
        get sctpStreamParameters() {
          return this._sctpStreamParameters;
        }
        /**
         * DataChannel readyState.
         */
        get readyState() {
          return this._dataChannel.readyState;
        }
        /**
         * DataChannel label.
         */
        get label() {
          return this._dataChannel.label;
        }
        /**
         * DataChannel protocol.
         */
        get protocol() {
          return this._dataChannel.protocol;
        }
        /**
         * DataChannel binaryType.
         */
        get binaryType() {
          return this._dataChannel.binaryType;
        }
        /**
         * Set DataChannel binaryType.
         */
        set binaryType(binaryType) {
          this._dataChannel.binaryType = binaryType;
        }
        /**
         * App custom data.
         */
        get appData() {
          return this._appData;
        }
        /**
         * App custom data setter.
         */
        set appData(appData) {
          this._appData = appData;
        }
        get observer() {
          return this._observer;
        }
        /**
         * Closes the DataConsumer.
         */
        close() {
          if (this._closed) {
            return;
          }
          logger13.debug("close()");
          this._closed = true;
          this._dataChannel.close();
          this.emit("@close");
          this._observer.safeEmit("close");
        }
        /**
         * Transport was closed.
         */
        transportClosed() {
          if (this._closed) {
            return;
          }
          logger13.debug("transportClosed()");
          this._closed = true;
          this._dataChannel.close();
          this.safeEmit("transportclose");
          this._observer.safeEmit("close");
        }
        handleDataChannel() {
          this._dataChannel.addEventListener("open", () => {
            if (this._closed) {
              return;
            }
            logger13.debug('DataChannel "open" event');
            this.safeEmit("open");
          });
          this._dataChannel.addEventListener("error", (event) => {
            if (this._closed) {
              return;
            }
            let { error } = event;
            if (!error) {
              error = new Error("unknown DataChannel error");
            }
            if (error.errorDetail === "sctp-failure") {
              logger13.error("DataChannel SCTP error [sctpCauseCode:%s]: %s", error.sctpCauseCode, error.message);
            } else {
              logger13.error('DataChannel "error" event: %o', error);
            }
            this.safeEmit("error", error);
          });
          this._dataChannel.addEventListener("close", () => {
            if (this._closed) {
              return;
            }
            logger13.warn('DataChannel "close" event');
            this._closed = true;
            this.emit("@close");
            this.safeEmit("close");
            this._observer.safeEmit("close");
          });
          this._dataChannel.addEventListener("message", (event) => {
            if (this._closed) {
              return;
            }
            this.safeEmit("message", event.data);
          });
        }
      };
      exports.DataConsumer = DataConsumer;
    }
  });

  // ../../node_modules/mediasoup-client/lib/Transport.js
  var require_Transport = __commonJS({
    "../../node_modules/mediasoup-client/lib/Transport.js"(exports) {
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Transport = void 0;
      var awaitqueue_1 = require_lib2();
      var queue_microtask_1 = __importDefault(require_queue_microtask());
      var Logger_1 = require_Logger();
      var enhancedEvents_1 = require_enhancedEvents();
      var errors_1 = require_errors();
      var utils = __importStar(require_utils());
      var ortc = __importStar(require_ortc());
      var Producer_1 = require_Producer();
      var Consumer_1 = require_Consumer();
      var DataProducer_1 = require_DataProducer();
      var DataConsumer_1 = require_DataConsumer();
      var logger13 = new Logger_1.Logger("Transport");
      var ConsumerCreationTask = class {
        constructor(consumerOptions) {
          this.consumerOptions = consumerOptions;
          this.promise = new Promise((resolve, reject) => {
            this.resolve = resolve;
            this.reject = reject;
          });
        }
      };
      var Transport2 = class extends enhancedEvents_1.EnhancedEventEmitter {
        constructor({ direction, id, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, appData, handlerFactory, extendedRtpCapabilities, canProduceByKind }) {
          super();
          this._closed = false;
          this._iceGatheringState = "new";
          this._connectionState = "new";
          this._producers = /* @__PURE__ */ new Map();
          this._consumers = /* @__PURE__ */ new Map();
          this._dataProducers = /* @__PURE__ */ new Map();
          this._dataConsumers = /* @__PURE__ */ new Map();
          this._probatorConsumerCreated = false;
          this._awaitQueue = new awaitqueue_1.AwaitQueue();
          this._pendingConsumerTasks = [];
          this._consumerCreationInProgress = false;
          this._pendingPauseConsumers = /* @__PURE__ */ new Map();
          this._consumerPauseInProgress = false;
          this._pendingResumeConsumers = /* @__PURE__ */ new Map();
          this._consumerResumeInProgress = false;
          this._pendingCloseConsumers = /* @__PURE__ */ new Map();
          this._consumerCloseInProgress = false;
          this._observer = new enhancedEvents_1.EnhancedEventEmitter();
          logger13.debug("constructor() [id:%s, direction:%s]", id, direction);
          this._id = id;
          this._direction = direction;
          this._extendedRtpCapabilities = extendedRtpCapabilities;
          this._canProduceByKind = canProduceByKind;
          this._maxSctpMessageSize = sctpParameters ? sctpParameters.maxMessageSize : null;
          const clonedAdditionalSettings = utils.clone(additionalSettings) ?? {};
          delete clonedAdditionalSettings.iceServers;
          delete clonedAdditionalSettings.iceTransportPolicy;
          delete clonedAdditionalSettings.bundlePolicy;
          delete clonedAdditionalSettings.rtcpMuxPolicy;
          delete clonedAdditionalSettings.sdpSemantics;
          this._handler = handlerFactory();
          this._handler.run({
            direction,
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
            iceServers,
            iceTransportPolicy,
            additionalSettings: clonedAdditionalSettings,
            proprietaryConstraints,
            extendedRtpCapabilities
          });
          this._appData = appData ?? {};
          this.handleHandler();
        }
        /**
         * Transport id.
         */
        get id() {
          return this._id;
        }
        /**
         * Whether the Transport is closed.
         */
        get closed() {
          return this._closed;
        }
        /**
         * Transport direction.
         */
        get direction() {
          return this._direction;
        }
        /**
         * RTC handler instance.
         */
        get handler() {
          return this._handler;
        }
        /**
         * ICE gathering state.
         */
        get iceGatheringState() {
          return this._iceGatheringState;
        }
        /**
         * Connection state.
         */
        get connectionState() {
          return this._connectionState;
        }
        /**
         * App custom data.
         */
        get appData() {
          return this._appData;
        }
        /**
         * App custom data setter.
         */
        set appData(appData) {
          this._appData = appData;
        }
        get observer() {
          return this._observer;
        }
        /**
         * Close the Transport.
         */
        close() {
          if (this._closed) {
            return;
          }
          logger13.debug("close()");
          this._closed = true;
          this._awaitQueue.stop();
          this._handler.close();
          this._connectionState = "closed";
          for (const producer of this._producers.values()) {
            producer.transportClosed();
          }
          this._producers.clear();
          for (const consumer of this._consumers.values()) {
            consumer.transportClosed();
          }
          this._consumers.clear();
          for (const dataProducer of this._dataProducers.values()) {
            dataProducer.transportClosed();
          }
          this._dataProducers.clear();
          for (const dataConsumer of this._dataConsumers.values()) {
            dataConsumer.transportClosed();
          }
          this._dataConsumers.clear();
          this._observer.safeEmit("close");
        }
        /**
         * Get associated Transport (RTCPeerConnection) stats.
         *
         * @returns {RTCStatsReport}
         */
        async getStats() {
          if (this._closed) {
            throw new errors_1.InvalidStateError("closed");
          }
          return this._handler.getTransportStats();
        }
        /**
         * Restart ICE connection.
         */
        async restartIce({ iceParameters }) {
          logger13.debug("restartIce()");
          if (this._closed) {
            throw new errors_1.InvalidStateError("closed");
          } else if (!iceParameters) {
            throw new TypeError("missing iceParameters");
          }
          return this._awaitQueue.push(async () => await this._handler.restartIce(iceParameters), "transport.restartIce()");
        }
        /**
         * Update ICE servers.
         */
        async updateIceServers({ iceServers } = {}) {
          logger13.debug("updateIceServers()");
          if (this._closed) {
            throw new errors_1.InvalidStateError("closed");
          } else if (!Array.isArray(iceServers)) {
            throw new TypeError("missing iceServers");
          }
          return this._awaitQueue.push(async () => this._handler.updateIceServers(iceServers), "transport.updateIceServers()");
        }
        /**
         * Create a Producer.
         */
        async produce({ track, encodings, codecOptions, codec, stopTracks = true, disableTrackOnPause = true, zeroRtpOnPause = false, onRtpSender, appData = {} } = {}) {
          logger13.debug("produce() [track:%o]", track);
          if (this._closed) {
            throw new errors_1.InvalidStateError("closed");
          } else if (!track) {
            throw new TypeError("missing track");
          } else if (this._direction !== "send") {
            throw new errors_1.UnsupportedError("not a sending Transport");
          } else if (!this._canProduceByKind[track.kind]) {
            throw new errors_1.UnsupportedError(`cannot produce ${track.kind}`);
          } else if (track.readyState === "ended") {
            throw new errors_1.InvalidStateError("track ended");
          } else if (this.listenerCount("connect") === 0 && this._connectionState === "new") {
            throw new TypeError('no "connect" listener set into this transport');
          } else if (this.listenerCount("produce") === 0) {
            throw new TypeError('no "produce" listener set into this transport');
          } else if (appData && typeof appData !== "object") {
            throw new TypeError("if given, appData must be an object");
          }
          return this._awaitQueue.push(async () => {
            let normalizedEncodings;
            if (encodings && !Array.isArray(encodings)) {
              throw TypeError("encodings must be an array");
            } else if (encodings && encodings.length === 0) {
              normalizedEncodings = void 0;
            } else if (encodings) {
              normalizedEncodings = encodings.map((encoding) => {
                const normalizedEncoding = { active: true };
                if (encoding.active === false) {
                  normalizedEncoding.active = false;
                }
                if (typeof encoding.dtx === "boolean") {
                  normalizedEncoding.dtx = encoding.dtx;
                }
                if (typeof encoding.scalabilityMode === "string") {
                  normalizedEncoding.scalabilityMode = encoding.scalabilityMode;
                }
                if (typeof encoding.scaleResolutionDownBy === "number") {
                  normalizedEncoding.scaleResolutionDownBy = encoding.scaleResolutionDownBy;
                }
                if (typeof encoding.maxBitrate === "number") {
                  normalizedEncoding.maxBitrate = encoding.maxBitrate;
                }
                if (typeof encoding.maxFramerate === "number") {
                  normalizedEncoding.maxFramerate = encoding.maxFramerate;
                }
                if (typeof encoding.adaptivePtime === "boolean") {
                  normalizedEncoding.adaptivePtime = encoding.adaptivePtime;
                }
                if (typeof encoding.priority === "string") {
                  normalizedEncoding.priority = encoding.priority;
                }
                if (typeof encoding.networkPriority === "string") {
                  normalizedEncoding.networkPriority = encoding.networkPriority;
                }
                return normalizedEncoding;
              });
            }
            const { localId, rtpParameters, rtpSender } = await this._handler.send({
              track,
              encodings: normalizedEncodings,
              codecOptions,
              codec,
              onRtpSender
            });
            try {
              ortc.validateRtpParameters(rtpParameters);
              const { id } = await new Promise((resolve, reject) => {
                this.safeEmit("produce", {
                  kind: track.kind,
                  rtpParameters,
                  appData
                }, resolve, reject);
              });
              const producer = new Producer_1.Producer({
                id,
                localId,
                rtpSender,
                track,
                rtpParameters,
                stopTracks,
                disableTrackOnPause,
                zeroRtpOnPause,
                appData
              });
              this._producers.set(producer.id, producer);
              this.handleProducer(producer);
              this._observer.safeEmit("newproducer", producer);
              return producer;
            } catch (error) {
              this._handler.stopSending(localId).catch(() => {
              });
              throw error;
            }
          }, "transport.produce()").catch((error) => {
            if (stopTracks) {
              try {
                track.stop();
              } catch (error2) {
              }
            }
            throw error;
          });
        }
        /**
         * Create a Consumer to consume a remote Producer.
         */
        async consume({ id, producerId, kind, rtpParameters, streamId, onRtpReceiver, appData = {} }) {
          logger13.debug("consume()");
          if (this._closed) {
            throw new errors_1.InvalidStateError("closed");
          } else if (this._direction !== "recv") {
            throw new errors_1.UnsupportedError("not a receiving Transport");
          } else if (typeof id !== "string") {
            throw new TypeError("missing id");
          } else if (typeof producerId !== "string") {
            throw new TypeError("missing producerId");
          } else if (kind !== "audio" && kind !== "video") {
            throw new TypeError(`invalid kind '${kind}'`);
          } else if (this.listenerCount("connect") === 0 && this._connectionState === "new") {
            throw new TypeError('no "connect" listener set into this transport');
          } else if (appData && typeof appData !== "object") {
            throw new TypeError("if given, appData must be an object");
          }
          const clonedRtpParameters = utils.clone(rtpParameters);
          const canConsume = ortc.canReceive(clonedRtpParameters, this._extendedRtpCapabilities);
          if (!canConsume) {
            throw new errors_1.UnsupportedError("cannot consume this Producer");
          }
          const consumerCreationTask = new ConsumerCreationTask({
            id,
            producerId,
            kind,
            rtpParameters: clonedRtpParameters,
            streamId,
            onRtpReceiver,
            appData
          });
          this._pendingConsumerTasks.push(consumerCreationTask);
          (0, queue_microtask_1.default)(() => {
            if (this._closed) {
              return;
            }
            if (this._consumerCreationInProgress === false) {
              void this.createPendingConsumers();
            }
          });
          return consumerCreationTask.promise;
        }
        /**
         * Create a DataProducer
         */
        async produceData({ ordered = true, maxPacketLifeTime, maxRetransmits, label = "", protocol = "", appData = {} } = {}) {
          logger13.debug("produceData()");
          if (this._closed) {
            throw new errors_1.InvalidStateError("closed");
          } else if (this._direction !== "send") {
            throw new errors_1.UnsupportedError("not a sending Transport");
          } else if (!this._maxSctpMessageSize) {
            throw new errors_1.UnsupportedError("SCTP not enabled by remote Transport");
          } else if (this.listenerCount("connect") === 0 && this._connectionState === "new") {
            throw new TypeError('no "connect" listener set into this transport');
          } else if (this.listenerCount("producedata") === 0) {
            throw new TypeError('no "producedata" listener set into this transport');
          } else if (appData && typeof appData !== "object") {
            throw new TypeError("if given, appData must be an object");
          }
          if (maxPacketLifeTime || maxRetransmits) {
            ordered = false;
          }
          return this._awaitQueue.push(async () => {
            const { dataChannel, sctpStreamParameters } = await this._handler.sendDataChannel({
              ordered,
              maxPacketLifeTime,
              maxRetransmits,
              label,
              protocol
            });
            ortc.validateSctpStreamParameters(sctpStreamParameters);
            const { id } = await new Promise((resolve, reject) => {
              this.safeEmit("producedata", {
                sctpStreamParameters,
                label,
                protocol,
                appData
              }, resolve, reject);
            });
            const dataProducer = new DataProducer_1.DataProducer({
              id,
              dataChannel,
              sctpStreamParameters,
              appData
            });
            this._dataProducers.set(dataProducer.id, dataProducer);
            this.handleDataProducer(dataProducer);
            this._observer.safeEmit("newdataproducer", dataProducer);
            return dataProducer;
          }, "transport.produceData()");
        }
        /**
         * Create a DataConsumer
         */
        async consumeData({ id, dataProducerId, sctpStreamParameters, label = "", protocol = "", appData = {} }) {
          logger13.debug("consumeData()");
          if (this._closed) {
            throw new errors_1.InvalidStateError("closed");
          } else if (this._direction !== "recv") {
            throw new errors_1.UnsupportedError("not a receiving Transport");
          } else if (!this._maxSctpMessageSize) {
            throw new errors_1.UnsupportedError("SCTP not enabled by remote Transport");
          } else if (typeof id !== "string") {
            throw new TypeError("missing id");
          } else if (typeof dataProducerId !== "string") {
            throw new TypeError("missing dataProducerId");
          } else if (this.listenerCount("connect") === 0 && this._connectionState === "new") {
            throw new TypeError('no "connect" listener set into this transport');
          } else if (appData && typeof appData !== "object") {
            throw new TypeError("if given, appData must be an object");
          }
          const clonedSctpStreamParameters = utils.clone(sctpStreamParameters);
          ortc.validateSctpStreamParameters(clonedSctpStreamParameters);
          return this._awaitQueue.push(async () => {
            const { dataChannel } = await this._handler.receiveDataChannel({
              sctpStreamParameters: clonedSctpStreamParameters,
              label,
              protocol
            });
            const dataConsumer = new DataConsumer_1.DataConsumer({
              id,
              dataProducerId,
              dataChannel,
              sctpStreamParameters: clonedSctpStreamParameters,
              appData
            });
            this._dataConsumers.set(dataConsumer.id, dataConsumer);
            this.handleDataConsumer(dataConsumer);
            this._observer.safeEmit("newdataconsumer", dataConsumer);
            return dataConsumer;
          }, "transport.consumeData()");
        }
        // This method is guaranteed to never throw.
        async createPendingConsumers() {
          this._consumerCreationInProgress = true;
          this._awaitQueue.push(async () => {
            if (this._pendingConsumerTasks.length === 0) {
              logger13.debug("createPendingConsumers() | there is no Consumer to be created");
              return;
            }
            const pendingConsumerTasks = [...this._pendingConsumerTasks];
            this._pendingConsumerTasks = [];
            let videoConsumerForProbator = void 0;
            const optionsList = [];
            for (const task of pendingConsumerTasks) {
              const { id, kind, rtpParameters, streamId, onRtpReceiver } = task.consumerOptions;
              optionsList.push({
                trackId: id,
                kind,
                rtpParameters,
                streamId,
                onRtpReceiver
              });
            }
            try {
              const results = await this._handler.receive(optionsList);
              for (let idx = 0; idx < results.length; ++idx) {
                const task = pendingConsumerTasks[idx];
                const result = results[idx];
                const { id, producerId, kind, rtpParameters, appData } = task.consumerOptions;
                const { localId, rtpReceiver, track } = result;
                const consumer = new Consumer_1.Consumer({
                  id,
                  localId,
                  producerId,
                  rtpReceiver,
                  track,
                  rtpParameters,
                  appData
                });
                this._consumers.set(consumer.id, consumer);
                this.handleConsumer(consumer);
                if (!this._probatorConsumerCreated && !videoConsumerForProbator && kind === "video") {
                  videoConsumerForProbator = consumer;
                }
                this._observer.safeEmit("newconsumer", consumer);
                task.resolve(consumer);
              }
            } catch (error) {
              for (const task of pendingConsumerTasks) {
                task.reject(error);
              }
            }
            if (videoConsumerForProbator) {
              try {
                const probatorRtpParameters = ortc.generateProbatorRtpParameters(videoConsumerForProbator.rtpParameters);
                await this._handler.receive([
                  {
                    trackId: "probator",
                    kind: "video",
                    rtpParameters: probatorRtpParameters
                  }
                ]);
                logger13.debug("createPendingConsumers() | Consumer for RTP probation created");
                this._probatorConsumerCreated = true;
              } catch (error) {
                logger13.error("createPendingConsumers() | failed to create Consumer for RTP probation:%o", error);
              }
            }
          }, "transport.createPendingConsumers()").then(() => {
            this._consumerCreationInProgress = false;
            if (this._pendingConsumerTasks.length > 0) {
              void this.createPendingConsumers();
            }
          }).catch(() => {
          });
        }
        pausePendingConsumers() {
          this._consumerPauseInProgress = true;
          this._awaitQueue.push(async () => {
            if (this._pendingPauseConsumers.size === 0) {
              logger13.debug("pausePendingConsumers() | there is no Consumer to be paused");
              return;
            }
            const pendingPauseConsumers = Array.from(this._pendingPauseConsumers.values());
            this._pendingPauseConsumers.clear();
            try {
              const localIds = pendingPauseConsumers.map((consumer) => consumer.localId);
              await this._handler.pauseReceiving(localIds);
            } catch (error) {
              logger13.error("pausePendingConsumers() | failed to pause Consumers:", error);
            }
          }, "transport.pausePendingConsumers").then(() => {
            this._consumerPauseInProgress = false;
            if (this._pendingPauseConsumers.size > 0) {
              this.pausePendingConsumers();
            }
          }).catch(() => {
          });
        }
        resumePendingConsumers() {
          this._consumerResumeInProgress = true;
          this._awaitQueue.push(async () => {
            if (this._pendingResumeConsumers.size === 0) {
              logger13.debug("resumePendingConsumers() | there is no Consumer to be resumed");
              return;
            }
            const pendingResumeConsumers = Array.from(this._pendingResumeConsumers.values());
            this._pendingResumeConsumers.clear();
            try {
              const localIds = pendingResumeConsumers.map((consumer) => consumer.localId);
              await this._handler.resumeReceiving(localIds);
            } catch (error) {
              logger13.error("resumePendingConsumers() | failed to resume Consumers:", error);
            }
          }, "transport.resumePendingConsumers").then(() => {
            this._consumerResumeInProgress = false;
            if (this._pendingResumeConsumers.size > 0) {
              this.resumePendingConsumers();
            }
          }).catch(() => {
          });
        }
        closePendingConsumers() {
          this._consumerCloseInProgress = true;
          this._awaitQueue.push(async () => {
            if (this._pendingCloseConsumers.size === 0) {
              logger13.debug("closePendingConsumers() | there is no Consumer to be closed");
              return;
            }
            const pendingCloseConsumers = Array.from(this._pendingCloseConsumers.values());
            this._pendingCloseConsumers.clear();
            try {
              await this._handler.stopReceiving(pendingCloseConsumers.map((consumer) => consumer.localId));
            } catch (error) {
              logger13.error("closePendingConsumers() | failed to close Consumers:", error);
            }
          }, "transport.closePendingConsumers").then(() => {
            this._consumerCloseInProgress = false;
            if (this._pendingCloseConsumers.size > 0) {
              this.closePendingConsumers();
            }
          }).catch(() => {
          });
        }
        handleHandler() {
          const handler = this._handler;
          handler.on("@connect", ({ dtlsParameters }, callback, errback) => {
            if (this._closed) {
              errback(new errors_1.InvalidStateError("closed"));
              return;
            }
            this.safeEmit("connect", { dtlsParameters }, callback, errback);
          });
          handler.on("@icegatheringstatechange", (iceGatheringState) => {
            if (iceGatheringState === this._iceGatheringState) {
              return;
            }
            logger13.debug("ICE gathering state changed to %s", iceGatheringState);
            this._iceGatheringState = iceGatheringState;
            if (!this._closed) {
              this.safeEmit("icegatheringstatechange", iceGatheringState);
            }
          });
          handler.on("@connectionstatechange", (connectionState) => {
            if (connectionState === this._connectionState) {
              return;
            }
            logger13.debug("connection state changed to %s", connectionState);
            this._connectionState = connectionState;
            if (!this._closed) {
              this.safeEmit("connectionstatechange", connectionState);
            }
          });
        }
        handleProducer(producer) {
          producer.on("@close", () => {
            this._producers.delete(producer.id);
            if (this._closed) {
              return;
            }
            this._awaitQueue.push(async () => await this._handler.stopSending(producer.localId), "producer @close event").catch((error) => logger13.warn("producer.close() failed:%o", error));
          });
          producer.on("@pause", (callback, errback) => {
            this._awaitQueue.push(async () => await this._handler.pauseSending(producer.localId), "producer @pause event").then(callback).catch(errback);
          });
          producer.on("@resume", (callback, errback) => {
            this._awaitQueue.push(async () => await this._handler.resumeSending(producer.localId), "producer @resume event").then(callback).catch(errback);
          });
          producer.on("@replacetrack", (track, callback, errback) => {
            this._awaitQueue.push(async () => await this._handler.replaceTrack(producer.localId, track), "producer @replacetrack event").then(callback).catch(errback);
          });
          producer.on("@setmaxspatiallayer", (spatialLayer, callback, errback) => {
            this._awaitQueue.push(async () => await this._handler.setMaxSpatialLayer(producer.localId, spatialLayer), "producer @setmaxspatiallayer event").then(callback).catch(errback);
          });
          producer.on("@setrtpencodingparameters", (params, callback, errback) => {
            this._awaitQueue.push(async () => await this._handler.setRtpEncodingParameters(producer.localId, params), "producer @setrtpencodingparameters event").then(callback).catch(errback);
          });
          producer.on("@getstats", (callback, errback) => {
            if (this._closed) {
              return errback(new errors_1.InvalidStateError("closed"));
            }
            this._handler.getSenderStats(producer.localId).then(callback).catch(errback);
          });
        }
        handleConsumer(consumer) {
          consumer.on("@close", () => {
            this._consumers.delete(consumer.id);
            this._pendingPauseConsumers.delete(consumer.id);
            this._pendingResumeConsumers.delete(consumer.id);
            if (this._closed) {
              return;
            }
            this._pendingCloseConsumers.set(consumer.id, consumer);
            if (this._consumerCloseInProgress === false) {
              this.closePendingConsumers();
            }
          });
          consumer.on("@pause", () => {
            if (this._pendingResumeConsumers.has(consumer.id)) {
              this._pendingResumeConsumers.delete(consumer.id);
            }
            this._pendingPauseConsumers.set(consumer.id, consumer);
            (0, queue_microtask_1.default)(() => {
              if (this._closed) {
                return;
              }
              if (this._consumerPauseInProgress === false) {
                this.pausePendingConsumers();
              }
            });
          });
          consumer.on("@resume", () => {
            if (this._pendingPauseConsumers.has(consumer.id)) {
              this._pendingPauseConsumers.delete(consumer.id);
            }
            this._pendingResumeConsumers.set(consumer.id, consumer);
            (0, queue_microtask_1.default)(() => {
              if (this._closed) {
                return;
              }
              if (this._consumerResumeInProgress === false) {
                this.resumePendingConsumers();
              }
            });
          });
          consumer.on("@getstats", (callback, errback) => {
            if (this._closed) {
              return errback(new errors_1.InvalidStateError("closed"));
            }
            this._handler.getReceiverStats(consumer.localId).then(callback).catch(errback);
          });
        }
        handleDataProducer(dataProducer) {
          dataProducer.on("@close", () => {
            this._dataProducers.delete(dataProducer.id);
          });
        }
        handleDataConsumer(dataConsumer) {
          dataConsumer.on("@close", () => {
            this._dataConsumers.delete(dataConsumer.id);
          });
        }
      };
      exports.Transport = Transport2;
    }
  });

  // ../../node_modules/sdp-transform/lib/grammar.js
  var require_grammar = __commonJS({
    "../../node_modules/sdp-transform/lib/grammar.js"(exports, module) {
      var grammar = module.exports = {
        v: [{
          name: "version",
          reg: /^(\d*)$/
        }],
        o: [{
          // o=- 20518 0 IN IP4 203.0.113.1
          // NB: sessionId will be a String in most cases because it is huge
          name: "origin",
          reg: /^(\S*) (\d*) (\d*) (\S*) IP(\d) (\S*)/,
          names: ["username", "sessionId", "sessionVersion", "netType", "ipVer", "address"],
          format: "%s %s %d %s IP%d %s"
        }],
        // default parsing of these only (though some of these feel outdated)
        s: [{ name: "name" }],
        i: [{ name: "description" }],
        u: [{ name: "uri" }],
        e: [{ name: "email" }],
        p: [{ name: "phone" }],
        z: [{ name: "timezones" }],
        // TODO: this one can actually be parsed properly...
        r: [{ name: "repeats" }],
        // TODO: this one can also be parsed properly
        // k: [{}], // outdated thing ignored
        t: [{
          // t=0 0
          name: "timing",
          reg: /^(\d*) (\d*)/,
          names: ["start", "stop"],
          format: "%d %d"
        }],
        c: [{
          // c=IN IP4 10.47.197.26
          name: "connection",
          reg: /^IN IP(\d) (\S*)/,
          names: ["version", "ip"],
          format: "IN IP%d %s"
        }],
        b: [{
          // b=AS:4000
          push: "bandwidth",
          reg: /^(TIAS|AS|CT|RR|RS):(\d*)/,
          names: ["type", "limit"],
          format: "%s:%s"
        }],
        m: [{
          // m=video 51744 RTP/AVP 126 97 98 34 31
          // NB: special - pushes to session
          // TODO: rtp/fmtp should be filtered by the payloads found here?
          reg: /^(\w*) (\d*) ([\w/]*)(?: (.*))?/,
          names: ["type", "port", "protocol", "payloads"],
          format: "%s %d %s %s"
        }],
        a: [
          {
            // a=rtpmap:110 opus/48000/2
            push: "rtp",
            reg: /^rtpmap:(\d*) ([\w\-.]*)(?:\s*\/(\d*)(?:\s*\/(\S*))?)?/,
            names: ["payload", "codec", "rate", "encoding"],
            format: function(o) {
              return o.encoding ? "rtpmap:%d %s/%s/%s" : o.rate ? "rtpmap:%d %s/%s" : "rtpmap:%d %s";
            }
          },
          {
            // a=fmtp:108 profile-level-id=24;object=23;bitrate=64000
            // a=fmtp:111 minptime=10; useinbandfec=1
            push: "fmtp",
            reg: /^fmtp:(\d*) ([\S| ]*)/,
            names: ["payload", "config"],
            format: "fmtp:%d %s"
          },
          {
            // a=control:streamid=0
            name: "control",
            reg: /^control:(.*)/,
            format: "control:%s"
          },
          {
            // a=rtcp:65179 IN IP4 193.84.77.194
            name: "rtcp",
            reg: /^rtcp:(\d*)(?: (\S*) IP(\d) (\S*))?/,
            names: ["port", "netType", "ipVer", "address"],
            format: function(o) {
              return o.address != null ? "rtcp:%d %s IP%d %s" : "rtcp:%d";
            }
          },
          {
            // a=rtcp-fb:98 trr-int 100
            push: "rtcpFbTrrInt",
            reg: /^rtcp-fb:(\*|\d*) trr-int (\d*)/,
            names: ["payload", "value"],
            format: "rtcp-fb:%s trr-int %d"
          },
          {
            // a=rtcp-fb:98 nack rpsi
            push: "rtcpFb",
            reg: /^rtcp-fb:(\*|\d*) ([\w-_]*)(?: ([\w-_]*))?/,
            names: ["payload", "type", "subtype"],
            format: function(o) {
              return o.subtype != null ? "rtcp-fb:%s %s %s" : "rtcp-fb:%s %s";
            }
          },
          {
            // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
            // a=extmap:1/recvonly URI-gps-string
            // a=extmap:3 urn:ietf:params:rtp-hdrext:encrypt urn:ietf:params:rtp-hdrext:smpte-tc 25@600/24
            push: "ext",
            reg: /^extmap:(\d+)(?:\/(\w+))?(?: (urn:ietf:params:rtp-hdrext:encrypt))? (\S*)(?: (\S*))?/,
            names: ["value", "direction", "encrypt-uri", "uri", "config"],
            format: function(o) {
              return "extmap:%d" + (o.direction ? "/%s" : "%v") + (o["encrypt-uri"] ? " %s" : "%v") + " %s" + (o.config ? " %s" : "");
            }
          },
          {
            // a=extmap-allow-mixed
            name: "extmapAllowMixed",
            reg: /^(extmap-allow-mixed)/
          },
          {
            // a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:PS1uQCVeeCFCanVmcjkpPywjNWhcYD0mXXtxaVBR|2^20|1:32
            push: "crypto",
            reg: /^crypto:(\d*) ([\w_]*) (\S*)(?: (\S*))?/,
            names: ["id", "suite", "config", "sessionConfig"],
            format: function(o) {
              return o.sessionConfig != null ? "crypto:%d %s %s %s" : "crypto:%d %s %s";
            }
          },
          {
            // a=setup:actpass
            name: "setup",
            reg: /^setup:(\w*)/,
            format: "setup:%s"
          },
          {
            // a=connection:new
            name: "connectionType",
            reg: /^connection:(new|existing)/,
            format: "connection:%s"
          },
          {
            // a=mid:1
            name: "mid",
            reg: /^mid:([^\s]*)/,
            format: "mid:%s"
          },
          {
            // a=msid:0c8b064d-d807-43b4-b434-f92a889d8587 98178685-d409-46e0-8e16-7ef0db0db64a
            name: "msid",
            reg: /^msid:(.*)/,
            format: "msid:%s"
          },
          {
            // a=ptime:20
            name: "ptime",
            reg: /^ptime:(\d*(?:\.\d*)*)/,
            format: "ptime:%d"
          },
          {
            // a=maxptime:60
            name: "maxptime",
            reg: /^maxptime:(\d*(?:\.\d*)*)/,
            format: "maxptime:%d"
          },
          {
            // a=sendrecv
            name: "direction",
            reg: /^(sendrecv|recvonly|sendonly|inactive)/
          },
          {
            // a=ice-lite
            name: "icelite",
            reg: /^(ice-lite)/
          },
          {
            // a=ice-ufrag:F7gI
            name: "iceUfrag",
            reg: /^ice-ufrag:(\S*)/,
            format: "ice-ufrag:%s"
          },
          {
            // a=ice-pwd:x9cml/YzichV2+XlhiMu8g
            name: "icePwd",
            reg: /^ice-pwd:(\S*)/,
            format: "ice-pwd:%s"
          },
          {
            // a=fingerprint:SHA-1 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33
            name: "fingerprint",
            reg: /^fingerprint:(\S*) (\S*)/,
            names: ["type", "hash"],
            format: "fingerprint:%s %s"
          },
          {
            // a=candidate:0 1 UDP 2113667327 203.0.113.1 54400 typ host
            // a=candidate:1162875081 1 udp 2113937151 192.168.34.75 60017 typ host generation 0 network-id 3 network-cost 10
            // a=candidate:3289912957 2 udp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0 network-id 3 network-cost 10
            // a=candidate:229815620 1 tcp 1518280447 192.168.150.19 60017 typ host tcptype active generation 0 network-id 3 network-cost 10
            // a=candidate:3289912957 2 tcp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 tcptype passive generation 0 network-id 3 network-cost 10
            push: "candidates",
            reg: /^candidate:(\S*) (\d*) (\S*) (\d*) (\S*) (\d*) typ (\S*)(?: raddr (\S*) rport (\d*))?(?: tcptype (\S*))?(?: generation (\d*))?(?: network-id (\d*))?(?: network-cost (\d*))?/,
            names: ["foundation", "component", "transport", "priority", "ip", "port", "type", "raddr", "rport", "tcptype", "generation", "network-id", "network-cost"],
            format: function(o) {
              var str = "candidate:%s %d %s %d %s %d typ %s";
              str += o.raddr != null ? " raddr %s rport %d" : "%v%v";
              str += o.tcptype != null ? " tcptype %s" : "%v";
              if (o.generation != null) {
                str += " generation %d";
              }
              str += o["network-id"] != null ? " network-id %d" : "%v";
              str += o["network-cost"] != null ? " network-cost %d" : "%v";
              return str;
            }
          },
          {
            // a=end-of-candidates (keep after the candidates line for readability)
            name: "endOfCandidates",
            reg: /^(end-of-candidates)/
          },
          {
            // a=remote-candidates:1 203.0.113.1 54400 2 203.0.113.1 54401 ...
            name: "remoteCandidates",
            reg: /^remote-candidates:(.*)/,
            format: "remote-candidates:%s"
          },
          {
            // a=ice-options:google-ice
            name: "iceOptions",
            reg: /^ice-options:(\S*)/,
            format: "ice-options:%s"
          },
          {
            // a=ssrc:2566107569 cname:t9YU8M1UxTF8Y1A1
            push: "ssrcs",
            reg: /^ssrc:(\d*) ([\w_-]*)(?::(.*))?/,
            names: ["id", "attribute", "value"],
            format: function(o) {
              var str = "ssrc:%d";
              if (o.attribute != null) {
                str += " %s";
                if (o.value != null) {
                  str += ":%s";
                }
              }
              return str;
            }
          },
          {
            // a=ssrc-group:FEC 1 2
            // a=ssrc-group:FEC-FR 3004364195 1080772241
            push: "ssrcGroups",
            // token-char = %x21 / %x23-27 / %x2A-2B / %x2D-2E / %x30-39 / %x41-5A / %x5E-7E
            reg: /^ssrc-group:([\x21\x23\x24\x25\x26\x27\x2A\x2B\x2D\x2E\w]*) (.*)/,
            names: ["semantics", "ssrcs"],
            format: "ssrc-group:%s %s"
          },
          {
            // a=msid-semantic: WMS Jvlam5X3SX1OP6pn20zWogvaKJz5Hjf9OnlV
            name: "msidSemantic",
            reg: /^msid-semantic:\s?(\w*) (\S*)/,
            names: ["semantic", "token"],
            format: "msid-semantic: %s %s"
            // space after ':' is not accidental
          },
          {
            // a=group:BUNDLE audio video
            push: "groups",
            reg: /^group:(\w*) (.*)/,
            names: ["type", "mids"],
            format: "group:%s %s"
          },
          {
            // a=rtcp-mux
            name: "rtcpMux",
            reg: /^(rtcp-mux)/
          },
          {
            // a=rtcp-rsize
            name: "rtcpRsize",
            reg: /^(rtcp-rsize)/
          },
          {
            // a=sctpmap:5000 webrtc-datachannel 1024
            name: "sctpmap",
            reg: /^sctpmap:([\w_/]*) (\S*)(?: (\S*))?/,
            names: ["sctpmapNumber", "app", "maxMessageSize"],
            format: function(o) {
              return o.maxMessageSize != null ? "sctpmap:%s %s %s" : "sctpmap:%s %s";
            }
          },
          {
            // a=x-google-flag:conference
            name: "xGoogleFlag",
            reg: /^x-google-flag:([^\s]*)/,
            format: "x-google-flag:%s"
          },
          {
            // a=rid:1 send max-width=1280;max-height=720;max-fps=30;depend=0
            push: "rids",
            reg: /^rid:([\d\w]+) (\w+)(?: ([\S| ]*))?/,
            names: ["id", "direction", "params"],
            format: function(o) {
              return o.params ? "rid:%s %s %s" : "rid:%s %s";
            }
          },
          {
            // a=imageattr:97 send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320] recv [x=330,y=250]
            // a=imageattr:* send [x=800,y=640] recv *
            // a=imageattr:100 recv [x=320,y=240]
            push: "imageattrs",
            reg: new RegExp(
              // a=imageattr:97
              "^imageattr:(\\d+|\\*)[\\s\\t]+(send|recv)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*)(?:[\\s\\t]+(recv|send)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*))?"
            ),
            names: ["pt", "dir1", "attrs1", "dir2", "attrs2"],
            format: function(o) {
              return "imageattr:%s %s %s" + (o.dir2 ? " %s %s" : "");
            }
          },
          {
            // a=simulcast:send 1,2,3;~4,~5 recv 6;~7,~8
            // a=simulcast:recv 1;4,5 send 6;7
            name: "simulcast",
            reg: new RegExp(
              // a=simulcast:
              "^simulcast:(send|recv) ([a-zA-Z0-9\\-_~;,]+)(?:\\s?(send|recv) ([a-zA-Z0-9\\-_~;,]+))?$"
            ),
            names: ["dir1", "list1", "dir2", "list2"],
            format: function(o) {
              return "simulcast:%s %s" + (o.dir2 ? " %s %s" : "");
            }
          },
          {
            // old simulcast draft 03 (implemented by Firefox)
            //   https://tools.ietf.org/html/draft-ietf-mmusic-sdp-simulcast-03
            // a=simulcast: recv pt=97;98 send pt=97
            // a=simulcast: send rid=5;6;7 paused=6,7
            name: "simulcast_03",
            reg: /^simulcast:[\s\t]+([\S+\s\t]+)$/,
            names: ["value"],
            format: "simulcast: %s"
          },
          {
            // a=framerate:25
            // a=framerate:29.97
            name: "framerate",
            reg: /^framerate:(\d+(?:$|\.\d+))/,
            format: "framerate:%s"
          },
          {
            // RFC4570
            // a=source-filter: incl IN IP4 239.5.2.31 10.1.15.5
            name: "sourceFilter",
            reg: /^source-filter: *(excl|incl) (\S*) (IP4|IP6|\*) (\S*) (.*)/,
            names: ["filterMode", "netType", "addressTypes", "destAddress", "srcList"],
            format: "source-filter: %s %s %s %s %s"
          },
          {
            // a=bundle-only
            name: "bundleOnly",
            reg: /^(bundle-only)/
          },
          {
            // a=label:1
            name: "label",
            reg: /^label:(.+)/,
            format: "label:%s"
          },
          {
            // RFC version 26 for SCTP over DTLS
            // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-5
            name: "sctpPort",
            reg: /^sctp-port:(\d+)$/,
            format: "sctp-port:%s"
          },
          {
            // RFC version 26 for SCTP over DTLS
            // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-6
            name: "maxMessageSize",
            reg: /^max-message-size:(\d+)$/,
            format: "max-message-size:%s"
          },
          {
            // RFC7273
            // a=ts-refclk:ptp=IEEE1588-2008:39-A7-94-FF-FE-07-CB-D0:37
            push: "tsRefClocks",
            reg: /^ts-refclk:([^\s=]*)(?:=(\S*))?/,
            names: ["clksrc", "clksrcExt"],
            format: function(o) {
              return "ts-refclk:%s" + (o.clksrcExt != null ? "=%s" : "");
            }
          },
          {
            // RFC7273
            // a=mediaclk:direct=963214424
            name: "mediaClk",
            reg: /^mediaclk:(?:id=(\S*))? *([^\s=]*)(?:=(\S*))?(?: *rate=(\d+)\/(\d+))?/,
            names: ["id", "mediaClockName", "mediaClockValue", "rateNumerator", "rateDenominator"],
            format: function(o) {
              var str = "mediaclk:";
              str += o.id != null ? "id=%s %s" : "%v%s";
              str += o.mediaClockValue != null ? "=%s" : "";
              str += o.rateNumerator != null ? " rate=%s" : "";
              str += o.rateDenominator != null ? "/%s" : "";
              return str;
            }
          },
          {
            // a=keywds:keywords
            name: "keywords",
            reg: /^keywds:(.+)$/,
            format: "keywds:%s"
          },
          {
            // a=content:main
            name: "content",
            reg: /^content:(.+)/,
            format: "content:%s"
          },
          // BFCP https://tools.ietf.org/html/rfc4583
          {
            // a=floorctrl:c-s
            name: "bfcpFloorCtrl",
            reg: /^floorctrl:(c-only|s-only|c-s)/,
            format: "floorctrl:%s"
          },
          {
            // a=confid:1
            name: "bfcpConfId",
            reg: /^confid:(\d+)/,
            format: "confid:%s"
          },
          {
            // a=userid:1
            name: "bfcpUserId",
            reg: /^userid:(\d+)/,
            format: "userid:%s"
          },
          {
            // a=floorid:1
            name: "bfcpFloorId",
            reg: /^floorid:(.+) (?:m-stream|mstrm):(.+)/,
            names: ["id", "mStream"],
            format: "floorid:%s mstrm:%s"
          },
          {
            // any a= that we don't understand is kept verbatim on media.invalid
            push: "invalid",
            names: ["value"]
          }
        ]
      };
      Object.keys(grammar).forEach(function(key) {
        var objs = grammar[key];
        objs.forEach(function(obj) {
          if (!obj.reg) {
            obj.reg = /(.*)/;
          }
          if (!obj.format) {
            obj.format = "%s";
          }
        });
      });
    }
  });

  // ../../node_modules/sdp-transform/lib/parser.js
  var require_parser = __commonJS({
    "../../node_modules/sdp-transform/lib/parser.js"(exports) {
      var toIntIfInt = function(v) {
        return String(Number(v)) === v ? Number(v) : v;
      };
      var attachProperties = function(match, location, names, rawName) {
        if (rawName && !names) {
          location[rawName] = toIntIfInt(match[1]);
        } else {
          for (var i = 0; i < names.length; i += 1) {
            if (match[i + 1] != null) {
              location[names[i]] = toIntIfInt(match[i + 1]);
            }
          }
        }
      };
      var parseReg = function(obj, location, content) {
        var needsBlank = obj.name && obj.names;
        if (obj.push && !location[obj.push]) {
          location[obj.push] = [];
        } else if (needsBlank && !location[obj.name]) {
          location[obj.name] = {};
        }
        var keyLocation = obj.push ? {} : (
          // blank object that will be pushed
          needsBlank ? location[obj.name] : location
        );
        attachProperties(content.match(obj.reg), keyLocation, obj.names, obj.name);
        if (obj.push) {
          location[obj.push].push(keyLocation);
        }
      };
      var grammar = require_grammar();
      var validLine = RegExp.prototype.test.bind(/^([a-z])=(.*)/);
      exports.parse = function(sdp) {
        var session = {}, media = [], location = session;
        sdp.split(/(\r\n|\r|\n)/).filter(validLine).forEach(function(l) {
          var type = l[0];
          var content = l.slice(2);
          if (type === "m") {
            media.push({ rtp: [], fmtp: [] });
            location = media[media.length - 1];
          }
          for (var j = 0; j < (grammar[type] || []).length; j += 1) {
            var obj = grammar[type][j];
            if (obj.reg.test(content)) {
              return parseReg(obj, location, content);
            }
          }
        });
        session.media = media;
        return session;
      };
      var paramReducer = function(acc, expr) {
        var s = expr.split(/=(.+)/, 2);
        if (s.length === 2) {
          acc[s[0]] = toIntIfInt(s[1]);
        } else if (s.length === 1 && expr.length > 1) {
          acc[s[0]] = void 0;
        }
        return acc;
      };
      exports.parseParams = function(str) {
        return str.split(/;\s?/).reduce(paramReducer, {});
      };
      exports.parseFmtpConfig = exports.parseParams;
      exports.parsePayloads = function(str) {
        return str.toString().split(" ").map(Number);
      };
      exports.parseRemoteCandidates = function(str) {
        var candidates = [];
        var parts = str.split(" ").map(toIntIfInt);
        for (var i = 0; i < parts.length; i += 3) {
          candidates.push({
            component: parts[i],
            ip: parts[i + 1],
            port: parts[i + 2]
          });
        }
        return candidates;
      };
      exports.parseImageAttributes = function(str) {
        return str.split(" ").map(function(item) {
          return item.substring(1, item.length - 1).split(",").reduce(paramReducer, {});
        });
      };
      exports.parseSimulcastStreamList = function(str) {
        return str.split(";").map(function(stream) {
          return stream.split(",").map(function(format) {
            var scid, paused = false;
            if (format[0] !== "~") {
              scid = toIntIfInt(format);
            } else {
              scid = toIntIfInt(format.substring(1, format.length));
              paused = true;
            }
            return {
              scid,
              paused
            };
          });
        });
      };
    }
  });

  // ../../node_modules/sdp-transform/lib/writer.js
  var require_writer = __commonJS({
    "../../node_modules/sdp-transform/lib/writer.js"(exports, module) {
      var grammar = require_grammar();
      var formatRegExp = /%[sdv%]/g;
      var format = function(formatStr) {
        var i = 1;
        var args = arguments;
        var len = args.length;
        return formatStr.replace(formatRegExp, function(x) {
          if (i >= len) {
            return x;
          }
          var arg = args[i];
          i += 1;
          switch (x) {
            case "%%":
              return "%";
            case "%s":
              return String(arg);
            case "%d":
              return Number(arg);
            case "%v":
              return "";
          }
        });
      };
      var makeLine = function(type, obj, location) {
        var str = obj.format instanceof Function ? obj.format(obj.push ? location : location[obj.name]) : obj.format;
        var args = [type + "=" + str];
        if (obj.names) {
          for (var i = 0; i < obj.names.length; i += 1) {
            var n = obj.names[i];
            if (obj.name) {
              args.push(location[obj.name][n]);
            } else {
              args.push(location[obj.names[i]]);
            }
          }
        } else {
          args.push(location[obj.name]);
        }
        return format.apply(null, args);
      };
      var defaultOuterOrder = [
        "v",
        "o",
        "s",
        "i",
        "u",
        "e",
        "p",
        "c",
        "b",
        "t",
        "r",
        "z",
        "a"
      ];
      var defaultInnerOrder = ["i", "c", "b", "a"];
      module.exports = function(session, opts) {
        opts = opts || {};
        if (session.version == null) {
          session.version = 0;
        }
        if (session.name == null) {
          session.name = " ";
        }
        session.media.forEach(function(mLine) {
          if (mLine.payloads == null) {
            mLine.payloads = "";
          }
        });
        var outerOrder = opts.outerOrder || defaultOuterOrder;
        var innerOrder = opts.innerOrder || defaultInnerOrder;
        var sdp = [];
        outerOrder.forEach(function(type) {
          grammar[type].forEach(function(obj) {
            if (obj.name in session && session[obj.name] != null) {
              sdp.push(makeLine(type, obj, session));
            } else if (obj.push in session && session[obj.push] != null) {
              session[obj.push].forEach(function(el) {
                sdp.push(makeLine(type, obj, el));
              });
            }
          });
        });
        session.media.forEach(function(mLine) {
          sdp.push(makeLine("m", grammar.m[0], mLine));
          innerOrder.forEach(function(type) {
            grammar[type].forEach(function(obj) {
              if (obj.name in mLine && mLine[obj.name] != null) {
                sdp.push(makeLine(type, obj, mLine));
              } else if (obj.push in mLine && mLine[obj.push] != null) {
                mLine[obj.push].forEach(function(el) {
                  sdp.push(makeLine(type, obj, el));
                });
              }
            });
          });
        });
        return sdp.join("\r\n") + "\r\n";
      };
    }
  });

  // ../../node_modules/sdp-transform/lib/index.js
  var require_lib3 = __commonJS({
    "../../node_modules/sdp-transform/lib/index.js"(exports) {
      var parser = require_parser();
      var writer = require_writer();
      exports.write = writer;
      exports.parse = parser.parse;
      exports.parseParams = parser.parseParams;
      exports.parseFmtpConfig = parser.parseFmtpConfig;
      exports.parsePayloads = parser.parsePayloads;
      exports.parseRemoteCandidates = parser.parseRemoteCandidates;
      exports.parseImageAttributes = parser.parseImageAttributes;
      exports.parseSimulcastStreamList = parser.parseSimulcastStreamList;
    }
  });

  // ../../node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js
  var require_commonUtils = __commonJS({
    "../../node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js"(exports) {
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.extractRtpCapabilities = extractRtpCapabilities;
      exports.extractDtlsParameters = extractDtlsParameters;
      exports.getCname = getCname;
      exports.applyCodecParameters = applyCodecParameters;
      var sdpTransform = __importStar(require_lib3());
      function extractRtpCapabilities({ sdpObject }) {
        const codecsMap = /* @__PURE__ */ new Map();
        const headerExtensions = [];
        let gotAudio = false;
        let gotVideo = false;
        for (const m of sdpObject.media) {
          const kind = m.type;
          switch (kind) {
            case "audio": {
              if (gotAudio) {
                continue;
              }
              gotAudio = true;
              break;
            }
            case "video": {
              if (gotVideo) {
                continue;
              }
              gotVideo = true;
              break;
            }
            default: {
              continue;
            }
          }
          for (const rtp of m.rtp) {
            const codec = {
              kind,
              mimeType: `${kind}/${rtp.codec}`,
              preferredPayloadType: rtp.payload,
              clockRate: rtp.rate,
              channels: rtp.encoding,
              parameters: {},
              rtcpFeedback: []
            };
            codecsMap.set(codec.preferredPayloadType, codec);
          }
          for (const fmtp of m.fmtp || []) {
            const parameters = sdpTransform.parseParams(fmtp.config);
            const codec = codecsMap.get(fmtp.payload);
            if (!codec) {
              continue;
            }
            if (parameters?.hasOwnProperty("profile-level-id")) {
              parameters["profile-level-id"] = String(parameters["profile-level-id"]);
            }
            codec.parameters = parameters;
          }
          for (const fb of m.rtcpFb || []) {
            const feedback = {
              type: fb.type,
              parameter: fb.subtype
            };
            if (!feedback.parameter) {
              delete feedback.parameter;
            }
            if (fb.payload !== "*") {
              const codec = codecsMap.get(fb.payload);
              if (!codec) {
                continue;
              }
              codec.rtcpFeedback.push(feedback);
            } else {
              for (const codec of codecsMap.values()) {
                if (codec.kind === kind && !/.+\/rtx$/i.test(codec.mimeType)) {
                  codec.rtcpFeedback.push(feedback);
                }
              }
            }
          }
          for (const ext of m.ext || []) {
            if (ext["encrypt-uri"]) {
              continue;
            }
            const headerExtension = {
              kind,
              uri: ext.uri,
              preferredId: ext.value
            };
            headerExtensions.push(headerExtension);
          }
        }
        const rtpCapabilities = {
          codecs: Array.from(codecsMap.values()),
          headerExtensions
        };
        return rtpCapabilities;
      }
      function extractDtlsParameters({ sdpObject }) {
        let setup = sdpObject.setup;
        let fingerprint = sdpObject.fingerprint;
        if (!setup || !fingerprint) {
          const mediaObject = (sdpObject.media || []).find((m) => m.port !== 0);
          if (mediaObject) {
            setup ?? (setup = mediaObject.setup);
            fingerprint ?? (fingerprint = mediaObject.fingerprint);
          }
        }
        if (!setup) {
          throw new Error("no a=setup found at SDP session or media level");
        } else if (!fingerprint) {
          throw new Error("no a=fingerprint found at SDP session or media level");
        }
        let role;
        switch (setup) {
          case "active": {
            role = "client";
            break;
          }
          case "passive": {
            role = "server";
            break;
          }
          case "actpass": {
            role = "auto";
            break;
          }
        }
        const dtlsParameters = {
          role,
          fingerprints: [
            {
              algorithm: fingerprint.type,
              value: fingerprint.hash
            }
          ]
        };
        return dtlsParameters;
      }
      function getCname({ offerMediaObject }) {
        const ssrcCnameLine = (offerMediaObject.ssrcs || []).find((line) => line.attribute === "cname");
        if (!ssrcCnameLine) {
          return "";
        }
        return ssrcCnameLine.value;
      }
      function applyCodecParameters({ offerRtpParameters, answerMediaObject }) {
        for (const codec of offerRtpParameters.codecs) {
          const mimeType = codec.mimeType.toLowerCase();
          if (mimeType !== "audio/opus") {
            continue;
          }
          const rtp = (answerMediaObject.rtp || []).find((r) => r.payload === codec.payloadType);
          if (!rtp) {
            continue;
          }
          answerMediaObject.fmtp = answerMediaObject.fmtp || [];
          let fmtp = answerMediaObject.fmtp.find((f) => f.payload === codec.payloadType);
          if (!fmtp) {
            fmtp = { payload: codec.payloadType, config: "" };
            answerMediaObject.fmtp.push(fmtp);
          }
          const parameters = sdpTransform.parseParams(fmtp.config);
          switch (mimeType) {
            case "audio/opus": {
              const spropStereo = codec.parameters["sprop-stereo"];
              if (spropStereo !== void 0) {
                parameters.stereo = spropStereo ? 1 : 0;
              }
              break;
            }
          }
          fmtp.config = "";
          for (const key of Object.keys(parameters)) {
            if (fmtp.config) {
              fmtp.config += ";";
            }
            fmtp.config += `${key}=${parameters[key]}`;
          }
        }
      }
    }
  });

  // ../../node_modules/mediasoup-client/lib/handlers/sdp/unifiedPlanUtils.js
  var require_unifiedPlanUtils = __commonJS({
    "../../node_modules/mediasoup-client/lib/handlers/sdp/unifiedPlanUtils.js"(exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getRtpEncodings = getRtpEncodings;
      exports.addLegacySimulcast = addLegacySimulcast;
      function getRtpEncodings({ offerMediaObject }) {
        const ssrcs = /* @__PURE__ */ new Set();
        for (const line of offerMediaObject.ssrcs || []) {
          const ssrc = line.id;
          ssrcs.add(ssrc);
        }
        if (ssrcs.size === 0) {
          throw new Error("no a=ssrc lines found");
        }
        const ssrcToRtxSsrc = /* @__PURE__ */ new Map();
        for (const line of offerMediaObject.ssrcGroups || []) {
          if (line.semantics !== "FID") {
            continue;
          }
          let [ssrc, rtxSsrc] = line.ssrcs.split(/\s+/);
          ssrc = Number(ssrc);
          rtxSsrc = Number(rtxSsrc);
          if (ssrcs.has(ssrc)) {
            ssrcs.delete(ssrc);
            ssrcs.delete(rtxSsrc);
            ssrcToRtxSsrc.set(ssrc, rtxSsrc);
          }
        }
        for (const ssrc of ssrcs) {
          ssrcToRtxSsrc.set(ssrc, null);
        }
        const encodings = [];
        for (const [ssrc, rtxSsrc] of ssrcToRtxSsrc) {
          const encoding = { ssrc };
          if (rtxSsrc) {
            encoding.rtx = { ssrc: rtxSsrc };
          }
          encodings.push(encoding);
        }
        return encodings;
      }
      function addLegacySimulcast({ offerMediaObject, numStreams }) {
        if (numStreams <= 1) {
          throw new TypeError("numStreams must be greater than 1");
        }
        const ssrcMsidLine = (offerMediaObject.ssrcs || []).find((line) => line.attribute === "msid");
        if (!ssrcMsidLine) {
          throw new Error("a=ssrc line with msid information not found");
        }
        const [streamId, trackId] = ssrcMsidLine.value.split(" ");
        const firstSsrc = Number(ssrcMsidLine.id);
        let firstRtxSsrc;
        (offerMediaObject.ssrcGroups || []).some((line) => {
          if (line.semantics !== "FID") {
            return false;
          }
          const ssrcs2 = line.ssrcs.split(/\s+/);
          if (Number(ssrcs2[0]) === firstSsrc) {
            firstRtxSsrc = Number(ssrcs2[1]);
            return true;
          } else {
            return false;
          }
        });
        const ssrcCnameLine = offerMediaObject.ssrcs.find((line) => line.attribute === "cname");
        if (!ssrcCnameLine) {
          throw new Error("a=ssrc line with cname information not found");
        }
        const cname = ssrcCnameLine.value;
        const ssrcs = [];
        const rtxSsrcs = [];
        for (let i = 0; i < numStreams; ++i) {
          ssrcs.push(firstSsrc + i);
          if (firstRtxSsrc) {
            rtxSsrcs.push(firstRtxSsrc + i);
          }
        }
        offerMediaObject.ssrcGroups = [];
        offerMediaObject.ssrcs = [];
        offerMediaObject.ssrcGroups.push({
          semantics: "SIM",
          ssrcs: ssrcs.join(" ")
        });
        for (const ssrc of ssrcs) {
          offerMediaObject.ssrcs.push({
            id: ssrc,
            attribute: "cname",
            value: cname
          });
          offerMediaObject.ssrcs.push({
            id: ssrc,
            attribute: "msid",
            value: `${streamId} ${trackId}`
          });
        }
        for (let i = 0; i < rtxSsrcs.length; ++i) {
          const ssrc = ssrcs[i];
          const rtxSsrc = rtxSsrcs[i];
          offerMediaObject.ssrcs.push({
            id: rtxSsrc,
            attribute: "cname",
            value: cname
          });
          offerMediaObject.ssrcs.push({
            id: rtxSsrc,
            attribute: "msid",
            value: `${streamId} ${trackId}`
          });
          offerMediaObject.ssrcGroups.push({
            semantics: "FID",
            ssrcs: `${ssrc} ${rtxSsrc}`
          });
        }
      }
    }
  });

  // ../../node_modules/mediasoup-client/lib/handlers/ortc/utils.js
  var require_utils2 = __commonJS({
    "../../node_modules/mediasoup-client/lib/handlers/ortc/utils.js"(exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.addNackSuppportForOpus = addNackSuppportForOpus;
      function addNackSuppportForOpus(rtpCapabilities) {
        for (const codec of rtpCapabilities.codecs ?? []) {
          if ((codec.mimeType.toLowerCase() === "audio/opus" || codec.mimeType.toLowerCase() === "audio/multiopus") && !codec.rtcpFeedback?.some((fb) => fb.type === "nack" && !fb.parameter)) {
            if (!codec.rtcpFeedback) {
              codec.rtcpFeedback = [];
            }
            codec.rtcpFeedback.push({ type: "nack" });
          }
        }
      }
    }
  });

  // ../../node_modules/mediasoup-client/lib/handlers/HandlerInterface.js
  var require_HandlerInterface = __commonJS({
    "../../node_modules/mediasoup-client/lib/handlers/HandlerInterface.js"(exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.HandlerInterface = void 0;
      var enhancedEvents_1 = require_enhancedEvents();
      var HandlerInterface = class extends enhancedEvents_1.EnhancedEventEmitter {
        constructor() {
          super();
        }
      };
      exports.HandlerInterface = HandlerInterface;
    }
  });

  // ../../node_modules/mediasoup-client/lib/handlers/sdp/MediaSection.js
  var require_MediaSection = __commonJS({
    "../../node_modules/mediasoup-client/lib/handlers/sdp/MediaSection.js"(exports) {
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.OfferMediaSection = exports.AnswerMediaSection = exports.MediaSection = void 0;
      var sdpTransform = __importStar(require_lib3());
      var utils = __importStar(require_utils());
      var MediaSection = class {
        constructor({ iceParameters, iceCandidates, dtlsParameters, planB = false }) {
          this._mediaObject = {};
          this._planB = planB;
          if (iceParameters) {
            this.setIceParameters(iceParameters);
          }
          if (iceCandidates) {
            this._mediaObject.candidates = [];
            for (const candidate of iceCandidates) {
              const candidateObject = {};
              candidateObject.component = 1;
              candidateObject.foundation = candidate.foundation;
              candidateObject.ip = candidate.address ?? candidate.ip;
              candidateObject.port = candidate.port;
              candidateObject.priority = candidate.priority;
              candidateObject.transport = candidate.protocol;
              candidateObject.type = candidate.type;
              if (candidate.tcpType) {
                candidateObject.tcptype = candidate.tcpType;
              }
              this._mediaObject.candidates.push(candidateObject);
            }
            this._mediaObject.endOfCandidates = "end-of-candidates";
            this._mediaObject.iceOptions = "renomination";
          }
          if (dtlsParameters) {
            this.setDtlsRole(dtlsParameters.role);
          }
        }
        get mid() {
          return String(this._mediaObject.mid);
        }
        get closed() {
          return this._mediaObject.port === 0;
        }
        getObject() {
          return this._mediaObject;
        }
        setIceParameters(iceParameters) {
          this._mediaObject.iceUfrag = iceParameters.usernameFragment;
          this._mediaObject.icePwd = iceParameters.password;
        }
        pause() {
          this._mediaObject.direction = "inactive";
        }
        disable() {
          this.pause();
          delete this._mediaObject.ext;
          delete this._mediaObject.ssrcs;
          delete this._mediaObject.ssrcGroups;
          delete this._mediaObject.simulcast;
          delete this._mediaObject.simulcast_03;
          delete this._mediaObject.rids;
          delete this._mediaObject.extmapAllowMixed;
        }
        close() {
          this.disable();
          this._mediaObject.port = 0;
        }
      };
      exports.MediaSection = MediaSection;
      var AnswerMediaSection = class extends MediaSection {
        constructor({ iceParameters, iceCandidates, dtlsParameters, sctpParameters, plainRtpParameters, planB = false, offerMediaObject, offerRtpParameters, answerRtpParameters, codecOptions, extmapAllowMixed = false }) {
          super({ iceParameters, iceCandidates, dtlsParameters, planB });
          this._mediaObject.mid = String(offerMediaObject.mid);
          this._mediaObject.type = offerMediaObject.type;
          this._mediaObject.protocol = offerMediaObject.protocol;
          if (!plainRtpParameters) {
            this._mediaObject.connection = { ip: "127.0.0.1", version: 4 };
            this._mediaObject.port = 7;
          } else {
            this._mediaObject.connection = {
              ip: plainRtpParameters.ip,
              version: plainRtpParameters.ipVersion
            };
            this._mediaObject.port = plainRtpParameters.port;
          }
          switch (offerMediaObject.type) {
            case "audio":
            case "video": {
              this._mediaObject.direction = "recvonly";
              this._mediaObject.rtp = [];
              this._mediaObject.rtcpFb = [];
              this._mediaObject.fmtp = [];
              for (const codec of answerRtpParameters.codecs) {
                const rtp = {
                  payload: codec.payloadType,
                  codec: getCodecName(codec),
                  rate: codec.clockRate
                };
                if (codec.channels > 1) {
                  rtp.encoding = codec.channels;
                }
                this._mediaObject.rtp.push(rtp);
                const codecParameters = utils.clone(codec.parameters) ?? {};
                let codecRtcpFeedback = utils.clone(codec.rtcpFeedback) ?? [];
                if (codecOptions) {
                  const { opusStereo, opusFec, opusDtx, opusMaxPlaybackRate, opusMaxAverageBitrate, opusPtime, opusNack, videoGoogleStartBitrate, videoGoogleMaxBitrate, videoGoogleMinBitrate } = codecOptions;
                  const offerCodec = offerRtpParameters.codecs.find((c) => c.payloadType === codec.payloadType);
                  switch (codec.mimeType.toLowerCase()) {
                    case "audio/opus":
                    case "audio/multiopus": {
                      if (opusStereo !== void 0) {
                        offerCodec.parameters["sprop-stereo"] = opusStereo ? 1 : 0;
                        codecParameters.stereo = opusStereo ? 1 : 0;
                      }
                      if (opusFec !== void 0) {
                        offerCodec.parameters.useinbandfec = opusFec ? 1 : 0;
                        codecParameters.useinbandfec = opusFec ? 1 : 0;
                      }
                      if (opusDtx !== void 0) {
                        offerCodec.parameters.usedtx = opusDtx ? 1 : 0;
                        codecParameters.usedtx = opusDtx ? 1 : 0;
                      }
                      if (opusMaxPlaybackRate !== void 0) {
                        codecParameters.maxplaybackrate = opusMaxPlaybackRate;
                      }
                      if (opusMaxAverageBitrate !== void 0) {
                        codecParameters.maxaveragebitrate = opusMaxAverageBitrate;
                      }
                      if (opusPtime !== void 0) {
                        offerCodec.parameters.ptime = opusPtime;
                        codecParameters.ptime = opusPtime;
                      }
                      if (!opusNack) {
                        offerCodec.rtcpFeedback = offerCodec.rtcpFeedback.filter((fb) => fb.type !== "nack" || fb.parameter);
                        codecRtcpFeedback = codecRtcpFeedback.filter((fb) => fb.type !== "nack" || fb.parameter);
                      }
                      break;
                    }
                    case "video/vp8":
                    case "video/vp9":
                    case "video/h264":
                    case "video/h265": {
                      if (videoGoogleStartBitrate !== void 0) {
                        codecParameters["x-google-start-bitrate"] = videoGoogleStartBitrate;
                      }
                      if (videoGoogleMaxBitrate !== void 0) {
                        codecParameters["x-google-max-bitrate"] = videoGoogleMaxBitrate;
                      }
                      if (videoGoogleMinBitrate !== void 0) {
                        codecParameters["x-google-min-bitrate"] = videoGoogleMinBitrate;
                      }
                      break;
                    }
                  }
                }
                const fmtp = {
                  payload: codec.payloadType,
                  config: ""
                };
                for (const key of Object.keys(codecParameters)) {
                  if (fmtp.config) {
                    fmtp.config += ";";
                  }
                  fmtp.config += `${key}=${codecParameters[key]}`;
                }
                if (fmtp.config) {
                  this._mediaObject.fmtp.push(fmtp);
                }
                for (const fb of codecRtcpFeedback) {
                  this._mediaObject.rtcpFb.push({
                    payload: codec.payloadType,
                    type: fb.type,
                    subtype: fb.parameter
                  });
                }
              }
              this._mediaObject.payloads = answerRtpParameters.codecs.map((codec) => codec.payloadType).join(" ");
              this._mediaObject.ext = [];
              for (const ext of answerRtpParameters.headerExtensions) {
                const found = (offerMediaObject.ext ?? []).some((localExt) => localExt.uri === ext.uri);
                if (!found) {
                  continue;
                }
                this._mediaObject.ext.push({
                  uri: ext.uri,
                  value: ext.id
                });
              }
              if (extmapAllowMixed && offerMediaObject.extmapAllowMixed === "extmap-allow-mixed") {
                this._mediaObject.extmapAllowMixed = "extmap-allow-mixed";
              }
              if (offerMediaObject.simulcast) {
                this._mediaObject.simulcast = {
                  dir1: "recv",
                  list1: offerMediaObject.simulcast.list1
                };
                this._mediaObject.rids = [];
                for (const rid of offerMediaObject.rids ?? []) {
                  if (rid.direction !== "send") {
                    continue;
                  }
                  this._mediaObject.rids.push({
                    id: rid.id,
                    direction: "recv"
                  });
                }
              } else if (offerMediaObject.simulcast_03) {
                this._mediaObject.simulcast_03 = {
                  value: offerMediaObject.simulcast_03.value.replace(/send/g, "recv")
                };
                this._mediaObject.rids = [];
                for (const rid of offerMediaObject.rids ?? []) {
                  if (rid.direction !== "send") {
                    continue;
                  }
                  this._mediaObject.rids.push({
                    id: rid.id,
                    direction: "recv"
                  });
                }
              }
              this._mediaObject.rtcpMux = "rtcp-mux";
              this._mediaObject.rtcpRsize = "rtcp-rsize";
              if (this._planB && this._mediaObject.type === "video") {
                this._mediaObject.xGoogleFlag = "conference";
              }
              break;
            }
            case "application": {
              if (typeof offerMediaObject.sctpPort === "number") {
                this._mediaObject.payloads = "webrtc-datachannel";
                this._mediaObject.sctpPort = sctpParameters.port;
                this._mediaObject.maxMessageSize = sctpParameters.maxMessageSize;
              } else if (offerMediaObject.sctpmap) {
                this._mediaObject.payloads = sctpParameters.port;
                this._mediaObject.sctpmap = {
                  app: "webrtc-datachannel",
                  sctpmapNumber: sctpParameters.port,
                  maxMessageSize: sctpParameters.maxMessageSize
                };
              }
              break;
            }
          }
        }
        setDtlsRole(role) {
          switch (role) {
            case "client": {
              this._mediaObject.setup = "active";
              break;
            }
            case "server": {
              this._mediaObject.setup = "passive";
              break;
            }
            case "auto": {
              this._mediaObject.setup = "actpass";
              break;
            }
          }
        }
        resume() {
          this._mediaObject.direction = "recvonly";
        }
        muxSimulcastStreams(encodings) {
          if (!this._mediaObject.simulcast?.list1) {
            return;
          }
          const layers = {};
          for (const encoding of encodings) {
            if (encoding.rid) {
              layers[encoding.rid] = encoding;
            }
          }
          const raw = this._mediaObject.simulcast.list1;
          const simulcastStreams = sdpTransform.parseSimulcastStreamList(raw);
          for (const simulcastStream of simulcastStreams) {
            for (const simulcastFormat of simulcastStream) {
              simulcastFormat.paused = !layers[simulcastFormat.scid]?.active;
            }
          }
          this._mediaObject.simulcast.list1 = simulcastStreams.map((simulcastFormats) => simulcastFormats.map((f) => `${f.paused ? "~" : ""}${f.scid}`).join(",")).join(";");
        }
      };
      exports.AnswerMediaSection = AnswerMediaSection;
      var OfferMediaSection = class extends MediaSection {
        constructor({ iceParameters, iceCandidates, dtlsParameters, sctpParameters, plainRtpParameters, planB = false, mid, kind, offerRtpParameters, streamId, trackId, oldDataChannelSpec = false }) {
          super({ iceParameters, iceCandidates, dtlsParameters, planB });
          this._mediaObject.mid = String(mid);
          this._mediaObject.type = kind;
          if (!plainRtpParameters) {
            this._mediaObject.connection = { ip: "127.0.0.1", version: 4 };
            if (!sctpParameters) {
              this._mediaObject.protocol = "UDP/TLS/RTP/SAVPF";
            } else {
              this._mediaObject.protocol = "UDP/DTLS/SCTP";
            }
            this._mediaObject.port = 7;
          } else {
            this._mediaObject.connection = {
              ip: plainRtpParameters.ip,
              version: plainRtpParameters.ipVersion
            };
            this._mediaObject.protocol = "RTP/AVP";
            this._mediaObject.port = plainRtpParameters.port;
          }
          switch (kind) {
            case "audio":
            case "video": {
              this._mediaObject.direction = "sendonly";
              this._mediaObject.rtp = [];
              this._mediaObject.rtcpFb = [];
              this._mediaObject.fmtp = [];
              if (!this._planB) {
                this._mediaObject.msid = `${streamId ?? "-"} ${trackId}`;
              }
              for (const codec of offerRtpParameters.codecs) {
                const rtp = {
                  payload: codec.payloadType,
                  codec: getCodecName(codec),
                  rate: codec.clockRate
                };
                if (codec.channels > 1) {
                  rtp.encoding = codec.channels;
                }
                this._mediaObject.rtp.push(rtp);
                const fmtp = {
                  payload: codec.payloadType,
                  config: ""
                };
                for (const key of Object.keys(codec.parameters)) {
                  if (fmtp.config) {
                    fmtp.config += ";";
                  }
                  fmtp.config += `${key}=${codec.parameters[key]}`;
                }
                if (fmtp.config) {
                  this._mediaObject.fmtp.push(fmtp);
                }
                for (const fb of codec.rtcpFeedback) {
                  this._mediaObject.rtcpFb.push({
                    payload: codec.payloadType,
                    type: fb.type,
                    subtype: fb.parameter
                  });
                }
              }
              this._mediaObject.payloads = offerRtpParameters.codecs.map((codec) => codec.payloadType).join(" ");
              this._mediaObject.ext = [];
              for (const ext of offerRtpParameters.headerExtensions) {
                this._mediaObject.ext.push({
                  uri: ext.uri,
                  value: ext.id
                });
              }
              this._mediaObject.rtcpMux = "rtcp-mux";
              this._mediaObject.rtcpRsize = "rtcp-rsize";
              const encoding = offerRtpParameters.encodings[0];
              const ssrc = encoding.ssrc;
              const rtxSsrc = encoding.rtx?.ssrc;
              this._mediaObject.ssrcs = [];
              this._mediaObject.ssrcGroups = [];
              if (offerRtpParameters.rtcp.cname) {
                this._mediaObject.ssrcs.push({
                  id: ssrc,
                  attribute: "cname",
                  value: offerRtpParameters.rtcp.cname
                });
              }
              if (this._planB) {
                this._mediaObject.ssrcs.push({
                  id: ssrc,
                  attribute: "msid",
                  value: `${streamId ?? "-"} ${trackId}`
                });
              }
              if (rtxSsrc) {
                if (offerRtpParameters.rtcp.cname) {
                  this._mediaObject.ssrcs.push({
                    id: rtxSsrc,
                    attribute: "cname",
                    value: offerRtpParameters.rtcp.cname
                  });
                }
                if (this._planB) {
                  this._mediaObject.ssrcs.push({
                    id: rtxSsrc,
                    attribute: "msid",
                    value: `${streamId ?? "-"} ${trackId}`
                  });
                }
                this._mediaObject.ssrcGroups.push({
                  semantics: "FID",
                  ssrcs: `${ssrc} ${rtxSsrc}`
                });
              }
              break;
            }
            case "application": {
              if (!oldDataChannelSpec) {
                this._mediaObject.payloads = "webrtc-datachannel";
                this._mediaObject.sctpPort = sctpParameters.port;
                this._mediaObject.maxMessageSize = sctpParameters.maxMessageSize;
              } else {
                this._mediaObject.payloads = sctpParameters.port;
                this._mediaObject.sctpmap = {
                  app: "webrtc-datachannel",
                  sctpmapNumber: sctpParameters.port,
                  maxMessageSize: sctpParameters.maxMessageSize
                };
              }
              break;
            }
          }
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        setDtlsRole(role) {
          this._mediaObject.setup = "actpass";
        }
        resume() {
          this._mediaObject.direction = "sendonly";
        }
        planBReceive({ offerRtpParameters, streamId, trackId }) {
          const encoding = offerRtpParameters.encodings[0];
          const ssrc = encoding.ssrc;
          const rtxSsrc = encoding.rtx?.ssrc;
          const payloads = this._mediaObject.payloads.split(" ");
          for (const codec of offerRtpParameters.codecs) {
            if (payloads.includes(String(codec.payloadType))) {
              continue;
            }
            const rtp = {
              payload: codec.payloadType,
              codec: getCodecName(codec),
              rate: codec.clockRate
            };
            if (codec.channels > 1) {
              rtp.encoding = codec.channels;
            }
            this._mediaObject.rtp.push(rtp);
            const fmtp = {
              payload: codec.payloadType,
              config: ""
            };
            for (const key of Object.keys(codec.parameters)) {
              if (fmtp.config) {
                fmtp.config += ";";
              }
              fmtp.config += `${key}=${codec.parameters[key]}`;
            }
            if (fmtp.config) {
              this._mediaObject.fmtp.push(fmtp);
            }
            for (const fb of codec.rtcpFeedback) {
              this._mediaObject.rtcpFb.push({
                payload: codec.payloadType,
                type: fb.type,
                subtype: fb.parameter
              });
            }
          }
          this._mediaObject.payloads += ` ${offerRtpParameters.codecs.filter((codec) => !this._mediaObject.payloads.includes(codec.payloadType)).map((codec) => codec.payloadType).join(" ")}`;
          this._mediaObject.payloads = this._mediaObject.payloads.trim();
          if (offerRtpParameters.rtcp.cname) {
            this._mediaObject.ssrcs.push({
              id: ssrc,
              attribute: "cname",
              value: offerRtpParameters.rtcp.cname
            });
          }
          this._mediaObject.ssrcs.push({
            id: ssrc,
            attribute: "msid",
            value: `${streamId ?? "-"} ${trackId}`
          });
          if (rtxSsrc) {
            if (offerRtpParameters.rtcp.cname) {
              this._mediaObject.ssrcs.push({
                id: rtxSsrc,
                attribute: "cname",
                value: offerRtpParameters.rtcp.cname
              });
            }
            this._mediaObject.ssrcs.push({
              id: rtxSsrc,
              attribute: "msid",
              value: `${streamId ?? "-"} ${trackId}`
            });
            this._mediaObject.ssrcGroups.push({
              semantics: "FID",
              ssrcs: `${ssrc} ${rtxSsrc}`
            });
          }
        }
        planBStopReceiving({ offerRtpParameters }) {
          const encoding = offerRtpParameters.encodings[0];
          const ssrc = encoding.ssrc;
          const rtxSsrc = encoding.rtx?.ssrc;
          this._mediaObject.ssrcs = this._mediaObject.ssrcs.filter((s) => s.id !== ssrc && s.id !== rtxSsrc);
          if (rtxSsrc) {
            this._mediaObject.ssrcGroups = this._mediaObject.ssrcGroups.filter((group) => group.ssrcs !== `${ssrc} ${rtxSsrc}`);
          }
        }
      };
      exports.OfferMediaSection = OfferMediaSection;
      function getCodecName(codec) {
        const MimeTypeRegex = new RegExp("^(audio|video)/(.+)", "i");
        const mimeTypeMatch = MimeTypeRegex.exec(codec.mimeType);
        if (!mimeTypeMatch) {
          throw new TypeError("invalid codec.mimeType");
        }
        return mimeTypeMatch[2];
      }
    }
  });

  // ../../node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js
  var require_RemoteSdp = __commonJS({
    "../../node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js"(exports) {
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.RemoteSdp = void 0;
      var sdpTransform = __importStar(require_lib3());
      var Logger_1 = require_Logger();
      var MediaSection_1 = require_MediaSection();
      var logger13 = new Logger_1.Logger("RemoteSdp");
      var RemoteSdp = class {
        constructor({ iceParameters, iceCandidates, dtlsParameters, sctpParameters, plainRtpParameters, planB = false }) {
          this._mediaSections = [];
          this._midToIndex = /* @__PURE__ */ new Map();
          this._iceParameters = iceParameters;
          this._iceCandidates = iceCandidates;
          this._dtlsParameters = dtlsParameters;
          this._sctpParameters = sctpParameters;
          this._plainRtpParameters = plainRtpParameters;
          this._planB = planB;
          this._sdpObject = {
            version: 0,
            origin: {
              address: "0.0.0.0",
              ipVer: 4,
              netType: "IN",
              sessionId: 1e4,
              sessionVersion: 0,
              username: "mediasoup-client"
            },
            name: "-",
            timing: { start: 0, stop: 0 },
            media: []
          };
          if (iceParameters?.iceLite) {
            this._sdpObject.icelite = "ice-lite";
          }
          if (dtlsParameters) {
            this._sdpObject.msidSemantic = { semantic: "WMS", token: "*" };
            const numFingerprints = this._dtlsParameters.fingerprints.length;
            this._sdpObject.fingerprint = {
              type: dtlsParameters.fingerprints[numFingerprints - 1].algorithm,
              hash: dtlsParameters.fingerprints[numFingerprints - 1].value
            };
            this._sdpObject.groups = [{ type: "BUNDLE", mids: "" }];
          }
          if (plainRtpParameters) {
            this._sdpObject.origin.address = plainRtpParameters.ip;
            this._sdpObject.origin.ipVer = plainRtpParameters.ipVersion;
          }
        }
        updateIceParameters(iceParameters) {
          logger13.debug("updateIceParameters() [iceParameters:%o]", iceParameters);
          this._iceParameters = iceParameters;
          this._sdpObject.icelite = iceParameters.iceLite ? "ice-lite" : void 0;
          for (const mediaSection of this._mediaSections) {
            mediaSection.setIceParameters(iceParameters);
          }
        }
        updateDtlsRole(role) {
          logger13.debug("updateDtlsRole() [role:%s]", role);
          this._dtlsParameters.role = role;
          for (const mediaSection of this._mediaSections) {
            mediaSection.setDtlsRole(role);
          }
        }
        getNextMediaSectionIdx() {
          for (let idx = 0; idx < this._mediaSections.length; ++idx) {
            const mediaSection = this._mediaSections[idx];
            if (mediaSection.closed) {
              return { idx, reuseMid: mediaSection.mid };
            }
          }
          return { idx: this._mediaSections.length };
        }
        send({ offerMediaObject, reuseMid, offerRtpParameters, answerRtpParameters, codecOptions, extmapAllowMixed = false }) {
          const mediaSection = new MediaSection_1.AnswerMediaSection({
            iceParameters: this._iceParameters,
            iceCandidates: this._iceCandidates,
            dtlsParameters: this._dtlsParameters,
            plainRtpParameters: this._plainRtpParameters,
            planB: this._planB,
            offerMediaObject,
            offerRtpParameters,
            answerRtpParameters,
            codecOptions,
            extmapAllowMixed
          });
          if (reuseMid) {
            this._replaceMediaSection(mediaSection, reuseMid);
          } else if (!this._midToIndex.has(mediaSection.mid)) {
            this._addMediaSection(mediaSection);
          } else {
            this._replaceMediaSection(mediaSection);
          }
        }
        receive({ mid, kind, offerRtpParameters, streamId, trackId }) {
          const idx = this._midToIndex.get(mid);
          let mediaSection;
          if (idx !== void 0) {
            mediaSection = this._mediaSections[idx];
          }
          if (!mediaSection) {
            mediaSection = new MediaSection_1.OfferMediaSection({
              iceParameters: this._iceParameters,
              iceCandidates: this._iceCandidates,
              dtlsParameters: this._dtlsParameters,
              plainRtpParameters: this._plainRtpParameters,
              planB: this._planB,
              mid,
              kind,
              offerRtpParameters,
              streamId,
              trackId
            });
            const oldMediaSection = this._mediaSections.find((m) => m.closed);
            if (oldMediaSection) {
              this._replaceMediaSection(mediaSection, oldMediaSection.mid);
            } else {
              this._addMediaSection(mediaSection);
            }
          } else {
            mediaSection.planBReceive({ offerRtpParameters, streamId, trackId });
            this._replaceMediaSection(mediaSection);
          }
        }
        pauseMediaSection(mid) {
          const mediaSection = this._findMediaSection(mid);
          mediaSection.pause();
        }
        resumeSendingMediaSection(mid) {
          const mediaSection = this._findMediaSection(mid);
          mediaSection.resume();
        }
        resumeReceivingMediaSection(mid) {
          const mediaSection = this._findMediaSection(mid);
          mediaSection.resume();
        }
        disableMediaSection(mid) {
          const mediaSection = this._findMediaSection(mid);
          mediaSection.disable();
        }
        /**
         * Closes media section. Returns true if the given MID corresponds to a m
         * section that has been indeed closed. False otherwise.
         *
         * NOTE: Closing the first m section is a pain since it invalidates the bundled
         * transport, so instead closing it we just disable it.
         */
        closeMediaSection(mid) {
          const mediaSection = this._findMediaSection(mid);
          if (mid === this._firstMid) {
            logger13.debug("closeMediaSection() | cannot close first media section, disabling it instead [mid:%s]", mid);
            this.disableMediaSection(mid);
            return false;
          }
          mediaSection.close();
          this._regenerateBundleMids();
          return true;
        }
        muxMediaSectionSimulcast(mid, encodings) {
          const mediaSection = this._findMediaSection(mid);
          mediaSection.muxSimulcastStreams(encodings);
          this._replaceMediaSection(mediaSection);
        }
        planBStopReceiving({ mid, offerRtpParameters }) {
          const mediaSection = this._findMediaSection(mid);
          mediaSection.planBStopReceiving({ offerRtpParameters });
          this._replaceMediaSection(mediaSection);
        }
        sendSctpAssociation({ offerMediaObject }) {
          const mediaSection = new MediaSection_1.AnswerMediaSection({
            iceParameters: this._iceParameters,
            iceCandidates: this._iceCandidates,
            dtlsParameters: this._dtlsParameters,
            sctpParameters: this._sctpParameters,
            plainRtpParameters: this._plainRtpParameters,
            offerMediaObject
          });
          this._addMediaSection(mediaSection);
        }
        receiveSctpAssociation({ oldDataChannelSpec = false } = {}) {
          const mediaSection = new MediaSection_1.OfferMediaSection({
            iceParameters: this._iceParameters,
            iceCandidates: this._iceCandidates,
            dtlsParameters: this._dtlsParameters,
            sctpParameters: this._sctpParameters,
            plainRtpParameters: this._plainRtpParameters,
            mid: "datachannel",
            kind: "application",
            oldDataChannelSpec
          });
          this._addMediaSection(mediaSection);
        }
        getSdp() {
          this._sdpObject.origin.sessionVersion++;
          return sdpTransform.write(this._sdpObject);
        }
        _addMediaSection(newMediaSection) {
          if (!this._firstMid) {
            this._firstMid = newMediaSection.mid;
          }
          this._mediaSections.push(newMediaSection);
          this._midToIndex.set(newMediaSection.mid, this._mediaSections.length - 1);
          this._sdpObject.media.push(newMediaSection.getObject());
          this._regenerateBundleMids();
        }
        _replaceMediaSection(newMediaSection, reuseMid) {
          if (typeof reuseMid === "string") {
            const idx = this._midToIndex.get(reuseMid);
            if (idx === void 0) {
              throw new Error(`no media section found for reuseMid '${reuseMid}'`);
            }
            const oldMediaSection = this._mediaSections[idx];
            this._mediaSections[idx] = newMediaSection;
            this._midToIndex.delete(oldMediaSection.mid);
            this._midToIndex.set(newMediaSection.mid, idx);
            this._sdpObject.media[idx] = newMediaSection.getObject();
            this._regenerateBundleMids();
          } else {
            const idx = this._midToIndex.get(newMediaSection.mid);
            if (idx === void 0) {
              throw new Error(`no media section found with mid '${newMediaSection.mid}'`);
            }
            this._mediaSections[idx] = newMediaSection;
            this._sdpObject.media[idx] = newMediaSection.getObject();
          }
        }
        _findMediaSection(mid) {
          const idx = this._midToIndex.get(mid);
          if (idx === void 0) {
            throw new Error(`no media section found with mid '${mid}'`);
          }
          return this._mediaSections[idx];
        }
        _regenerateBundleMids() {
          if (!this._dtlsParameters) {
            return;
          }
          this._sdpObject.groups[0].mids = this._mediaSections.filter((mediaSection) => !mediaSection.closed).map((mediaSection) => mediaSection.mid).join(" ");
        }
      };
      exports.RemoteSdp = RemoteSdp;
    }
  });

  // ../../node_modules/mediasoup-client/lib/scalabilityModes.js
  var require_scalabilityModes = __commonJS({
    "../../node_modules/mediasoup-client/lib/scalabilityModes.js"(exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.parse = parse;
      var ScalabilityModeRegex = new RegExp("^[LS]([1-9]\\d{0,1})T([1-9]\\d{0,1})");
      function parse(scalabilityMode) {
        const match = ScalabilityModeRegex.exec(scalabilityMode ?? "");
        if (match) {
          return {
            spatialLayers: Number(match[1]),
            temporalLayers: Number(match[2])
          };
        } else {
          return {
            spatialLayers: 1,
            temporalLayers: 1
          };
        }
      }
    }
  });

  // ../../node_modules/mediasoup-client/lib/handlers/Chrome111.js
  var require_Chrome111 = __commonJS({
    "../../node_modules/mediasoup-client/lib/handlers/Chrome111.js"(exports) {
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Chrome111 = void 0;
      var sdpTransform = __importStar(require_lib3());
      var Logger_1 = require_Logger();
      var utils = __importStar(require_utils());
      var ortc = __importStar(require_ortc());
      var sdpCommonUtils = __importStar(require_commonUtils());
      var sdpUnifiedPlanUtils = __importStar(require_unifiedPlanUtils());
      var ortcUtils = __importStar(require_utils2());
      var errors_1 = require_errors();
      var HandlerInterface_1 = require_HandlerInterface();
      var RemoteSdp_1 = require_RemoteSdp();
      var scalabilityModes_1 = require_scalabilityModes();
      var logger13 = new Logger_1.Logger("Chrome111");
      var NAME = "Chrome111";
      var SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };
      var Chrome111 = class _Chrome111 extends HandlerInterface_1.HandlerInterface {
        /**
         * Creates a factory function.
         */
        static createFactory() {
          return () => new _Chrome111();
        }
        constructor() {
          super();
          this._closed = false;
          this._mapMidTransceiver = /* @__PURE__ */ new Map();
          this._sendStream = new MediaStream();
          this._hasDataChannelMediaSection = false;
          this._nextSendSctpStreamId = 0;
          this._transportReady = false;
        }
        get name() {
          return NAME;
        }
        close() {
          logger13.debug("close()");
          if (this._closed) {
            return;
          }
          this._closed = true;
          if (this._pc) {
            try {
              this._pc.close();
            } catch (error) {
            }
          }
          this.emit("@close");
        }
        async getNativeRtpCapabilities() {
          logger13.debug("getNativeRtpCapabilities()");
          const pc = new RTCPeerConnection({
            iceServers: [],
            iceTransportPolicy: "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require",
            sdpSemantics: "unified-plan"
          });
          try {
            pc.addTransceiver("audio");
            pc.addTransceiver("video");
            const offer = await pc.createOffer();
            try {
              pc.close();
            } catch (error) {
            }
            const sdpObject = sdpTransform.parse(offer.sdp);
            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
              sdpObject
            });
            ortcUtils.addNackSuppportForOpus(nativeRtpCapabilities);
            return nativeRtpCapabilities;
          } catch (error) {
            try {
              pc.close();
            } catch (error2) {
            }
            throw error;
          }
        }
        async getNativeSctpCapabilities() {
          logger13.debug("getNativeSctpCapabilities()");
          return {
            numStreams: SCTP_NUM_STREAMS
          };
        }
        run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities }) {
          this.assertNotClosed();
          logger13.debug("run()");
          this._direction = direction;
          this._remoteSdp = new RemoteSdp_1.RemoteSdp({
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters
          });
          this._sendingRtpParametersByKind = {
            audio: ortc.getSendingRtpParameters("audio", extendedRtpCapabilities),
            video: ortc.getSendingRtpParameters("video", extendedRtpCapabilities)
          };
          this._sendingRemoteRtpParametersByKind = {
            audio: ortc.getSendingRemoteRtpParameters("audio", extendedRtpCapabilities),
            video: ortc.getSendingRemoteRtpParameters("video", extendedRtpCapabilities)
          };
          if (dtlsParameters.role && dtlsParameters.role !== "auto") {
            this._forcedLocalDtlsRole = dtlsParameters.role === "server" ? "client" : "server";
          }
          this._pc = new RTCPeerConnection({
            iceServers: iceServers ?? [],
            iceTransportPolicy: iceTransportPolicy ?? "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require",
            sdpSemantics: "unified-plan",
            ...additionalSettings
          }, proprietaryConstraints);
          this._pc.addEventListener("icegatheringstatechange", () => {
            this.emit("@icegatheringstatechange", this._pc.iceGatheringState);
          });
          if (this._pc.connectionState) {
            this._pc.addEventListener("connectionstatechange", () => {
              this.emit("@connectionstatechange", this._pc.connectionState);
            });
          } else {
            logger13.warn("run() | pc.connectionState not supported, using pc.iceConnectionState");
            this._pc.addEventListener("iceconnectionstatechange", () => {
              switch (this._pc.iceConnectionState) {
                case "checking": {
                  this.emit("@connectionstatechange", "connecting");
                  break;
                }
                case "connected":
                case "completed": {
                  this.emit("@connectionstatechange", "connected");
                  break;
                }
                case "failed": {
                  this.emit("@connectionstatechange", "failed");
                  break;
                }
                case "disconnected": {
                  this.emit("@connectionstatechange", "disconnected");
                  break;
                }
                case "closed": {
                  this.emit("@connectionstatechange", "closed");
                  break;
                }
              }
            });
          }
        }
        async updateIceServers(iceServers) {
          this.assertNotClosed();
          logger13.debug("updateIceServers()");
          const configuration = this._pc.getConfiguration();
          configuration.iceServers = iceServers;
          this._pc.setConfiguration(configuration);
        }
        async restartIce(iceParameters) {
          this.assertNotClosed();
          logger13.debug("restartIce()");
          this._remoteSdp.updateIceParameters(iceParameters);
          if (!this._transportReady) {
            return;
          }
          if (this._direction === "send") {
            const offer = await this._pc.createOffer({ iceRestart: true });
            logger13.debug("restartIce() | calling pc.setLocalDescription() [offer:%o]", offer);
            await this._pc.setLocalDescription(offer);
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger13.debug("restartIce() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setRemoteDescription(answer);
          } else {
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger13.debug("restartIce() | calling pc.setRemoteDescription() [offer:%o]", offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger13.debug("restartIce() | calling pc.setLocalDescription() [answer:%o]", answer);
            await this._pc.setLocalDescription(answer);
          }
        }
        async getTransportStats() {
          this.assertNotClosed();
          return this._pc.getStats();
        }
        async send({ track, encodings, codecOptions, codec, onRtpSender }) {
          this.assertNotClosed();
          this.assertSendDirection();
          logger13.debug("send() [kind:%s, track.id:%s]", track.kind, track.id);
          if (encodings && encodings.length > 1) {
            let maxTemporalLayers = 1;
            for (const encoding of encodings) {
              const temporalLayers = encoding.scalabilityMode ? (0, scalabilityModes_1.parse)(encoding.scalabilityMode).temporalLayers : 3;
              if (temporalLayers > maxTemporalLayers) {
                maxTemporalLayers = temporalLayers;
              }
            }
            encodings.forEach((encoding, idx) => {
              encoding.rid = `r${idx}`;
              encoding.scalabilityMode = `L1T${maxTemporalLayers}`;
            });
          }
          const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);
          sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);
          const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);
          sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);
          const mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();
          const transceiver = this._pc.addTransceiver(track, {
            direction: "sendonly",
            streams: [this._sendStream],
            sendEncodings: encodings
          });
          if (onRtpSender) {
            onRtpSender(transceiver.sender);
          }
          const offer = await this._pc.createOffer();
          let localSdpObject = sdpTransform.parse(offer.sdp);
          if (!this._transportReady) {
            await this.setupTransport({
              localDtlsRole: this._forcedLocalDtlsRole ?? "client",
              localSdpObject
            });
          }
          logger13.debug("send() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const localId = transceiver.mid;
          sendingRtpParameters.mid = localId;
          localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
          const offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
          sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
            offerMediaObject
          });
          if (!encodings) {
            sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({
              offerMediaObject
            });
          } else if (encodings.length === 1) {
            const newEncodings = sdpUnifiedPlanUtils.getRtpEncodings({
              offerMediaObject
            });
            Object.assign(newEncodings[0], encodings[0]);
            sendingRtpParameters.encodings = newEncodings;
          } else {
            sendingRtpParameters.encodings = encodings;
          }
          this._remoteSdp.send({
            offerMediaObject,
            reuseMid: mediaSectionIdx.reuseMid,
            offerRtpParameters: sendingRtpParameters,
            answerRtpParameters: sendingRemoteRtpParameters,
            codecOptions,
            extmapAllowMixed: true
          });
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger13.debug("send() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
          this._mapMidTransceiver.set(localId, transceiver);
          return {
            localId,
            rtpParameters: sendingRtpParameters,
            rtpSender: transceiver.sender
          };
        }
        async stopSending(localId) {
          this.assertSendDirection();
          logger13.debug("stopSending() [localId:%s]", localId);
          if (this._closed) {
            return;
          }
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          void transceiver.sender.replaceTrack(null);
          this._pc.removeTrack(transceiver.sender);
          const mediaSectionClosed = this._remoteSdp.closeMediaSection(transceiver.mid);
          if (mediaSectionClosed) {
            try {
              transceiver.stop();
            } catch (error) {
            }
          }
          const offer = await this._pc.createOffer();
          logger13.debug("stopSending() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger13.debug("stopSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
          this._mapMidTransceiver.delete(localId);
        }
        async pauseSending(localId) {
          this.assertNotClosed();
          this.assertSendDirection();
          logger13.debug("pauseSending() [localId:%s]", localId);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          transceiver.direction = "inactive";
          this._remoteSdp.pauseMediaSection(localId);
          const offer = await this._pc.createOffer();
          logger13.debug("pauseSending() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger13.debug("pauseSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
        }
        async resumeSending(localId) {
          this.assertNotClosed();
          this.assertSendDirection();
          logger13.debug("resumeSending() [localId:%s]", localId);
          const transceiver = this._mapMidTransceiver.get(localId);
          this._remoteSdp.resumeSendingMediaSection(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          transceiver.direction = "sendonly";
          const offer = await this._pc.createOffer();
          logger13.debug("resumeSending() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger13.debug("resumeSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
        }
        async replaceTrack(localId, track) {
          this.assertNotClosed();
          this.assertSendDirection();
          if (track) {
            logger13.debug("replaceTrack() [localId:%s, track.id:%s]", localId, track.id);
          } else {
            logger13.debug("replaceTrack() [localId:%s, no track]", localId);
          }
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          await transceiver.sender.replaceTrack(track);
        }
        async setMaxSpatialLayer(localId, spatialLayer) {
          this.assertNotClosed();
          this.assertSendDirection();
          logger13.debug("setMaxSpatialLayer() [localId:%s, spatialLayer:%s]", localId, spatialLayer);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          const parameters = transceiver.sender.getParameters();
          parameters.encodings.forEach((encoding, idx) => {
            if (idx <= spatialLayer) {
              encoding.active = true;
            } else {
              encoding.active = false;
            }
          });
          await transceiver.sender.setParameters(parameters);
          this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
          const offer = await this._pc.createOffer();
          logger13.debug("setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger13.debug("setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
        }
        async setRtpEncodingParameters(localId, params) {
          this.assertNotClosed();
          this.assertSendDirection();
          logger13.debug("setRtpEncodingParameters() [localId:%s, params:%o]", localId, params);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          const parameters = transceiver.sender.getParameters();
          parameters.encodings.forEach((encoding, idx) => {
            parameters.encodings[idx] = { ...encoding, ...params };
          });
          await transceiver.sender.setParameters(parameters);
          this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
          const offer = await this._pc.createOffer();
          logger13.debug("setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger13.debug("setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
        }
        async getSenderStats(localId) {
          this.assertNotClosed();
          this.assertSendDirection();
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          return transceiver.sender.getStats();
        }
        async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol }) {
          this.assertNotClosed();
          this.assertSendDirection();
          const options = {
            negotiated: true,
            id: this._nextSendSctpStreamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol
          };
          logger13.debug("sendDataChannel() [options:%o]", options);
          const dataChannel = this._pc.createDataChannel(label, options);
          this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
          if (!this._hasDataChannelMediaSection) {
            const offer = await this._pc.createOffer();
            const localSdpObject = sdpTransform.parse(offer.sdp);
            const offerMediaObject = localSdpObject.media.find((m) => m.type === "application");
            if (!this._transportReady) {
              await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                localSdpObject
              });
            }
            logger13.debug("sendDataChannel() | calling pc.setLocalDescription() [offer:%o]", offer);
            await this._pc.setLocalDescription(offer);
            this._remoteSdp.sendSctpAssociation({ offerMediaObject });
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger13.debug("sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setRemoteDescription(answer);
            this._hasDataChannelMediaSection = true;
          }
          const sctpStreamParameters = {
            streamId: options.id,
            ordered: options.ordered,
            maxPacketLifeTime: options.maxPacketLifeTime,
            maxRetransmits: options.maxRetransmits
          };
          return { dataChannel, sctpStreamParameters };
        }
        async receive(optionsList) {
          this.assertNotClosed();
          this.assertRecvDirection();
          const results = [];
          const mapLocalId = /* @__PURE__ */ new Map();
          for (const options of optionsList) {
            const { trackId, kind, rtpParameters, streamId } = options;
            logger13.debug("receive() [trackId:%s, kind:%s]", trackId, kind);
            const localId = rtpParameters.mid ?? String(this._mapMidTransceiver.size);
            mapLocalId.set(trackId, localId);
            this._remoteSdp.receive({
              mid: localId,
              kind,
              offerRtpParameters: rtpParameters,
              streamId: streamId ?? rtpParameters.rtcp.cname,
              trackId
            });
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger13.debug("receive() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          for (const options of optionsList) {
            const { trackId, onRtpReceiver } = options;
            if (onRtpReceiver) {
              const localId = mapLocalId.get(trackId);
              const transceiver = this._pc.getTransceivers().find((t) => t.mid === localId);
              if (!transceiver) {
                throw new Error("transceiver not found");
              }
              onRtpReceiver(transceiver.receiver);
            }
          }
          let answer = await this._pc.createAnswer();
          const localSdpObject = sdpTransform.parse(answer.sdp);
          for (const options of optionsList) {
            const { trackId, rtpParameters } = options;
            const localId = mapLocalId.get(trackId);
            const answerMediaObject = localSdpObject.media.find((m) => String(m.mid) === localId);
            sdpCommonUtils.applyCodecParameters({
              offerRtpParameters: rtpParameters,
              answerMediaObject
            });
          }
          answer = { type: "answer", sdp: sdpTransform.write(localSdpObject) };
          if (!this._transportReady) {
            await this.setupTransport({
              localDtlsRole: this._forcedLocalDtlsRole ?? "client",
              localSdpObject
            });
          }
          logger13.debug("receive() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
          for (const options of optionsList) {
            const { trackId } = options;
            const localId = mapLocalId.get(trackId);
            const transceiver = this._pc.getTransceivers().find((t) => t.mid === localId);
            if (!transceiver) {
              throw new Error("new RTCRtpTransceiver not found");
            } else {
              this._mapMidTransceiver.set(localId, transceiver);
              results.push({
                localId,
                track: transceiver.receiver.track,
                rtpReceiver: transceiver.receiver
              });
            }
          }
          return results;
        }
        async stopReceiving(localIds) {
          this.assertRecvDirection();
          if (this._closed) {
            return;
          }
          for (const localId of localIds) {
            logger13.debug("stopReceiving() [localId:%s]", localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            this._remoteSdp.closeMediaSection(transceiver.mid);
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger13.debug("stopReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          const answer = await this._pc.createAnswer();
          logger13.debug("stopReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
          for (const localId of localIds) {
            this._mapMidTransceiver.delete(localId);
          }
        }
        async pauseReceiving(localIds) {
          this.assertNotClosed();
          this.assertRecvDirection();
          for (const localId of localIds) {
            logger13.debug("pauseReceiving() [localId:%s]", localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            transceiver.direction = "inactive";
            this._remoteSdp.pauseMediaSection(localId);
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger13.debug("pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          const answer = await this._pc.createAnswer();
          logger13.debug("pauseReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
        }
        async resumeReceiving(localIds) {
          this.assertNotClosed();
          this.assertRecvDirection();
          for (const localId of localIds) {
            logger13.debug("resumeReceiving() [localId:%s]", localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            transceiver.direction = "recvonly";
            this._remoteSdp.resumeReceivingMediaSection(localId);
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger13.debug("resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          const answer = await this._pc.createAnswer();
          logger13.debug("resumeReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
        }
        async getReceiverStats(localId) {
          this.assertNotClosed();
          this.assertRecvDirection();
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          return transceiver.receiver.getStats();
        }
        async receiveDataChannel({ sctpStreamParameters, label, protocol }) {
          this.assertNotClosed();
          this.assertRecvDirection();
          const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;
          const options = {
            negotiated: true,
            id: streamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol
          };
          logger13.debug("receiveDataChannel() [options:%o]", options);
          const dataChannel = this._pc.createDataChannel(label, options);
          if (!this._hasDataChannelMediaSection) {
            this._remoteSdp.receiveSctpAssociation();
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger13.debug("receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]", offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            if (!this._transportReady) {
              const localSdpObject = sdpTransform.parse(answer.sdp);
              await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                localSdpObject
              });
            }
            logger13.debug("receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setLocalDescription(answer);
            this._hasDataChannelMediaSection = true;
          }
          return { dataChannel };
        }
        async setupTransport({ localDtlsRole, localSdpObject }) {
          if (!localSdpObject) {
            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
          }
          const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
            sdpObject: localSdpObject
          });
          dtlsParameters.role = localDtlsRole;
          this._remoteSdp.updateDtlsRole(localDtlsRole === "client" ? "server" : "client");
          await new Promise((resolve, reject) => {
            this.safeEmit("@connect", { dtlsParameters }, resolve, reject);
          });
          this._transportReady = true;
        }
        assertNotClosed() {
          if (this._closed) {
            throw new errors_1.InvalidStateError("method called in a closed handler");
          }
        }
        assertSendDirection() {
          if (this._direction !== "send") {
            throw new Error('method can just be called for handlers with "send" direction');
          }
        }
        assertRecvDirection() {
          if (this._direction !== "recv") {
            throw new Error('method can just be called for handlers with "recv" direction');
          }
        }
      };
      exports.Chrome111 = Chrome111;
    }
  });

  // ../../node_modules/mediasoup-client/lib/handlers/Chrome74.js
  var require_Chrome74 = __commonJS({
    "../../node_modules/mediasoup-client/lib/handlers/Chrome74.js"(exports) {
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Chrome74 = void 0;
      var sdpTransform = __importStar(require_lib3());
      var Logger_1 = require_Logger();
      var utils = __importStar(require_utils());
      var ortc = __importStar(require_ortc());
      var sdpCommonUtils = __importStar(require_commonUtils());
      var sdpUnifiedPlanUtils = __importStar(require_unifiedPlanUtils());
      var ortcUtils = __importStar(require_utils2());
      var errors_1 = require_errors();
      var HandlerInterface_1 = require_HandlerInterface();
      var RemoteSdp_1 = require_RemoteSdp();
      var scalabilityModes_1 = require_scalabilityModes();
      var logger13 = new Logger_1.Logger("Chrome74");
      var NAME = "Chrome74";
      var SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };
      var Chrome74 = class _Chrome74 extends HandlerInterface_1.HandlerInterface {
        /**
         * Creates a factory function.
         */
        static createFactory() {
          return () => new _Chrome74();
        }
        constructor() {
          super();
          this._closed = false;
          this._mapMidTransceiver = /* @__PURE__ */ new Map();
          this._sendStream = new MediaStream();
          this._hasDataChannelMediaSection = false;
          this._nextSendSctpStreamId = 0;
          this._transportReady = false;
        }
        get name() {
          return NAME;
        }
        close() {
          logger13.debug("close()");
          if (this._closed) {
            return;
          }
          this._closed = true;
          if (this._pc) {
            try {
              this._pc.close();
            } catch (error) {
            }
          }
          this.emit("@close");
        }
        async getNativeRtpCapabilities() {
          logger13.debug("getNativeRtpCapabilities()");
          const pc = new RTCPeerConnection({
            iceServers: [],
            iceTransportPolicy: "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require",
            sdpSemantics: "unified-plan"
          });
          try {
            pc.addTransceiver("audio");
            pc.addTransceiver("video");
            const offer = await pc.createOffer();
            try {
              pc.close();
            } catch (error) {
            }
            const sdpObject = sdpTransform.parse(offer.sdp);
            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
              sdpObject
            });
            ortcUtils.addNackSuppportForOpus(nativeRtpCapabilities);
            return nativeRtpCapabilities;
          } catch (error) {
            try {
              pc.close();
            } catch (error2) {
            }
            throw error;
          }
        }
        async getNativeSctpCapabilities() {
          logger13.debug("getNativeSctpCapabilities()");
          return {
            numStreams: SCTP_NUM_STREAMS
          };
        }
        run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities }) {
          logger13.debug("run()");
          this._direction = direction;
          this._remoteSdp = new RemoteSdp_1.RemoteSdp({
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters
          });
          this._sendingRtpParametersByKind = {
            audio: ortc.getSendingRtpParameters("audio", extendedRtpCapabilities),
            video: ortc.getSendingRtpParameters("video", extendedRtpCapabilities)
          };
          this._sendingRemoteRtpParametersByKind = {
            audio: ortc.getSendingRemoteRtpParameters("audio", extendedRtpCapabilities),
            video: ortc.getSendingRemoteRtpParameters("video", extendedRtpCapabilities)
          };
          if (dtlsParameters.role && dtlsParameters.role !== "auto") {
            this._forcedLocalDtlsRole = dtlsParameters.role === "server" ? "client" : "server";
          }
          this._pc = new RTCPeerConnection({
            iceServers: iceServers ?? [],
            iceTransportPolicy: iceTransportPolicy ?? "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require",
            sdpSemantics: "unified-plan",
            ...additionalSettings
          }, proprietaryConstraints);
          this._pc.addEventListener("icegatheringstatechange", () => {
            this.emit("@icegatheringstatechange", this._pc.iceGatheringState);
          });
          if (this._pc.connectionState) {
            this._pc.addEventListener("connectionstatechange", () => {
              this.emit("@connectionstatechange", this._pc.connectionState);
            });
          } else {
            logger13.warn("run() | pc.connectionState not supported, using pc.iceConnectionState");
            this._pc.addEventListener("iceconnectionstatechange", () => {
              switch (this._pc.iceConnectionState) {
                case "checking": {
                  this.emit("@connectionstatechange", "connecting");
                  break;
                }
                case "connected":
                case "completed": {
                  this.emit("@connectionstatechange", "connected");
                  break;
                }
                case "failed": {
                  this.emit("@connectionstatechange", "failed");
                  break;
                }
                case "disconnected": {
                  this.emit("@connectionstatechange", "disconnected");
                  break;
                }
                case "closed": {
                  this.emit("@connectionstatechange", "closed");
                  break;
                }
              }
            });
          }
        }
        async updateIceServers(iceServers) {
          this.assertNotClosed();
          logger13.debug("updateIceServers()");
          const configuration = this._pc.getConfiguration();
          configuration.iceServers = iceServers;
          this._pc.setConfiguration(configuration);
        }
        async restartIce(iceParameters) {
          this.assertNotClosed();
          logger13.debug("restartIce()");
          this._remoteSdp.updateIceParameters(iceParameters);
          if (!this._transportReady) {
            return;
          }
          if (this._direction === "send") {
            const offer = await this._pc.createOffer({ iceRestart: true });
            logger13.debug("restartIce() | calling pc.setLocalDescription() [offer:%o]", offer);
            await this._pc.setLocalDescription(offer);
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger13.debug("restartIce() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setRemoteDescription(answer);
          } else {
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger13.debug("restartIce() | calling pc.setRemoteDescription() [offer:%o]", offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger13.debug("restartIce() | calling pc.setLocalDescription() [answer:%o]", answer);
            await this._pc.setLocalDescription(answer);
          }
        }
        async getTransportStats() {
          this.assertNotClosed();
          return this._pc.getStats();
        }
        async send({ track, encodings, codecOptions, codec }) {
          this.assertNotClosed();
          this.assertSendDirection();
          logger13.debug("send() [kind:%s, track.id:%s]", track.kind, track.id);
          if (encodings && encodings.length > 1) {
            encodings.forEach((encoding, idx) => {
              encoding.rid = `r${idx}`;
            });
          }
          const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);
          sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);
          const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);
          sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);
          const mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();
          const transceiver = this._pc.addTransceiver(track, {
            direction: "sendonly",
            streams: [this._sendStream],
            sendEncodings: encodings
          });
          let offer = await this._pc.createOffer();
          let localSdpObject = sdpTransform.parse(offer.sdp);
          let offerMediaObject;
          if (!this._transportReady) {
            await this.setupTransport({
              localDtlsRole: this._forcedLocalDtlsRole ?? "client",
              localSdpObject
            });
          }
          let hackVp9Svc = false;
          const layers = (0, scalabilityModes_1.parse)((encodings ?? [{}])[0].scalabilityMode);
          if (encodings && encodings.length === 1 && layers.spatialLayers > 1 && sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/vp9") {
            logger13.debug("send() | enabling legacy simulcast for VP9 SVC");
            hackVp9Svc = true;
            localSdpObject = sdpTransform.parse(offer.sdp);
            offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
            sdpUnifiedPlanUtils.addLegacySimulcast({
              offerMediaObject,
              numStreams: layers.spatialLayers
            });
            offer = { type: "offer", sdp: sdpTransform.write(localSdpObject) };
          }
          logger13.debug("send() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const localId = transceiver.mid;
          sendingRtpParameters.mid = localId;
          localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
          offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
          sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
            offerMediaObject
          });
          if (!encodings) {
            sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({
              offerMediaObject
            });
          } else if (encodings.length === 1) {
            let newEncodings = sdpUnifiedPlanUtils.getRtpEncodings({
              offerMediaObject
            });
            Object.assign(newEncodings[0], encodings[0]);
            if (hackVp9Svc) {
              newEncodings = [newEncodings[0]];
            }
            sendingRtpParameters.encodings = newEncodings;
          } else {
            sendingRtpParameters.encodings = encodings;
          }
          if (sendingRtpParameters.encodings.length > 1 && (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/vp8" || sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/h264")) {
            for (const encoding of sendingRtpParameters.encodings) {
              if (encoding.scalabilityMode) {
                encoding.scalabilityMode = `L1T${layers.temporalLayers}`;
              } else {
                encoding.scalabilityMode = "L1T3";
              }
            }
          }
          this._remoteSdp.send({
            offerMediaObject,
            reuseMid: mediaSectionIdx.reuseMid,
            offerRtpParameters: sendingRtpParameters,
            answerRtpParameters: sendingRemoteRtpParameters,
            codecOptions,
            extmapAllowMixed: true
          });
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger13.debug("send() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
          this._mapMidTransceiver.set(localId, transceiver);
          return {
            localId,
            rtpParameters: sendingRtpParameters,
            rtpSender: transceiver.sender
          };
        }
        async stopSending(localId) {
          this.assertSendDirection();
          logger13.debug("stopSending() [localId:%s]", localId);
          if (this._closed) {
            return;
          }
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          void transceiver.sender.replaceTrack(null);
          this._pc.removeTrack(transceiver.sender);
          const mediaSectionClosed = this._remoteSdp.closeMediaSection(transceiver.mid);
          if (mediaSectionClosed) {
            try {
              transceiver.stop();
            } catch (error) {
            }
          }
          const offer = await this._pc.createOffer();
          logger13.debug("stopSending() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger13.debug("stopSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
          this._mapMidTransceiver.delete(localId);
        }
        async pauseSending(localId) {
          this.assertNotClosed();
          this.assertSendDirection();
          logger13.debug("pauseSending() [localId:%s]", localId);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          transceiver.direction = "inactive";
          this._remoteSdp.pauseMediaSection(localId);
          const offer = await this._pc.createOffer();
          logger13.debug("pauseSending() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger13.debug("pauseSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
        }
        async resumeSending(localId) {
          this.assertNotClosed();
          this.assertSendDirection();
          logger13.debug("resumeSending() [localId:%s]", localId);
          const transceiver = this._mapMidTransceiver.get(localId);
          this._remoteSdp.resumeSendingMediaSection(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          transceiver.direction = "sendonly";
          const offer = await this._pc.createOffer();
          logger13.debug("resumeSending() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger13.debug("resumeSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
        }
        async replaceTrack(localId, track) {
          this.assertNotClosed();
          this.assertSendDirection();
          if (track) {
            logger13.debug("replaceTrack() [localId:%s, track.id:%s]", localId, track.id);
          } else {
            logger13.debug("replaceTrack() [localId:%s, no track]", localId);
          }
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          await transceiver.sender.replaceTrack(track);
        }
        async setMaxSpatialLayer(localId, spatialLayer) {
          this.assertNotClosed();
          this.assertSendDirection();
          logger13.debug("setMaxSpatialLayer() [localId:%s, spatialLayer:%s]", localId, spatialLayer);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          const parameters = transceiver.sender.getParameters();
          parameters.encodings.forEach((encoding, idx) => {
            if (idx <= spatialLayer) {
              encoding.active = true;
            } else {
              encoding.active = false;
            }
          });
          await transceiver.sender.setParameters(parameters);
          this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
          const offer = await this._pc.createOffer();
          logger13.debug("setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger13.debug("setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
        }
        async setRtpEncodingParameters(localId, params) {
          this.assertNotClosed();
          this.assertSendDirection();
          logger13.debug("setRtpEncodingParameters() [localId:%s, params:%o]", localId, params);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          const parameters = transceiver.sender.getParameters();
          parameters.encodings.forEach((encoding, idx) => {
            parameters.encodings[idx] = { ...encoding, ...params };
          });
          await transceiver.sender.setParameters(parameters);
          this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
          const offer = await this._pc.createOffer();
          logger13.debug("setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger13.debug("setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
        }
        async getSenderStats(localId) {
          this.assertNotClosed();
          this.assertSendDirection();
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          return transceiver.sender.getStats();
        }
        async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol }) {
          this.assertNotClosed();
          this.assertSendDirection();
          const options = {
            negotiated: true,
            id: this._nextSendSctpStreamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol
          };
          logger13.debug("sendDataChannel() [options:%o]", options);
          const dataChannel = this._pc.createDataChannel(label, options);
          this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
          if (!this._hasDataChannelMediaSection) {
            const offer = await this._pc.createOffer();
            const localSdpObject = sdpTransform.parse(offer.sdp);
            const offerMediaObject = localSdpObject.media.find((m) => m.type === "application");
            if (!this._transportReady) {
              await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                localSdpObject
              });
            }
            logger13.debug("sendDataChannel() | calling pc.setLocalDescription() [offer:%o]", offer);
            await this._pc.setLocalDescription(offer);
            this._remoteSdp.sendSctpAssociation({ offerMediaObject });
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger13.debug("sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setRemoteDescription(answer);
            this._hasDataChannelMediaSection = true;
          }
          const sctpStreamParameters = {
            streamId: options.id,
            ordered: options.ordered,
            maxPacketLifeTime: options.maxPacketLifeTime,
            maxRetransmits: options.maxRetransmits
          };
          return { dataChannel, sctpStreamParameters };
        }
        async receive(optionsList) {
          this.assertNotClosed();
          this.assertRecvDirection();
          const results = [];
          const mapLocalId = /* @__PURE__ */ new Map();
          for (const options of optionsList) {
            const { trackId, kind, rtpParameters, streamId } = options;
            logger13.debug("receive() [trackId:%s, kind:%s]", trackId, kind);
            const localId = rtpParameters.mid ?? String(this._mapMidTransceiver.size);
            mapLocalId.set(trackId, localId);
            this._remoteSdp.receive({
              mid: localId,
              kind,
              offerRtpParameters: rtpParameters,
              streamId: streamId ?? rtpParameters.rtcp.cname,
              trackId
            });
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger13.debug("receive() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          let answer = await this._pc.createAnswer();
          const localSdpObject = sdpTransform.parse(answer.sdp);
          for (const options of optionsList) {
            const { trackId, rtpParameters } = options;
            const localId = mapLocalId.get(trackId);
            const answerMediaObject = localSdpObject.media.find((m) => String(m.mid) === localId);
            sdpCommonUtils.applyCodecParameters({
              offerRtpParameters: rtpParameters,
              answerMediaObject
            });
          }
          answer = { type: "answer", sdp: sdpTransform.write(localSdpObject) };
          if (!this._transportReady) {
            await this.setupTransport({
              localDtlsRole: this._forcedLocalDtlsRole ?? "client",
              localSdpObject
            });
          }
          logger13.debug("receive() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
          for (const options of optionsList) {
            const { trackId } = options;
            const localId = mapLocalId.get(trackId);
            const transceiver = this._pc.getTransceivers().find((t) => t.mid === localId);
            if (!transceiver) {
              throw new Error("new RTCRtpTransceiver not found");
            } else {
              this._mapMidTransceiver.set(localId, transceiver);
              results.push({
                localId,
                track: transceiver.receiver.track,
                rtpReceiver: transceiver.receiver
              });
            }
          }
          return results;
        }
        async stopReceiving(localIds) {
          this.assertRecvDirection();
          if (this._closed) {
            return;
          }
          for (const localId of localIds) {
            logger13.debug("stopReceiving() [localId:%s]", localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            this._remoteSdp.closeMediaSection(transceiver.mid);
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger13.debug("stopReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          const answer = await this._pc.createAnswer();
          logger13.debug("stopReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
          for (const localId of localIds) {
            this._mapMidTransceiver.delete(localId);
          }
        }
        async pauseReceiving(localIds) {
          this.assertNotClosed();
          this.assertRecvDirection();
          for (const localId of localIds) {
            logger13.debug("pauseReceiving() [localId:%s]", localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            transceiver.direction = "inactive";
            this._remoteSdp.pauseMediaSection(localId);
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger13.debug("pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          const answer = await this._pc.createAnswer();
          logger13.debug("pauseReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
        }
        async resumeReceiving(localIds) {
          this.assertNotClosed();
          this.assertRecvDirection();
          for (const localId of localIds) {
            logger13.debug("resumeReceiving() [localId:%s]", localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            transceiver.direction = "recvonly";
            this._remoteSdp.resumeReceivingMediaSection(localId);
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger13.debug("resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          const answer = await this._pc.createAnswer();
          logger13.debug("resumeReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
        }
        async getReceiverStats(localId) {
          this.assertNotClosed();
          this.assertRecvDirection();
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          return transceiver.receiver.getStats();
        }
        async receiveDataChannel({ sctpStreamParameters, label, protocol }) {
          this.assertNotClosed();
          this.assertRecvDirection();
          const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;
          const options = {
            negotiated: true,
            id: streamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol
          };
          logger13.debug("receiveDataChannel() [options:%o]", options);
          const dataChannel = this._pc.createDataChannel(label, options);
          if (!this._hasDataChannelMediaSection) {
            this._remoteSdp.receiveSctpAssociation();
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger13.debug("receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]", offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            if (!this._transportReady) {
              const localSdpObject = sdpTransform.parse(answer.sdp);
              await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                localSdpObject
              });
            }
            logger13.debug("receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setLocalDescription(answer);
            this._hasDataChannelMediaSection = true;
          }
          return { dataChannel };
        }
        async setupTransport({ localDtlsRole, localSdpObject }) {
          if (!localSdpObject) {
            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
          }
          const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
            sdpObject: localSdpObject
          });
          dtlsParameters.role = localDtlsRole;
          this._remoteSdp.updateDtlsRole(localDtlsRole === "client" ? "server" : "client");
          await new Promise((resolve, reject) => {
            this.safeEmit("@connect", { dtlsParameters }, resolve, reject);
          });
          this._transportReady = true;
        }
        assertNotClosed() {
          if (this._closed) {
            throw new errors_1.InvalidStateError("method called in a closed handler");
          }
        }
        assertSendDirection() {
          if (this._direction !== "send") {
            throw new Error('method can just be called for handlers with "send" direction');
          }
        }
        assertRecvDirection() {
          if (this._direction !== "recv") {
            throw new Error('method can just be called for handlers with "recv" direction');
          }
        }
      };
      exports.Chrome74 = Chrome74;
    }
  });

  // ../../node_modules/mediasoup-client/lib/handlers/Chrome70.js
  var require_Chrome70 = __commonJS({
    "../../node_modules/mediasoup-client/lib/handlers/Chrome70.js"(exports) {
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Chrome70 = void 0;
      var sdpTransform = __importStar(require_lib3());
      var Logger_1 = require_Logger();
      var utils = __importStar(require_utils());
      var ortc = __importStar(require_ortc());
      var sdpCommonUtils = __importStar(require_commonUtils());
      var sdpUnifiedPlanUtils = __importStar(require_unifiedPlanUtils());
      var HandlerInterface_1 = require_HandlerInterface();
      var RemoteSdp_1 = require_RemoteSdp();
      var scalabilityModes_1 = require_scalabilityModes();
      var logger13 = new Logger_1.Logger("Chrome70");
      var NAME = "Chrome70";
      var SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };
      var Chrome70 = class _Chrome70 extends HandlerInterface_1.HandlerInterface {
        /**
         * Creates a factory function.
         */
        static createFactory() {
          return () => new _Chrome70();
        }
        constructor() {
          super();
          this._mapMidTransceiver = /* @__PURE__ */ new Map();
          this._sendStream = new MediaStream();
          this._hasDataChannelMediaSection = false;
          this._nextSendSctpStreamId = 0;
          this._transportReady = false;
        }
        get name() {
          return NAME;
        }
        close() {
          logger13.debug("close()");
          if (this._pc) {
            try {
              this._pc.close();
            } catch (error) {
            }
          }
          this.emit("@close");
        }
        async getNativeRtpCapabilities() {
          logger13.debug("getNativeRtpCapabilities()");
          const pc = new RTCPeerConnection({
            iceServers: [],
            iceTransportPolicy: "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require",
            sdpSemantics: "unified-plan"
          });
          try {
            pc.addTransceiver("audio");
            pc.addTransceiver("video");
            const offer = await pc.createOffer();
            try {
              pc.close();
            } catch (error) {
            }
            const sdpObject = sdpTransform.parse(offer.sdp);
            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
              sdpObject
            });
            return nativeRtpCapabilities;
          } catch (error) {
            try {
              pc.close();
            } catch (error2) {
            }
            throw error;
          }
        }
        async getNativeSctpCapabilities() {
          logger13.debug("getNativeSctpCapabilities()");
          return {
            numStreams: SCTP_NUM_STREAMS
          };
        }
        run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities }) {
          logger13.debug("run()");
          this._direction = direction;
          this._remoteSdp = new RemoteSdp_1.RemoteSdp({
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters
          });
          this._sendingRtpParametersByKind = {
            audio: ortc.getSendingRtpParameters("audio", extendedRtpCapabilities),
            video: ortc.getSendingRtpParameters("video", extendedRtpCapabilities)
          };
          this._sendingRemoteRtpParametersByKind = {
            audio: ortc.getSendingRemoteRtpParameters("audio", extendedRtpCapabilities),
            video: ortc.getSendingRemoteRtpParameters("video", extendedRtpCapabilities)
          };
          if (dtlsParameters.role && dtlsParameters.role !== "auto") {
            this._forcedLocalDtlsRole = dtlsParameters.role === "server" ? "client" : "server";
          }
          this._pc = new RTCPeerConnection({
            iceServers: iceServers ?? [],
            iceTransportPolicy: iceTransportPolicy ?? "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require",
            sdpSemantics: "unified-plan",
            ...additionalSettings
          }, proprietaryConstraints);
          this._pc.addEventListener("icegatheringstatechange", () => {
            this.emit("@icegatheringstatechange", this._pc.iceGatheringState);
          });
          if (this._pc.connectionState) {
            this._pc.addEventListener("connectionstatechange", () => {
              this.emit("@connectionstatechange", this._pc.connectionState);
            });
          } else {
            this._pc.addEventListener("iceconnectionstatechange", () => {
              logger13.warn("run() | pc.connectionState not supported, using pc.iceConnectionState");
              switch (this._pc.iceConnectionState) {
                case "checking": {
                  this.emit("@connectionstatechange", "connecting");
                  break;
                }
                case "connected":
                case "completed": {
                  this.emit("@connectionstatechange", "connected");
                  break;
                }
                case "failed": {
                  this.emit("@connectionstatechange", "failed");
                  break;
                }
                case "disconnected": {
                  this.emit("@connectionstatechange", "disconnected");
                  break;
                }
                case "closed": {
                  this.emit("@connectionstatechange", "closed");
                  break;
                }
              }
            });
          }
        }
        async updateIceServers(iceServers) {
          logger13.debug("updateIceServers()");
          const configuration = this._pc.getConfiguration();
          configuration.iceServers = iceServers;
          this._pc.setConfiguration(configuration);
        }
        async restartIce(iceParameters) {
          logger13.debug("restartIce()");
          this._remoteSdp.updateIceParameters(iceParameters);
          if (!this._transportReady) {
            return;
          }
          if (this._direction === "send") {
            const offer = await this._pc.createOffer({ iceRestart: true });
            logger13.debug("restartIce() | calling pc.setLocalDescription() [offer:%o]", offer);
            await this._pc.setLocalDescription(offer);
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger13.debug("restartIce() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setRemoteDescription(answer);
          } else {
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger13.debug("restartIce() | calling pc.setRemoteDescription() [offer:%o]", offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger13.debug("restartIce() | calling pc.setLocalDescription() [answer:%o]", answer);
            await this._pc.setLocalDescription(answer);
          }
        }
        async getTransportStats() {
          return this._pc.getStats();
        }
        async send({ track, encodings, codecOptions, codec }) {
          this.assertSendDirection();
          logger13.debug("send() [kind:%s, track.id:%s]", track.kind, track.id);
          const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);
          sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);
          const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);
          sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);
          const mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();
          const transceiver = this._pc.addTransceiver(track, {
            direction: "sendonly",
            streams: [this._sendStream]
          });
          let offer = await this._pc.createOffer();
          let localSdpObject = sdpTransform.parse(offer.sdp);
          let offerMediaObject;
          if (!this._transportReady) {
            await this.setupTransport({
              localDtlsRole: this._forcedLocalDtlsRole ?? "client",
              localSdpObject
            });
          }
          if (encodings && encodings.length > 1) {
            logger13.debug("send() | enabling legacy simulcast");
            localSdpObject = sdpTransform.parse(offer.sdp);
            offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
            sdpUnifiedPlanUtils.addLegacySimulcast({
              offerMediaObject,
              numStreams: encodings.length
            });
            offer = { type: "offer", sdp: sdpTransform.write(localSdpObject) };
          }
          let hackVp9Svc = false;
          const layers = (0, scalabilityModes_1.parse)((encodings ?? [{}])[0].scalabilityMode);
          if (encodings && encodings.length === 1 && layers.spatialLayers > 1 && sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/vp9") {
            logger13.debug("send() | enabling legacy simulcast for VP9 SVC");
            hackVp9Svc = true;
            localSdpObject = sdpTransform.parse(offer.sdp);
            offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
            sdpUnifiedPlanUtils.addLegacySimulcast({
              offerMediaObject,
              numStreams: layers.spatialLayers
            });
            offer = { type: "offer", sdp: sdpTransform.write(localSdpObject) };
          }
          logger13.debug("send() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          if (encodings) {
            logger13.debug("send() | applying given encodings");
            const parameters = transceiver.sender.getParameters();
            for (let idx = 0; idx < (parameters.encodings ?? []).length; ++idx) {
              const encoding = parameters.encodings[idx];
              const desiredEncoding = encodings[idx];
              if (!desiredEncoding) {
                break;
              }
              parameters.encodings[idx] = Object.assign(encoding, desiredEncoding);
            }
            await transceiver.sender.setParameters(parameters);
          }
          const localId = transceiver.mid;
          sendingRtpParameters.mid = localId;
          localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
          offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
          sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
            offerMediaObject
          });
          sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({
            offerMediaObject
          });
          if (encodings) {
            for (let idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {
              if (encodings[idx]) {
                Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);
              }
            }
          }
          if (hackVp9Svc) {
            sendingRtpParameters.encodings = [sendingRtpParameters.encodings[0]];
          }
          if (sendingRtpParameters.encodings.length > 1 && (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/vp8" || sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/h264")) {
            for (const encoding of sendingRtpParameters.encodings) {
              encoding.scalabilityMode = "L1T3";
            }
          }
          this._remoteSdp.send({
            offerMediaObject,
            reuseMid: mediaSectionIdx.reuseMid,
            offerRtpParameters: sendingRtpParameters,
            answerRtpParameters: sendingRemoteRtpParameters,
            codecOptions
          });
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger13.debug("send() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
          this._mapMidTransceiver.set(localId, transceiver);
          return {
            localId,
            rtpParameters: sendingRtpParameters,
            rtpSender: transceiver.sender
          };
        }
        async stopSending(localId) {
          this.assertSendDirection();
          logger13.debug("stopSending() [localId:%s]", localId);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          void transceiver.sender.replaceTrack(null);
          this._pc.removeTrack(transceiver.sender);
          const mediaSectionClosed = this._remoteSdp.closeMediaSection(transceiver.mid);
          if (mediaSectionClosed) {
            try {
              transceiver.stop();
            } catch (error) {
            }
          }
          const offer = await this._pc.createOffer();
          logger13.debug("stopSending() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger13.debug("stopSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
          this._mapMidTransceiver.delete(localId);
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        async pauseSending(localId) {
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        async resumeSending(localId) {
        }
        async replaceTrack(localId, track) {
          this.assertSendDirection();
          if (track) {
            logger13.debug("replaceTrack() [localId:%s, track.id:%s]", localId, track.id);
          } else {
            logger13.debug("replaceTrack() [localId:%s, no track]", localId);
          }
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          await transceiver.sender.replaceTrack(track);
        }
        async setMaxSpatialLayer(localId, spatialLayer) {
          this.assertSendDirection();
          logger13.debug("setMaxSpatialLayer() [localId:%s, spatialLayer:%s]", localId, spatialLayer);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          const parameters = transceiver.sender.getParameters();
          parameters.encodings.forEach((encoding, idx) => {
            if (idx <= spatialLayer) {
              encoding.active = true;
            } else {
              encoding.active = false;
            }
          });
          await transceiver.sender.setParameters(parameters);
          this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
          const offer = await this._pc.createOffer();
          logger13.debug("setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger13.debug("setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
        }
        async setRtpEncodingParameters(localId, params) {
          this.assertSendDirection();
          logger13.debug("setRtpEncodingParameters() [localId:%s, params:%o]", localId, params);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          const parameters = transceiver.sender.getParameters();
          parameters.encodings.forEach((encoding, idx) => {
            parameters.encodings[idx] = { ...encoding, ...params };
          });
          await transceiver.sender.setParameters(parameters);
          this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
          const offer = await this._pc.createOffer();
          logger13.debug("setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger13.debug("setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
        }
        async getSenderStats(localId) {
          this.assertSendDirection();
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          return transceiver.sender.getStats();
        }
        async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol }) {
          this.assertSendDirection();
          const options = {
            negotiated: true,
            id: this._nextSendSctpStreamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmitTime: maxPacketLifeTime,
            // NOTE: Old spec.
            maxRetransmits,
            protocol
          };
          logger13.debug("sendDataChannel() [options:%o]", options);
          const dataChannel = this._pc.createDataChannel(label, options);
          this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
          if (!this._hasDataChannelMediaSection) {
            const offer = await this._pc.createOffer();
            const localSdpObject = sdpTransform.parse(offer.sdp);
            const offerMediaObject = localSdpObject.media.find((m) => m.type === "application");
            if (!this._transportReady) {
              await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                localSdpObject
              });
            }
            logger13.debug("sendDataChannel() | calling pc.setLocalDescription() [offer:%o]", offer);
            await this._pc.setLocalDescription(offer);
            this._remoteSdp.sendSctpAssociation({ offerMediaObject });
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger13.debug("sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setRemoteDescription(answer);
            this._hasDataChannelMediaSection = true;
          }
          const sctpStreamParameters = {
            streamId: options.id,
            ordered: options.ordered,
            maxPacketLifeTime: options.maxPacketLifeTime,
            maxRetransmits: options.maxRetransmits
          };
          return { dataChannel, sctpStreamParameters };
        }
        async receive(optionsList) {
          this.assertRecvDirection();
          const results = [];
          const mapLocalId = /* @__PURE__ */ new Map();
          for (const options of optionsList) {
            const { trackId, kind, rtpParameters, streamId } = options;
            logger13.debug("receive() [trackId:%s, kind:%s]", trackId, kind);
            const localId = rtpParameters.mid ?? String(this._mapMidTransceiver.size);
            mapLocalId.set(trackId, localId);
            this._remoteSdp.receive({
              mid: localId,
              kind,
              offerRtpParameters: rtpParameters,
              streamId: streamId ?? rtpParameters.rtcp.cname,
              trackId
            });
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger13.debug("receive() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          let answer = await this._pc.createAnswer();
          const localSdpObject = sdpTransform.parse(answer.sdp);
          for (const options of optionsList) {
            const { trackId, rtpParameters } = options;
            const localId = mapLocalId.get(trackId);
            const answerMediaObject = localSdpObject.media.find((m) => String(m.mid) === localId);
            sdpCommonUtils.applyCodecParameters({
              offerRtpParameters: rtpParameters,
              answerMediaObject
            });
          }
          answer = { type: "answer", sdp: sdpTransform.write(localSdpObject) };
          if (!this._transportReady) {
            await this.setupTransport({
              localDtlsRole: this._forcedLocalDtlsRole ?? "client",
              localSdpObject
            });
          }
          logger13.debug("receive() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
          for (const options of optionsList) {
            const { trackId } = options;
            const localId = mapLocalId.get(trackId);
            const transceiver = this._pc.getTransceivers().find((t) => t.mid === localId);
            if (!transceiver) {
              throw new Error("new RTCRtpTransceiver not found");
            }
            this._mapMidTransceiver.set(localId, transceiver);
            results.push({
              localId,
              track: transceiver.receiver.track,
              rtpReceiver: transceiver.receiver
            });
          }
          return results;
        }
        async stopReceiving(localIds) {
          this.assertRecvDirection();
          for (const localId of localIds) {
            logger13.debug("stopReceiving() [localId:%s]", localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            this._remoteSdp.closeMediaSection(transceiver.mid);
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger13.debug("stopReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          const answer = await this._pc.createAnswer();
          logger13.debug("stopReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
          for (const localId of localIds) {
            this._mapMidTransceiver.delete(localId);
          }
        }
        async pauseReceiving(localIds) {
        }
        async resumeReceiving(localIds) {
        }
        async getReceiverStats(localId) {
          this.assertRecvDirection();
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          return transceiver.receiver.getStats();
        }
        async receiveDataChannel({ sctpStreamParameters, label, protocol }) {
          this.assertRecvDirection();
          const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;
          const options = {
            negotiated: true,
            id: streamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmitTime: maxPacketLifeTime,
            // NOTE: Old spec.
            maxRetransmits,
            protocol
          };
          logger13.debug("receiveDataChannel() [options:%o]", options);
          const dataChannel = this._pc.createDataChannel(label, options);
          if (!this._hasDataChannelMediaSection) {
            this._remoteSdp.receiveSctpAssociation();
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger13.debug("receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]", offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            if (!this._transportReady) {
              const localSdpObject = sdpTransform.parse(answer.sdp);
              await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                localSdpObject
              });
            }
            logger13.debug("receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setLocalDescription(answer);
            this._hasDataChannelMediaSection = true;
          }
          return { dataChannel };
        }
        async setupTransport({ localDtlsRole, localSdpObject }) {
          if (!localSdpObject) {
            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
          }
          const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
            sdpObject: localSdpObject
          });
          dtlsParameters.role = localDtlsRole;
          this._remoteSdp.updateDtlsRole(localDtlsRole === "client" ? "server" : "client");
          await new Promise((resolve, reject) => {
            this.safeEmit("@connect", { dtlsParameters }, resolve, reject);
          });
          this._transportReady = true;
        }
        assertSendDirection() {
          if (this._direction !== "send") {
            throw new Error('method can just be called for handlers with "send" direction');
          }
        }
        assertRecvDirection() {
          if (this._direction !== "recv") {
            throw new Error('method can just be called for handlers with "recv" direction');
          }
        }
      };
      exports.Chrome70 = Chrome70;
    }
  });

  // ../../node_modules/mediasoup-client/lib/handlers/sdp/planBUtils.js
  var require_planBUtils = __commonJS({
    "../../node_modules/mediasoup-client/lib/handlers/sdp/planBUtils.js"(exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getRtpEncodings = getRtpEncodings;
      exports.addLegacySimulcast = addLegacySimulcast;
      function getRtpEncodings({ offerMediaObject, track }) {
        const ssrcs = /* @__PURE__ */ new Set();
        for (const line of offerMediaObject.ssrcs || []) {
          if (line.attribute !== "msid") {
            continue;
          }
          const trackId = line.value.split(" ")[1];
          if (trackId === track.id) {
            const ssrc = line.id;
            ssrcs.add(ssrc);
          }
        }
        if (ssrcs.size === 0) {
          throw new Error(`a=ssrc line with msid information not found [track.id:${track.id}]`);
        }
        const ssrcToRtxSsrc = /* @__PURE__ */ new Map();
        for (const line of offerMediaObject.ssrcGroups || []) {
          if (line.semantics !== "FID") {
            continue;
          }
          let [ssrc, rtxSsrc] = line.ssrcs.split(/\s+/);
          ssrc = Number(ssrc);
          rtxSsrc = Number(rtxSsrc);
          if (ssrcs.has(ssrc)) {
            ssrcs.delete(ssrc);
            ssrcs.delete(rtxSsrc);
            ssrcToRtxSsrc.set(ssrc, rtxSsrc);
          }
        }
        for (const ssrc of ssrcs) {
          ssrcToRtxSsrc.set(ssrc, null);
        }
        const encodings = [];
        for (const [ssrc, rtxSsrc] of ssrcToRtxSsrc) {
          const encoding = { ssrc };
          if (rtxSsrc) {
            encoding.rtx = { ssrc: rtxSsrc };
          }
          encodings.push(encoding);
        }
        return encodings;
      }
      function addLegacySimulcast({ offerMediaObject, track, numStreams }) {
        if (numStreams <= 1) {
          throw new TypeError("numStreams must be greater than 1");
        }
        let firstSsrc;
        let firstRtxSsrc;
        let streamId;
        const ssrcMsidLine = (offerMediaObject.ssrcs || []).find((line) => {
          if (line.attribute !== "msid") {
            return false;
          }
          const trackId = line.value.split(" ")[1];
          if (trackId === track.id) {
            firstSsrc = line.id;
            streamId = line.value.split(" ")[0];
            return true;
          } else {
            return false;
          }
        });
        if (!ssrcMsidLine) {
          throw new Error(`a=ssrc line with msid information not found [track.id:${track.id}]`);
        }
        (offerMediaObject.ssrcGroups || []).some((line) => {
          if (line.semantics !== "FID") {
            return false;
          }
          const ssrcs2 = line.ssrcs.split(/\s+/);
          if (Number(ssrcs2[0]) === firstSsrc) {
            firstRtxSsrc = Number(ssrcs2[1]);
            return true;
          } else {
            return false;
          }
        });
        const ssrcCnameLine = offerMediaObject.ssrcs.find((line) => line.attribute === "cname" && line.id === firstSsrc);
        if (!ssrcCnameLine) {
          throw new Error(`a=ssrc line with cname information not found [track.id:${track.id}]`);
        }
        const cname = ssrcCnameLine.value;
        const ssrcs = [];
        const rtxSsrcs = [];
        for (let i = 0; i < numStreams; ++i) {
          ssrcs.push(firstSsrc + i);
          if (firstRtxSsrc) {
            rtxSsrcs.push(firstRtxSsrc + i);
          }
        }
        offerMediaObject.ssrcGroups = offerMediaObject.ssrcGroups || [];
        offerMediaObject.ssrcs = offerMediaObject.ssrcs || [];
        offerMediaObject.ssrcGroups.push({
          semantics: "SIM",
          ssrcs: ssrcs.join(" ")
        });
        for (const ssrc of ssrcs) {
          offerMediaObject.ssrcs.push({
            id: ssrc,
            attribute: "cname",
            value: cname
          });
          offerMediaObject.ssrcs.push({
            id: ssrc,
            attribute: "msid",
            value: `${streamId} ${track.id}`
          });
        }
        for (let i = 0; i < rtxSsrcs.length; ++i) {
          const ssrc = ssrcs[i];
          const rtxSsrc = rtxSsrcs[i];
          offerMediaObject.ssrcs.push({
            id: rtxSsrc,
            attribute: "cname",
            value: cname
          });
          offerMediaObject.ssrcs.push({
            id: rtxSsrc,
            attribute: "msid",
            value: `${streamId} ${track.id}`
          });
          offerMediaObject.ssrcGroups.push({
            semantics: "FID",
            ssrcs: `${ssrc} ${rtxSsrc}`
          });
        }
      }
    }
  });

  // ../../node_modules/mediasoup-client/lib/handlers/Chrome67.js
  var require_Chrome67 = __commonJS({
    "../../node_modules/mediasoup-client/lib/handlers/Chrome67.js"(exports) {
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Chrome67 = void 0;
      var sdpTransform = __importStar(require_lib3());
      var Logger_1 = require_Logger();
      var utils = __importStar(require_utils());
      var ortc = __importStar(require_ortc());
      var sdpCommonUtils = __importStar(require_commonUtils());
      var sdpPlanBUtils = __importStar(require_planBUtils());
      var HandlerInterface_1 = require_HandlerInterface();
      var RemoteSdp_1 = require_RemoteSdp();
      var logger13 = new Logger_1.Logger("Chrome67");
      var NAME = "Chrome67";
      var SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };
      var Chrome67 = class _Chrome67 extends HandlerInterface_1.HandlerInterface {
        /**
         * Creates a factory function.
         */
        static createFactory() {
          return () => new _Chrome67();
        }
        constructor() {
          super();
          this._sendStream = new MediaStream();
          this._mapSendLocalIdRtpSender = /* @__PURE__ */ new Map();
          this._nextSendLocalId = 0;
          this._mapRecvLocalIdInfo = /* @__PURE__ */ new Map();
          this._hasDataChannelMediaSection = false;
          this._nextSendSctpStreamId = 0;
          this._transportReady = false;
        }
        get name() {
          return NAME;
        }
        close() {
          logger13.debug("close()");
          if (this._pc) {
            try {
              this._pc.close();
            } catch (error) {
            }
          }
          this.emit("@close");
        }
        async getNativeRtpCapabilities() {
          logger13.debug("getNativeRtpCapabilities()");
          const pc = new RTCPeerConnection({
            iceServers: [],
            iceTransportPolicy: "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require",
            sdpSemantics: "plan-b"
          });
          try {
            const offer = await pc.createOffer({
              offerToReceiveAudio: true,
              offerToReceiveVideo: true
            });
            try {
              pc.close();
            } catch (error) {
            }
            const sdpObject = sdpTransform.parse(offer.sdp);
            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
              sdpObject
            });
            return nativeRtpCapabilities;
          } catch (error) {
            try {
              pc.close();
            } catch (error2) {
            }
            throw error;
          }
        }
        async getNativeSctpCapabilities() {
          logger13.debug("getNativeSctpCapabilities()");
          return {
            numStreams: SCTP_NUM_STREAMS
          };
        }
        run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities }) {
          logger13.debug("run()");
          this._direction = direction;
          this._remoteSdp = new RemoteSdp_1.RemoteSdp({
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
            planB: true
          });
          this._sendingRtpParametersByKind = {
            audio: ortc.getSendingRtpParameters("audio", extendedRtpCapabilities),
            video: ortc.getSendingRtpParameters("video", extendedRtpCapabilities)
          };
          this._sendingRemoteRtpParametersByKind = {
            audio: ortc.getSendingRemoteRtpParameters("audio", extendedRtpCapabilities),
            video: ortc.getSendingRemoteRtpParameters("video", extendedRtpCapabilities)
          };
          if (dtlsParameters.role && dtlsParameters.role !== "auto") {
            this._forcedLocalDtlsRole = dtlsParameters.role === "server" ? "client" : "server";
          }
          this._pc = new RTCPeerConnection({
            iceServers: iceServers ?? [],
            iceTransportPolicy: iceTransportPolicy ?? "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require",
            sdpSemantics: "plan-b",
            ...additionalSettings
          }, proprietaryConstraints);
          this._pc.addEventListener("icegatheringstatechange", () => {
            this.emit("@icegatheringstatechange", this._pc.iceGatheringState);
          });
          if (this._pc.connectionState) {
            this._pc.addEventListener("connectionstatechange", () => {
              this.emit("@connectionstatechange", this._pc.connectionState);
            });
          } else {
            this._pc.addEventListener("iceconnectionstatechange", () => {
              logger13.warn("run() | pc.connectionState not supported, using pc.iceConnectionState");
              switch (this._pc.iceConnectionState) {
                case "checking": {
                  this.emit("@connectionstatechange", "connecting");
                  break;
                }
                case "connected":
                case "completed": {
                  this.emit("@connectionstatechange", "connected");
                  break;
                }
                case "failed": {
                  this.emit("@connectionstatechange", "failed");
                  break;
                }
                case "disconnected": {
                  this.emit("@connectionstatechange", "disconnected");
                  break;
                }
                case "closed": {
                  this.emit("@connectionstatechange", "closed");
                  break;
                }
              }
            });
          }
        }
        async updateIceServers(iceServers) {
          logger13.debug("updateIceServers()");
          const configuration = this._pc.getConfiguration();
          configuration.iceServers = iceServers;
          this._pc.setConfiguration(configuration);
        }
        async restartIce(iceParameters) {
          logger13.debug("restartIce()");
          this._remoteSdp.updateIceParameters(iceParameters);
          if (!this._transportReady) {
            return;
          }
          if (this._direction === "send") {
            const offer = await this._pc.createOffer({ iceRestart: true });
            logger13.debug("restartIce() | calling pc.setLocalDescription() [offer:%o]", offer);
            await this._pc.setLocalDescription(offer);
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger13.debug("restartIce() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setRemoteDescription(answer);
          } else {
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger13.debug("restartIce() | calling pc.setRemoteDescription() [offer:%o]", offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger13.debug("restartIce() | calling pc.setLocalDescription() [answer:%o]", answer);
            await this._pc.setLocalDescription(answer);
          }
        }
        async getTransportStats() {
          return this._pc.getStats();
        }
        async send({ track, encodings, codecOptions, codec }) {
          this.assertSendDirection();
          logger13.debug("send() [kind:%s, track.id:%s]", track.kind, track.id);
          if (codec) {
            logger13.warn("send() | codec selection is not available in %s handler", this.name);
          }
          this._sendStream.addTrack(track);
          this._pc.addTrack(track, this._sendStream);
          let offer = await this._pc.createOffer();
          let localSdpObject = sdpTransform.parse(offer.sdp);
          let offerMediaObject;
          const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);
          sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs);
          const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);
          sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs);
          if (!this._transportReady) {
            await this.setupTransport({
              localDtlsRole: this._forcedLocalDtlsRole ?? "client",
              localSdpObject
            });
          }
          if (track.kind === "video" && encodings && encodings.length > 1) {
            logger13.debug("send() | enabling simulcast");
            localSdpObject = sdpTransform.parse(offer.sdp);
            offerMediaObject = localSdpObject.media.find((m) => m.type === "video");
            sdpPlanBUtils.addLegacySimulcast({
              offerMediaObject,
              track,
              numStreams: encodings.length
            });
            offer = { type: "offer", sdp: sdpTransform.write(localSdpObject) };
          }
          logger13.debug("send() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
          offerMediaObject = localSdpObject.media.find((m) => m.type === track.kind);
          sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
            offerMediaObject
          });
          sendingRtpParameters.encodings = sdpPlanBUtils.getRtpEncodings({
            offerMediaObject,
            track
          });
          if (encodings) {
            for (let idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {
              if (encodings[idx]) {
                Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);
              }
            }
          }
          if (sendingRtpParameters.encodings.length > 1 && sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/vp8") {
            for (const encoding of sendingRtpParameters.encodings) {
              encoding.scalabilityMode = "L1T3";
            }
          }
          this._remoteSdp.send({
            offerMediaObject,
            offerRtpParameters: sendingRtpParameters,
            answerRtpParameters: sendingRemoteRtpParameters,
            codecOptions
          });
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger13.debug("send() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
          const localId = String(this._nextSendLocalId);
          this._nextSendLocalId++;
          const rtpSender = this._pc.getSenders().find((s) => s.track === track);
          this._mapSendLocalIdRtpSender.set(localId, rtpSender);
          return {
            localId,
            rtpParameters: sendingRtpParameters,
            rtpSender
          };
        }
        async stopSending(localId) {
          this.assertSendDirection();
          logger13.debug("stopSending() [localId:%s]", localId);
          const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
          if (!rtpSender) {
            throw new Error("associated RTCRtpSender not found");
          }
          this._pc.removeTrack(rtpSender);
          if (rtpSender.track) {
            this._sendStream.removeTrack(rtpSender.track);
          }
          this._mapSendLocalIdRtpSender.delete(localId);
          const offer = await this._pc.createOffer();
          logger13.debug("stopSending() | calling pc.setLocalDescription() [offer:%o]", offer);
          try {
            await this._pc.setLocalDescription(offer);
          } catch (error) {
            if (this._sendStream.getTracks().length === 0) {
              logger13.warn("stopSending() | ignoring expected error due no sending tracks: %s", error.toString());
              return;
            }
            throw error;
          }
          if (this._pc.signalingState === "stable") {
            return;
          }
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger13.debug("stopSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        async pauseSending(localId) {
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        async resumeSending(localId) {
        }
        async replaceTrack(localId, track) {
          this.assertSendDirection();
          if (track) {
            logger13.debug("replaceTrack() [localId:%s, track.id:%s]", localId, track.id);
          } else {
            logger13.debug("replaceTrack() [localId:%s, no track]", localId);
          }
          const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
          if (!rtpSender) {
            throw new Error("associated RTCRtpSender not found");
          }
          const oldTrack = rtpSender.track;
          await rtpSender.replaceTrack(track);
          if (oldTrack) {
            this._sendStream.removeTrack(oldTrack);
          }
          if (track) {
            this._sendStream.addTrack(track);
          }
        }
        async setMaxSpatialLayer(localId, spatialLayer) {
          this.assertSendDirection();
          logger13.debug("setMaxSpatialLayer() [localId:%s, spatialLayer:%s]", localId, spatialLayer);
          const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
          if (!rtpSender) {
            throw new Error("associated RTCRtpSender not found");
          }
          const parameters = rtpSender.getParameters();
          parameters.encodings.forEach((encoding, idx) => {
            if (idx <= spatialLayer) {
              encoding.active = true;
            } else {
              encoding.active = false;
            }
          });
          await rtpSender.setParameters(parameters);
        }
        async setRtpEncodingParameters(localId, params) {
          this.assertSendDirection();
          logger13.debug("setRtpEncodingParameters() [localId:%s, params:%o]", localId, params);
          const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
          if (!rtpSender) {
            throw new Error("associated RTCRtpSender not found");
          }
          const parameters = rtpSender.getParameters();
          parameters.encodings.forEach((encoding, idx) => {
            parameters.encodings[idx] = { ...encoding, ...params };
          });
          await rtpSender.setParameters(parameters);
        }
        async getSenderStats(localId) {
          this.assertSendDirection();
          const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
          if (!rtpSender) {
            throw new Error("associated RTCRtpSender not found");
          }
          return rtpSender.getStats();
        }
        async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol }) {
          this.assertSendDirection();
          const options = {
            negotiated: true,
            id: this._nextSendSctpStreamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmitTime: maxPacketLifeTime,
            // NOTE: Old spec.
            maxRetransmits,
            protocol
          };
          logger13.debug("sendDataChannel() [options:%o]", options);
          const dataChannel = this._pc.createDataChannel(label, options);
          this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
          if (!this._hasDataChannelMediaSection) {
            const offer = await this._pc.createOffer();
            const localSdpObject = sdpTransform.parse(offer.sdp);
            const offerMediaObject = localSdpObject.media.find((m) => m.type === "application");
            if (!this._transportReady) {
              await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                localSdpObject
              });
            }
            logger13.debug("sendDataChannel() | calling pc.setLocalDescription() [offer:%o]", offer);
            await this._pc.setLocalDescription(offer);
            this._remoteSdp.sendSctpAssociation({ offerMediaObject });
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger13.debug("sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setRemoteDescription(answer);
            this._hasDataChannelMediaSection = true;
          }
          const sctpStreamParameters = {
            streamId: options.id,
            ordered: options.ordered,
            maxPacketLifeTime: options.maxPacketLifeTime,
            maxRetransmits: options.maxRetransmits
          };
          return { dataChannel, sctpStreamParameters };
        }
        async receive(optionsList) {
          this.assertRecvDirection();
          const results = [];
          for (const options of optionsList) {
            const { trackId, kind, rtpParameters, streamId } = options;
            logger13.debug("receive() [trackId:%s, kind:%s]", trackId, kind);
            const mid = kind;
            this._remoteSdp.receive({
              mid,
              kind,
              offerRtpParameters: rtpParameters,
              streamId: streamId ?? rtpParameters.rtcp.cname,
              trackId
            });
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger13.debug("receive() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          let answer = await this._pc.createAnswer();
          const localSdpObject = sdpTransform.parse(answer.sdp);
          for (const options of optionsList) {
            const { kind, rtpParameters } = options;
            const mid = kind;
            const answerMediaObject = localSdpObject.media.find((m) => String(m.mid) === mid);
            sdpCommonUtils.applyCodecParameters({
              offerRtpParameters: rtpParameters,
              answerMediaObject
            });
          }
          answer = { type: "answer", sdp: sdpTransform.write(localSdpObject) };
          if (!this._transportReady) {
            await this.setupTransport({
              localDtlsRole: this._forcedLocalDtlsRole ?? "client",
              localSdpObject
            });
          }
          logger13.debug("receive() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
          for (const options of optionsList) {
            const { kind, trackId, rtpParameters } = options;
            const localId = trackId;
            const mid = kind;
            const rtpReceiver = this._pc.getReceivers().find((r) => r.track && r.track.id === localId);
            if (!rtpReceiver) {
              throw new Error("new RTCRtpReceiver not");
            }
            this._mapRecvLocalIdInfo.set(localId, {
              mid,
              rtpParameters,
              rtpReceiver
            });
            results.push({
              localId,
              track: rtpReceiver.track,
              rtpReceiver
            });
          }
          return results;
        }
        async stopReceiving(localIds) {
          this.assertRecvDirection();
          for (const localId of localIds) {
            logger13.debug("stopReceiving() [localId:%s]", localId);
            const { mid, rtpParameters } = this._mapRecvLocalIdInfo.get(localId) ?? {};
            this._mapRecvLocalIdInfo.delete(localId);
            this._remoteSdp.planBStopReceiving({
              mid,
              offerRtpParameters: rtpParameters
            });
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger13.debug("stopReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          const answer = await this._pc.createAnswer();
          logger13.debug("stopReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
        }
        async pauseReceiving(localIds) {
        }
        async resumeReceiving(localIds) {
        }
        async getReceiverStats(localId) {
          this.assertRecvDirection();
          const { rtpReceiver } = this._mapRecvLocalIdInfo.get(localId) ?? {};
          if (!rtpReceiver) {
            throw new Error("associated RTCRtpReceiver not found");
          }
          return rtpReceiver.getStats();
        }
        async receiveDataChannel({ sctpStreamParameters, label, protocol }) {
          this.assertRecvDirection();
          const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;
          const options = {
            negotiated: true,
            id: streamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmitTime: maxPacketLifeTime,
            // NOTE: Old spec.
            maxRetransmits,
            protocol
          };
          logger13.debug("receiveDataChannel() [options:%o]", options);
          const dataChannel = this._pc.createDataChannel(label, options);
          if (!this._hasDataChannelMediaSection) {
            this._remoteSdp.receiveSctpAssociation({ oldDataChannelSpec: true });
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger13.debug("receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]", offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            if (!this._transportReady) {
              const localSdpObject = sdpTransform.parse(answer.sdp);
              await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                localSdpObject
              });
            }
            logger13.debug("receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setLocalDescription(answer);
            this._hasDataChannelMediaSection = true;
          }
          return { dataChannel };
        }
        async setupTransport({ localDtlsRole, localSdpObject }) {
          if (!localSdpObject) {
            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
          }
          const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
            sdpObject: localSdpObject
          });
          dtlsParameters.role = localDtlsRole;
          this._remoteSdp.updateDtlsRole(localDtlsRole === "client" ? "server" : "client");
          await new Promise((resolve, reject) => {
            this.safeEmit("@connect", { dtlsParameters }, resolve, reject);
          });
          this._transportReady = true;
        }
        assertSendDirection() {
          if (this._direction !== "send") {
            throw new Error('method can just be called for handlers with "send" direction');
          }
        }
        assertRecvDirection() {
          if (this._direction !== "recv") {
            throw new Error('method can just be called for handlers with "recv" direction');
          }
        }
      };
      exports.Chrome67 = Chrome67;
    }
  });

  // ../../node_modules/mediasoup-client/lib/handlers/Chrome55.js
  var require_Chrome55 = __commonJS({
    "../../node_modules/mediasoup-client/lib/handlers/Chrome55.js"(exports) {
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Chrome55 = void 0;
      var sdpTransform = __importStar(require_lib3());
      var Logger_1 = require_Logger();
      var errors_1 = require_errors();
      var utils = __importStar(require_utils());
      var ortc = __importStar(require_ortc());
      var sdpCommonUtils = __importStar(require_commonUtils());
      var sdpPlanBUtils = __importStar(require_planBUtils());
      var HandlerInterface_1 = require_HandlerInterface();
      var RemoteSdp_1 = require_RemoteSdp();
      var logger13 = new Logger_1.Logger("Chrome55");
      var NAME = "Chrome55";
      var SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };
      var Chrome55 = class _Chrome55 extends HandlerInterface_1.HandlerInterface {
        /**
         * Creates a factory function.
         */
        static createFactory() {
          return () => new _Chrome55();
        }
        constructor() {
          super();
          this._sendStream = new MediaStream();
          this._mapSendLocalIdTrack = /* @__PURE__ */ new Map();
          this._nextSendLocalId = 0;
          this._mapRecvLocalIdInfo = /* @__PURE__ */ new Map();
          this._hasDataChannelMediaSection = false;
          this._nextSendSctpStreamId = 0;
          this._transportReady = false;
        }
        get name() {
          return NAME;
        }
        close() {
          logger13.debug("close()");
          if (this._pc) {
            try {
              this._pc.close();
            } catch (error) {
            }
          }
          this.emit("@close");
        }
        async getNativeRtpCapabilities() {
          logger13.debug("getNativeRtpCapabilities()");
          const pc = new RTCPeerConnection({
            iceServers: [],
            iceTransportPolicy: "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require",
            sdpSemantics: "plan-b"
          });
          try {
            const offer = await pc.createOffer({
              offerToReceiveAudio: true,
              offerToReceiveVideo: true
            });
            try {
              pc.close();
            } catch (error) {
            }
            const sdpObject = sdpTransform.parse(offer.sdp);
            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
              sdpObject
            });
            return nativeRtpCapabilities;
          } catch (error) {
            try {
              pc.close();
            } catch (error2) {
            }
            throw error;
          }
        }
        async getNativeSctpCapabilities() {
          logger13.debug("getNativeSctpCapabilities()");
          return {
            numStreams: SCTP_NUM_STREAMS
          };
        }
        run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities }) {
          logger13.debug("run()");
          this._direction = direction;
          this._remoteSdp = new RemoteSdp_1.RemoteSdp({
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
            planB: true
          });
          this._sendingRtpParametersByKind = {
            audio: ortc.getSendingRtpParameters("audio", extendedRtpCapabilities),
            video: ortc.getSendingRtpParameters("video", extendedRtpCapabilities)
          };
          this._sendingRemoteRtpParametersByKind = {
            audio: ortc.getSendingRemoteRtpParameters("audio", extendedRtpCapabilities),
            video: ortc.getSendingRemoteRtpParameters("video", extendedRtpCapabilities)
          };
          if (dtlsParameters.role && dtlsParameters.role !== "auto") {
            this._forcedLocalDtlsRole = dtlsParameters.role === "server" ? "client" : "server";
          }
          this._pc = new RTCPeerConnection({
            iceServers: iceServers ?? [],
            iceTransportPolicy: iceTransportPolicy ?? "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require",
            sdpSemantics: "plan-b",
            ...additionalSettings
          }, proprietaryConstraints);
          this._pc.addEventListener("icegatheringstatechange", () => {
            this.emit("@icegatheringstatechange", this._pc.iceGatheringState);
          });
          if (this._pc.connectionState) {
            this._pc.addEventListener("connectionstatechange", () => {
              this.emit("@connectionstatechange", this._pc.connectionState);
            });
          } else {
            this._pc.addEventListener("iceconnectionstatechange", () => {
              logger13.warn("run() | pc.connectionState not supported, using pc.iceConnectionState");
              switch (this._pc.iceConnectionState) {
                case "checking": {
                  this.emit("@connectionstatechange", "connecting");
                  break;
                }
                case "connected":
                case "completed": {
                  this.emit("@connectionstatechange", "connected");
                  break;
                }
                case "failed": {
                  this.emit("@connectionstatechange", "failed");
                  break;
                }
                case "disconnected": {
                  this.emit("@connectionstatechange", "disconnected");
                  break;
                }
                case "closed": {
                  this.emit("@connectionstatechange", "closed");
                  break;
                }
              }
            });
          }
        }
        async updateIceServers(iceServers) {
          logger13.debug("updateIceServers()");
          const configuration = this._pc.getConfiguration();
          configuration.iceServers = iceServers;
          this._pc.setConfiguration(configuration);
        }
        async restartIce(iceParameters) {
          logger13.debug("restartIce()");
          this._remoteSdp.updateIceParameters(iceParameters);
          if (!this._transportReady) {
            return;
          }
          if (this._direction === "send") {
            const offer = await this._pc.createOffer({ iceRestart: true });
            logger13.debug("restartIce() | calling pc.setLocalDescription() [offer:%o]", offer);
            await this._pc.setLocalDescription(offer);
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger13.debug("restartIce() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setRemoteDescription(answer);
          } else {
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger13.debug("restartIce() | calling pc.setRemoteDescription() [offer:%o]", offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger13.debug("restartIce() | calling pc.setLocalDescription() [answer:%o]", answer);
            await this._pc.setLocalDescription(answer);
          }
        }
        async getTransportStats() {
          return this._pc.getStats();
        }
        async send({ track, encodings, codecOptions, codec }) {
          this.assertSendDirection();
          logger13.debug("send() [kind:%s, track.id:%s]", track.kind, track.id);
          if (codec) {
            logger13.warn("send() | codec selection is not available in %s handler", this.name);
          }
          this._sendStream.addTrack(track);
          this._pc.addStream(this._sendStream);
          let offer = await this._pc.createOffer();
          let localSdpObject = sdpTransform.parse(offer.sdp);
          let offerMediaObject;
          const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);
          sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs);
          const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);
          sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs);
          if (!this._transportReady) {
            await this.setupTransport({
              localDtlsRole: this._forcedLocalDtlsRole ?? "client",
              localSdpObject
            });
          }
          if (track.kind === "video" && encodings && encodings.length > 1) {
            logger13.debug("send() | enabling simulcast");
            localSdpObject = sdpTransform.parse(offer.sdp);
            offerMediaObject = localSdpObject.media.find((m) => m.type === "video");
            sdpPlanBUtils.addLegacySimulcast({
              offerMediaObject,
              track,
              numStreams: encodings.length
            });
            offer = { type: "offer", sdp: sdpTransform.write(localSdpObject) };
          }
          logger13.debug("send() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
          offerMediaObject = localSdpObject.media.find((m) => m.type === track.kind);
          sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
            offerMediaObject
          });
          sendingRtpParameters.encodings = sdpPlanBUtils.getRtpEncodings({
            offerMediaObject,
            track
          });
          if (encodings) {
            for (let idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {
              if (encodings[idx]) {
                Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);
              }
            }
          }
          if (sendingRtpParameters.encodings.length > 1 && sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/vp8") {
            for (const encoding of sendingRtpParameters.encodings) {
              encoding.scalabilityMode = "L1T3";
            }
          }
          this._remoteSdp.send({
            offerMediaObject,
            offerRtpParameters: sendingRtpParameters,
            answerRtpParameters: sendingRemoteRtpParameters,
            codecOptions
          });
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger13.debug("send() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
          const localId = String(this._nextSendLocalId);
          this._nextSendLocalId++;
          this._mapSendLocalIdTrack.set(localId, track);
          return {
            localId,
            rtpParameters: sendingRtpParameters
          };
        }
        async stopSending(localId) {
          this.assertSendDirection();
          logger13.debug("stopSending() [localId:%s]", localId);
          const track = this._mapSendLocalIdTrack.get(localId);
          if (!track) {
            throw new Error("track not found");
          }
          this._mapSendLocalIdTrack.delete(localId);
          this._sendStream.removeTrack(track);
          this._pc.addStream(this._sendStream);
          const offer = await this._pc.createOffer();
          logger13.debug("stopSending() | calling pc.setLocalDescription() [offer:%o]", offer);
          try {
            await this._pc.setLocalDescription(offer);
          } catch (error) {
            if (this._sendStream.getTracks().length === 0) {
              logger13.warn("stopSending() | ignoring expected error due no sending tracks: %s", error.toString());
              return;
            }
            throw error;
          }
          if (this._pc.signalingState === "stable") {
            return;
          }
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger13.debug("stopSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        async pauseSending(localId) {
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        async resumeSending(localId) {
        }
        async replaceTrack(localId, track) {
          throw new errors_1.UnsupportedError("not implemented");
        }
        async setMaxSpatialLayer(localId, spatialLayer) {
          throw new errors_1.UnsupportedError(" not implemented");
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        async setRtpEncodingParameters(localId, params) {
          throw new errors_1.UnsupportedError("not supported");
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        async getSenderStats(localId) {
          throw new errors_1.UnsupportedError("not implemented");
        }
        async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol }) {
          this.assertSendDirection();
          const options = {
            negotiated: true,
            id: this._nextSendSctpStreamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmitTime: maxPacketLifeTime,
            // NOTE: Old spec.
            maxRetransmits,
            protocol
          };
          logger13.debug("sendDataChannel() [options:%o]", options);
          const dataChannel = this._pc.createDataChannel(label, options);
          this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
          if (!this._hasDataChannelMediaSection) {
            const offer = await this._pc.createOffer();
            const localSdpObject = sdpTransform.parse(offer.sdp);
            const offerMediaObject = localSdpObject.media.find((m) => m.type === "application");
            if (!this._transportReady) {
              await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                localSdpObject
              });
            }
            logger13.debug("sendDataChannel() | calling pc.setLocalDescription() [offer:%o]", offer);
            await this._pc.setLocalDescription(offer);
            this._remoteSdp.sendSctpAssociation({ offerMediaObject });
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger13.debug("sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setRemoteDescription(answer);
            this._hasDataChannelMediaSection = true;
          }
          const sctpStreamParameters = {
            streamId: options.id,
            ordered: options.ordered,
            maxPacketLifeTime: options.maxPacketLifeTime,
            maxRetransmits: options.maxRetransmits
          };
          return { dataChannel, sctpStreamParameters };
        }
        async receive(optionsList) {
          this.assertRecvDirection();
          const results = [];
          for (const options of optionsList) {
            const { trackId, kind, rtpParameters, streamId } = options;
            logger13.debug("receive() [trackId:%s, kind:%s]", trackId, kind);
            const mid = kind;
            this._remoteSdp.receive({
              mid,
              kind,
              offerRtpParameters: rtpParameters,
              streamId: streamId ?? rtpParameters.rtcp.cname,
              trackId
            });
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger13.debug("receive() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          let answer = await this._pc.createAnswer();
          const localSdpObject = sdpTransform.parse(answer.sdp);
          for (const options of optionsList) {
            const { kind, rtpParameters } = options;
            const mid = kind;
            const answerMediaObject = localSdpObject.media.find((m) => String(m.mid) === mid);
            sdpCommonUtils.applyCodecParameters({
              offerRtpParameters: rtpParameters,
              answerMediaObject
            });
          }
          answer = { type: "answer", sdp: sdpTransform.write(localSdpObject) };
          if (!this._transportReady) {
            await this.setupTransport({
              localDtlsRole: this._forcedLocalDtlsRole ?? "client",
              localSdpObject
            });
          }
          logger13.debug("receive() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
          for (const options of optionsList) {
            const { kind, trackId, rtpParameters } = options;
            const mid = kind;
            const localId = trackId;
            const streamId = options.streamId ?? rtpParameters.rtcp.cname;
            const stream = this._pc.getRemoteStreams().find((s) => s.id === streamId);
            const track = stream.getTrackById(localId);
            if (!track) {
              throw new Error("remote track not found");
            }
            this._mapRecvLocalIdInfo.set(localId, { mid, rtpParameters });
            results.push({ localId, track });
          }
          return results;
        }
        async stopReceiving(localIds) {
          this.assertRecvDirection();
          for (const localId of localIds) {
            logger13.debug("stopReceiving() [localId:%s]", localId);
            const { mid, rtpParameters } = this._mapRecvLocalIdInfo.get(localId) ?? {};
            this._mapRecvLocalIdInfo.delete(localId);
            this._remoteSdp.planBStopReceiving({
              mid,
              offerRtpParameters: rtpParameters
            });
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger13.debug("stopReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          const answer = await this._pc.createAnswer();
          logger13.debug("stopReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
        }
        async pauseReceiving(localIds) {
        }
        async resumeReceiving(localIds) {
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        async getReceiverStats(localId) {
          throw new errors_1.UnsupportedError("not implemented");
        }
        async receiveDataChannel({ sctpStreamParameters, label, protocol }) {
          this.assertRecvDirection();
          const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;
          const options = {
            negotiated: true,
            id: streamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmitTime: maxPacketLifeTime,
            // NOTE: Old spec.
            maxRetransmits,
            protocol
          };
          logger13.debug("receiveDataChannel() [options:%o]", options);
          const dataChannel = this._pc.createDataChannel(label, options);
          if (!this._hasDataChannelMediaSection) {
            this._remoteSdp.receiveSctpAssociation({ oldDataChannelSpec: true });
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger13.debug("receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]", offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            if (!this._transportReady) {
              const localSdpObject = sdpTransform.parse(answer.sdp);
              await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                localSdpObject
              });
            }
            logger13.debug("receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setLocalDescription(answer);
            this._hasDataChannelMediaSection = true;
          }
          return { dataChannel };
        }
        async setupTransport({ localDtlsRole, localSdpObject }) {
          if (!localSdpObject) {
            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
          }
          const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
            sdpObject: localSdpObject
          });
          dtlsParameters.role = localDtlsRole;
          this._remoteSdp.updateDtlsRole(localDtlsRole === "client" ? "server" : "client");
          await new Promise((resolve, reject) => {
            this.safeEmit("@connect", { dtlsParameters }, resolve, reject);
          });
          this._transportReady = true;
        }
        assertSendDirection() {
          if (this._direction !== "send") {
            throw new Error('method can just be called for handlers with "send" direction');
          }
        }
        assertRecvDirection() {
          if (this._direction !== "recv") {
            throw new Error('method can just be called for handlers with "recv" direction');
          }
        }
      };
      exports.Chrome55 = Chrome55;
    }
  });

  // ../../node_modules/mediasoup-client/lib/handlers/Firefox120.js
  var require_Firefox120 = __commonJS({
    "../../node_modules/mediasoup-client/lib/handlers/Firefox120.js"(exports) {
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Firefox120 = void 0;
      var sdpTransform = __importStar(require_lib3());
      var Logger_1 = require_Logger();
      var errors_1 = require_errors();
      var utils = __importStar(require_utils());
      var ortc = __importStar(require_ortc());
      var sdpCommonUtils = __importStar(require_commonUtils());
      var sdpUnifiedPlanUtils = __importStar(require_unifiedPlanUtils());
      var HandlerInterface_1 = require_HandlerInterface();
      var RemoteSdp_1 = require_RemoteSdp();
      var scalabilityModes_1 = require_scalabilityModes();
      var logger13 = new Logger_1.Logger("Firefox120");
      var NAME = "Firefox120";
      var SCTP_NUM_STREAMS = { OS: 16, MIS: 2048 };
      var Firefox120 = class _Firefox120 extends HandlerInterface_1.HandlerInterface {
        /**
         * Creates a factory function.
         */
        static createFactory() {
          return () => new _Firefox120();
        }
        constructor() {
          super();
          this._closed = false;
          this._mapMidTransceiver = /* @__PURE__ */ new Map();
          this._sendStream = new MediaStream();
          this._hasDataChannelMediaSection = false;
          this._nextSendSctpStreamId = 0;
          this._transportReady = false;
        }
        get name() {
          return NAME;
        }
        close() {
          logger13.debug("close()");
          if (this._closed) {
            return;
          }
          this._closed = true;
          if (this._pc) {
            try {
              this._pc.close();
            } catch (error) {
            }
          }
          this.emit("@close");
        }
        async getNativeRtpCapabilities() {
          logger13.debug("getNativeRtpCapabilities()");
          const pc = new RTCPeerConnection({
            iceServers: [],
            iceTransportPolicy: "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require"
          });
          const canvas = document.createElement("canvas");
          canvas.getContext("2d");
          const fakeStream = canvas.captureStream();
          const fakeVideoTrack = fakeStream.getVideoTracks()[0];
          try {
            pc.addTransceiver("audio", { direction: "sendrecv" });
            pc.addTransceiver(fakeVideoTrack, {
              direction: "sendrecv",
              sendEncodings: [
                { rid: "r0", maxBitrate: 1e5 },
                { rid: "r1", maxBitrate: 5e5 }
              ]
            });
            const offer = await pc.createOffer();
            try {
              canvas.remove();
            } catch (error) {
            }
            try {
              fakeVideoTrack.stop();
            } catch (error) {
            }
            try {
              pc.close();
            } catch (error) {
            }
            const sdpObject = sdpTransform.parse(offer.sdp);
            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
              sdpObject
            });
            return nativeRtpCapabilities;
          } catch (error) {
            try {
              canvas.remove();
            } catch (error2) {
            }
            try {
              fakeVideoTrack.stop();
            } catch (error2) {
            }
            try {
              pc.close();
            } catch (error2) {
            }
            throw error;
          }
        }
        async getNativeSctpCapabilities() {
          logger13.debug("getNativeSctpCapabilities()");
          return {
            numStreams: SCTP_NUM_STREAMS
          };
        }
        run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities }) {
          this.assertNotClosed();
          logger13.debug("run()");
          this._direction = direction;
          this._remoteSdp = new RemoteSdp_1.RemoteSdp({
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters
          });
          this._sendingRtpParametersByKind = {
            audio: ortc.getSendingRtpParameters("audio", extendedRtpCapabilities),
            video: ortc.getSendingRtpParameters("video", extendedRtpCapabilities)
          };
          this._sendingRemoteRtpParametersByKind = {
            audio: ortc.getSendingRemoteRtpParameters("audio", extendedRtpCapabilities),
            video: ortc.getSendingRemoteRtpParameters("video", extendedRtpCapabilities)
          };
          this._pc = new RTCPeerConnection({
            iceServers: iceServers ?? [],
            iceTransportPolicy: iceTransportPolicy ?? "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require",
            ...additionalSettings
          }, proprietaryConstraints);
          this._pc.addEventListener("icegatheringstatechange", () => {
            this.emit("@icegatheringstatechange", this._pc.iceGatheringState);
          });
          if (this._pc.connectionState) {
            this._pc.addEventListener("connectionstatechange", () => {
              this.emit("@connectionstatechange", this._pc.connectionState);
            });
          } else {
            this._pc.addEventListener("iceconnectionstatechange", () => {
              logger13.warn("run() | pc.connectionState not supported, using pc.iceConnectionState");
              switch (this._pc.iceConnectionState) {
                case "checking": {
                  this.emit("@connectionstatechange", "connecting");
                  break;
                }
                case "connected":
                case "completed": {
                  this.emit("@connectionstatechange", "connected");
                  break;
                }
                case "failed": {
                  this.emit("@connectionstatechange", "failed");
                  break;
                }
                case "disconnected": {
                  this.emit("@connectionstatechange", "disconnected");
                  break;
                }
                case "closed": {
                  this.emit("@connectionstatechange", "closed");
                  break;
                }
              }
            });
          }
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        async updateIceServers(iceServers) {
          this.assertNotClosed();
          throw new errors_1.UnsupportedError("not supported");
        }
        async restartIce(iceParameters) {
          this.assertNotClosed();
          logger13.debug("restartIce()");
          this._remoteSdp.updateIceParameters(iceParameters);
          if (!this._transportReady) {
            return;
          }
          if (this._direction === "send") {
            const offer = await this._pc.createOffer({ iceRestart: true });
            logger13.debug("restartIce() | calling pc.setLocalDescription() [offer:%o]", offer);
            await this._pc.setLocalDescription(offer);
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger13.debug("restartIce() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setRemoteDescription(answer);
          } else {
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger13.debug("restartIce() | calling pc.setRemoteDescription() [offer:%o]", offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger13.debug("restartIce() | calling pc.setLocalDescription() [answer:%o]", answer);
            await this._pc.setLocalDescription(answer);
          }
        }
        async getTransportStats() {
          this.assertNotClosed();
          return this._pc.getStats();
        }
        async send({ track, encodings, codecOptions, codec, onRtpSender }) {
          this.assertNotClosed();
          this.assertSendDirection();
          logger13.debug("send() [kind:%s, track.id:%s]", track.kind, track.id);
          if (encodings && encodings.length > 1) {
            encodings.forEach((encoding, idx) => {
              encoding.rid = `r${idx}`;
            });
          }
          const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);
          sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);
          const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);
          sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);
          const transceiver = this._pc.addTransceiver(track, {
            direction: "sendonly",
            streams: [this._sendStream],
            sendEncodings: encodings
          });
          if (onRtpSender) {
            onRtpSender(transceiver.sender);
          }
          const offer = await this._pc.createOffer();
          let localSdpObject = sdpTransform.parse(offer.sdp);
          if (!this._transportReady) {
            await this.setupTransport({ localDtlsRole: "client", localSdpObject });
          }
          const layers = (0, scalabilityModes_1.parse)((encodings ?? [{}])[0].scalabilityMode);
          logger13.debug("send() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const localId = transceiver.mid;
          sendingRtpParameters.mid = localId;
          localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
          const offerMediaObject = localSdpObject.media[localSdpObject.media.length - 1];
          sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
            offerMediaObject
          });
          if (!encodings) {
            sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({
              offerMediaObject
            });
          } else if (encodings.length === 1) {
            const newEncodings = sdpUnifiedPlanUtils.getRtpEncodings({
              offerMediaObject
            });
            Object.assign(newEncodings[0], encodings[0]);
            sendingRtpParameters.encodings = newEncodings;
          } else {
            sendingRtpParameters.encodings = encodings;
          }
          if (sendingRtpParameters.encodings.length > 1 && (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/vp8" || sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/h264")) {
            for (const encoding of sendingRtpParameters.encodings) {
              if (encoding.scalabilityMode) {
                encoding.scalabilityMode = `L1T${layers.temporalLayers}`;
              } else {
                encoding.scalabilityMode = "L1T3";
              }
            }
          }
          this._remoteSdp.send({
            offerMediaObject,
            offerRtpParameters: sendingRtpParameters,
            answerRtpParameters: sendingRemoteRtpParameters,
            codecOptions,
            extmapAllowMixed: true
          });
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger13.debug("send() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
          this._mapMidTransceiver.set(localId, transceiver);
          return {
            localId,
            rtpParameters: sendingRtpParameters,
            rtpSender: transceiver.sender
          };
        }
        async stopSending(localId) {
          this.assertSendDirection();
          logger13.debug("stopSending() [localId:%s]", localId);
          if (this._closed) {
            return;
          }
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated transceiver not found");
          }
          void transceiver.sender.replaceTrack(null);
          this._pc.removeTrack(transceiver.sender);
          this._remoteSdp.disableMediaSection(transceiver.mid);
          const offer = await this._pc.createOffer();
          logger13.debug("stopSending() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger13.debug("stopSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
          this._mapMidTransceiver.delete(localId);
        }
        async pauseSending(localId) {
          this.assertNotClosed();
          this.assertSendDirection();
          logger13.debug("pauseSending() [localId:%s]", localId);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          transceiver.direction = "inactive";
          this._remoteSdp.pauseMediaSection(localId);
          const offer = await this._pc.createOffer();
          logger13.debug("pauseSending() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger13.debug("pauseSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
        }
        async resumeSending(localId) {
          this.assertNotClosed();
          this.assertSendDirection();
          logger13.debug("resumeSending() [localId:%s]", localId);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          transceiver.direction = "sendonly";
          this._remoteSdp.resumeSendingMediaSection(localId);
          const offer = await this._pc.createOffer();
          logger13.debug("resumeSending() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger13.debug("resumeSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
        }
        async replaceTrack(localId, track) {
          this.assertNotClosed();
          this.assertSendDirection();
          if (track) {
            logger13.debug("replaceTrack() [localId:%s, track.id:%s]", localId, track.id);
          } else {
            logger13.debug("replaceTrack() [localId:%s, no track]", localId);
          }
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          await transceiver.sender.replaceTrack(track);
        }
        async setMaxSpatialLayer(localId, spatialLayer) {
          this.assertNotClosed();
          this.assertSendDirection();
          logger13.debug("setMaxSpatialLayer() [localId:%s, spatialLayer:%s]", localId, spatialLayer);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated transceiver not found");
          }
          const parameters = transceiver.sender.getParameters();
          parameters.encodings.forEach((encoding, idx) => {
            if (idx <= spatialLayer) {
              encoding.active = true;
            } else {
              encoding.active = false;
            }
          });
          await transceiver.sender.setParameters(parameters);
          this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
          const offer = await this._pc.createOffer();
          logger13.debug("setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger13.debug("setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
        }
        async setRtpEncodingParameters(localId, params) {
          this.assertNotClosed();
          this.assertSendDirection();
          logger13.debug("setRtpEncodingParameters() [localId:%s, params:%o]", localId, params);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          const parameters = transceiver.sender.getParameters();
          parameters.encodings.forEach((encoding, idx) => {
            parameters.encodings[idx] = { ...encoding, ...params };
          });
          await transceiver.sender.setParameters(parameters);
          this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
          const offer = await this._pc.createOffer();
          logger13.debug("setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger13.debug("setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
        }
        async getSenderStats(localId) {
          this.assertNotClosed();
          this.assertSendDirection();
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          return transceiver.sender.getStats();
        }
        async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol }) {
          this.assertNotClosed();
          this.assertSendDirection();
          const options = {
            negotiated: true,
            id: this._nextSendSctpStreamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol
          };
          logger13.debug("sendDataChannel() [options:%o]", options);
          const dataChannel = this._pc.createDataChannel(label, options);
          this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
          if (!this._hasDataChannelMediaSection) {
            const offer = await this._pc.createOffer();
            const localSdpObject = sdpTransform.parse(offer.sdp);
            const offerMediaObject = localSdpObject.media.find((m) => m.type === "application");
            if (!this._transportReady) {
              await this.setupTransport({ localDtlsRole: "client", localSdpObject });
            }
            logger13.debug("sendDataChannel() | calling pc.setLocalDescription() [offer:%o]", offer);
            await this._pc.setLocalDescription(offer);
            this._remoteSdp.sendSctpAssociation({ offerMediaObject });
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger13.debug("sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setRemoteDescription(answer);
            this._hasDataChannelMediaSection = true;
          }
          const sctpStreamParameters = {
            streamId: options.id,
            ordered: options.ordered,
            maxPacketLifeTime: options.maxPacketLifeTime,
            maxRetransmits: options.maxRetransmits
          };
          return { dataChannel, sctpStreamParameters };
        }
        async receive(optionsList) {
          this.assertNotClosed();
          this.assertRecvDirection();
          const results = [];
          const mapLocalId = /* @__PURE__ */ new Map();
          for (const options of optionsList) {
            const { trackId, kind, rtpParameters, streamId } = options;
            logger13.debug("receive() [trackId:%s, kind:%s]", trackId, kind);
            const localId = rtpParameters.mid ?? String(this._mapMidTransceiver.size);
            mapLocalId.set(trackId, localId);
            this._remoteSdp.receive({
              mid: localId,
              kind,
              offerRtpParameters: rtpParameters,
              streamId: streamId ?? rtpParameters.rtcp.cname,
              trackId
            });
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger13.debug("receive() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          for (const options of optionsList) {
            const { trackId, onRtpReceiver } = options;
            if (onRtpReceiver) {
              const localId = mapLocalId.get(trackId);
              const transceiver = this._pc.getTransceivers().find((t) => t.mid === localId);
              if (!transceiver) {
                throw new Error("transceiver not found");
              }
              onRtpReceiver(transceiver.receiver);
            }
          }
          let answer = await this._pc.createAnswer();
          const localSdpObject = sdpTransform.parse(answer.sdp);
          for (const options of optionsList) {
            const { trackId, rtpParameters } = options;
            const localId = mapLocalId.get(trackId);
            const answerMediaObject = localSdpObject.media.find((m) => String(m.mid) === localId);
            sdpCommonUtils.applyCodecParameters({
              offerRtpParameters: rtpParameters,
              answerMediaObject
            });
            answer = { type: "answer", sdp: sdpTransform.write(localSdpObject) };
          }
          if (!this._transportReady) {
            await this.setupTransport({ localDtlsRole: "client", localSdpObject });
          }
          logger13.debug("receive() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
          for (const options of optionsList) {
            const { trackId } = options;
            const localId = mapLocalId.get(trackId);
            const transceiver = this._pc.getTransceivers().find((t) => t.mid === localId);
            if (!transceiver) {
              throw new Error("new RTCRtpTransceiver not found");
            }
            this._mapMidTransceiver.set(localId, transceiver);
            results.push({
              localId,
              track: transceiver.receiver.track,
              rtpReceiver: transceiver.receiver
            });
          }
          return results;
        }
        async stopReceiving(localIds) {
          this.assertRecvDirection();
          if (this._closed) {
            return;
          }
          for (const localId of localIds) {
            logger13.debug("stopReceiving() [localId:%s]", localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            this._remoteSdp.closeMediaSection(transceiver.mid);
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger13.debug("stopReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          const answer = await this._pc.createAnswer();
          logger13.debug("stopReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
          for (const localId of localIds) {
            this._mapMidTransceiver.delete(localId);
          }
        }
        async pauseReceiving(localIds) {
          this.assertNotClosed();
          this.assertRecvDirection();
          for (const localId of localIds) {
            logger13.debug("pauseReceiving() [localId:%s]", localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            transceiver.direction = "inactive";
            this._remoteSdp.pauseMediaSection(localId);
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger13.debug("pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          const answer = await this._pc.createAnswer();
          logger13.debug("pauseReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
        }
        async resumeReceiving(localIds) {
          this.assertNotClosed();
          this.assertRecvDirection();
          for (const localId of localIds) {
            logger13.debug("resumeReceiving() [localId:%s]", localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            transceiver.direction = "recvonly";
            this._remoteSdp.resumeReceivingMediaSection(localId);
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger13.debug("resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          const answer = await this._pc.createAnswer();
          logger13.debug("resumeReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
        }
        async getReceiverStats(localId) {
          this.assertRecvDirection();
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          return transceiver.receiver.getStats();
        }
        async receiveDataChannel({ sctpStreamParameters, label, protocol }) {
          this.assertNotClosed();
          this.assertRecvDirection();
          const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;
          const options = {
            negotiated: true,
            id: streamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol
          };
          logger13.debug("receiveDataChannel() [options:%o]", options);
          const dataChannel = this._pc.createDataChannel(label, options);
          if (!this._hasDataChannelMediaSection) {
            this._remoteSdp.receiveSctpAssociation();
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger13.debug("receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]", offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            if (!this._transportReady) {
              const localSdpObject = sdpTransform.parse(answer.sdp);
              await this.setupTransport({ localDtlsRole: "client", localSdpObject });
            }
            logger13.debug("receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setLocalDescription(answer);
            this._hasDataChannelMediaSection = true;
          }
          return { dataChannel };
        }
        async setupTransport({ localDtlsRole, localSdpObject }) {
          if (!localSdpObject) {
            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
          }
          const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
            sdpObject: localSdpObject
          });
          dtlsParameters.role = localDtlsRole;
          this._remoteSdp.updateDtlsRole(localDtlsRole === "client" ? "server" : "client");
          await new Promise((resolve, reject) => {
            this.safeEmit("@connect", { dtlsParameters }, resolve, reject);
          });
          this._transportReady = true;
        }
        assertNotClosed() {
          if (this._closed) {
            throw new errors_1.InvalidStateError("method called in a closed handler");
          }
        }
        assertSendDirection() {
          if (this._direction !== "send") {
            throw new Error('method can just be called for handlers with "send" direction');
          }
        }
        assertRecvDirection() {
          if (this._direction !== "recv") {
            throw new Error('method can just be called for handlers with "recv" direction');
          }
        }
      };
      exports.Firefox120 = Firefox120;
    }
  });

  // ../../node_modules/mediasoup-client/lib/handlers/Firefox60.js
  var require_Firefox60 = __commonJS({
    "../../node_modules/mediasoup-client/lib/handlers/Firefox60.js"(exports) {
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Firefox60 = void 0;
      var sdpTransform = __importStar(require_lib3());
      var Logger_1 = require_Logger();
      var errors_1 = require_errors();
      var utils = __importStar(require_utils());
      var ortc = __importStar(require_ortc());
      var sdpCommonUtils = __importStar(require_commonUtils());
      var sdpUnifiedPlanUtils = __importStar(require_unifiedPlanUtils());
      var HandlerInterface_1 = require_HandlerInterface();
      var RemoteSdp_1 = require_RemoteSdp();
      var scalabilityModes_1 = require_scalabilityModes();
      var logger13 = new Logger_1.Logger("Firefox60");
      var NAME = "Firefox60";
      var SCTP_NUM_STREAMS = { OS: 16, MIS: 2048 };
      var Firefox60 = class _Firefox60 extends HandlerInterface_1.HandlerInterface {
        /**
         * Creates a factory function.
         */
        static createFactory() {
          return () => new _Firefox60();
        }
        constructor() {
          super();
          this._closed = false;
          this._mapMidTransceiver = /* @__PURE__ */ new Map();
          this._sendStream = new MediaStream();
          this._hasDataChannelMediaSection = false;
          this._nextSendSctpStreamId = 0;
          this._transportReady = false;
        }
        get name() {
          return NAME;
        }
        close() {
          logger13.debug("close()");
          if (this._closed) {
            return;
          }
          this._closed = true;
          if (this._pc) {
            try {
              this._pc.close();
            } catch (error) {
            }
          }
          this.emit("@close");
        }
        async getNativeRtpCapabilities() {
          logger13.debug("getNativeRtpCapabilities()");
          const pc = new RTCPeerConnection({
            iceServers: [],
            iceTransportPolicy: "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require"
          });
          const canvas = document.createElement("canvas");
          canvas.getContext("2d");
          const fakeStream = canvas.captureStream();
          const fakeVideoTrack = fakeStream.getVideoTracks()[0];
          try {
            pc.addTransceiver("audio", { direction: "sendrecv" });
            const videoTransceiver = pc.addTransceiver(fakeVideoTrack, {
              direction: "sendrecv"
            });
            const parameters = videoTransceiver.sender.getParameters();
            const encodings = [
              { rid: "r0", maxBitrate: 1e5 },
              { rid: "r1", maxBitrate: 5e5 }
            ];
            parameters.encodings = encodings;
            await videoTransceiver.sender.setParameters(parameters);
            const offer = await pc.createOffer();
            try {
              canvas.remove();
            } catch (error) {
            }
            try {
              fakeVideoTrack.stop();
            } catch (error) {
            }
            try {
              pc.close();
            } catch (error) {
            }
            const sdpObject = sdpTransform.parse(offer.sdp);
            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
              sdpObject
            });
            return nativeRtpCapabilities;
          } catch (error) {
            try {
              canvas.remove();
            } catch (error2) {
            }
            try {
              fakeVideoTrack.stop();
            } catch (error2) {
            }
            try {
              pc.close();
            } catch (error2) {
            }
            throw error;
          }
        }
        async getNativeSctpCapabilities() {
          logger13.debug("getNativeSctpCapabilities()");
          return {
            numStreams: SCTP_NUM_STREAMS
          };
        }
        run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities }) {
          this.assertNotClosed();
          logger13.debug("run()");
          this._direction = direction;
          this._remoteSdp = new RemoteSdp_1.RemoteSdp({
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters
          });
          this._sendingRtpParametersByKind = {
            audio: ortc.getSendingRtpParameters("audio", extendedRtpCapabilities),
            video: ortc.getSendingRtpParameters("video", extendedRtpCapabilities)
          };
          this._sendingRemoteRtpParametersByKind = {
            audio: ortc.getSendingRemoteRtpParameters("audio", extendedRtpCapabilities),
            video: ortc.getSendingRemoteRtpParameters("video", extendedRtpCapabilities)
          };
          this._pc = new RTCPeerConnection({
            iceServers: iceServers ?? [],
            iceTransportPolicy: iceTransportPolicy ?? "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require",
            ...additionalSettings
          }, proprietaryConstraints);
          this._pc.addEventListener("icegatheringstatechange", () => {
            this.emit("@icegatheringstatechange", this._pc.iceGatheringState);
          });
          if (this._pc.connectionState) {
            this._pc.addEventListener("connectionstatechange", () => {
              this.emit("@connectionstatechange", this._pc.connectionState);
            });
          } else {
            this._pc.addEventListener("iceconnectionstatechange", () => {
              logger13.warn("run() | pc.connectionState not supported, using pc.iceConnectionState");
              switch (this._pc.iceConnectionState) {
                case "checking": {
                  this.emit("@connectionstatechange", "connecting");
                  break;
                }
                case "connected":
                case "completed": {
                  this.emit("@connectionstatechange", "connected");
                  break;
                }
                case "failed": {
                  this.emit("@connectionstatechange", "failed");
                  break;
                }
                case "disconnected": {
                  this.emit("@connectionstatechange", "disconnected");
                  break;
                }
                case "closed": {
                  this.emit("@connectionstatechange", "closed");
                  break;
                }
              }
            });
          }
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        async updateIceServers(iceServers) {
          this.assertNotClosed();
          throw new errors_1.UnsupportedError("not supported");
        }
        async restartIce(iceParameters) {
          this.assertNotClosed();
          logger13.debug("restartIce()");
          this._remoteSdp.updateIceParameters(iceParameters);
          if (!this._transportReady) {
            return;
          }
          if (this._direction === "send") {
            const offer = await this._pc.createOffer({ iceRestart: true });
            logger13.debug("restartIce() | calling pc.setLocalDescription() [offer:%o]", offer);
            await this._pc.setLocalDescription(offer);
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger13.debug("restartIce() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setRemoteDescription(answer);
          } else {
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger13.debug("restartIce() | calling pc.setRemoteDescription() [offer:%o]", offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger13.debug("restartIce() | calling pc.setLocalDescription() [answer:%o]", answer);
            await this._pc.setLocalDescription(answer);
          }
        }
        async getTransportStats() {
          this.assertNotClosed();
          return this._pc.getStats();
        }
        async send({ track, encodings, codecOptions, codec }) {
          this.assertNotClosed();
          this.assertSendDirection();
          logger13.debug("send() [kind:%s, track.id:%s]", track.kind, track.id);
          if (encodings) {
            encodings = utils.clone(encodings);
            encodings.forEach((encoding, idx) => {
              encoding.rid = `r${idx}`;
            });
            encodings.reverse();
          }
          const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);
          sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);
          const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);
          sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);
          const transceiver = this._pc.addTransceiver(track, {
            direction: "sendonly",
            streams: [this._sendStream]
          });
          if (encodings) {
            const parameters = transceiver.sender.getParameters();
            parameters.encodings = encodings;
            await transceiver.sender.setParameters(parameters);
          }
          const offer = await this._pc.createOffer();
          let localSdpObject = sdpTransform.parse(offer.sdp);
          if (!this._transportReady) {
            await this.setupTransport({ localDtlsRole: "client", localSdpObject });
          }
          const layers = (0, scalabilityModes_1.parse)((encodings ?? [{}])[0].scalabilityMode);
          logger13.debug("send() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const localId = transceiver.mid;
          sendingRtpParameters.mid = localId;
          localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
          const offerMediaObject = localSdpObject.media[localSdpObject.media.length - 1];
          sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
            offerMediaObject
          });
          if (!encodings) {
            sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({
              offerMediaObject
            });
          } else if (encodings.length === 1) {
            const newEncodings = sdpUnifiedPlanUtils.getRtpEncodings({
              offerMediaObject
            });
            Object.assign(newEncodings[0], encodings[0]);
            sendingRtpParameters.encodings = newEncodings;
          } else {
            sendingRtpParameters.encodings = encodings.reverse();
          }
          if (sendingRtpParameters.encodings.length > 1 && (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/vp8" || sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/h264")) {
            for (const encoding of sendingRtpParameters.encodings) {
              if (encoding.scalabilityMode) {
                encoding.scalabilityMode = `L1T${layers.temporalLayers}`;
              } else {
                encoding.scalabilityMode = "L1T3";
              }
            }
          }
          this._remoteSdp.send({
            offerMediaObject,
            offerRtpParameters: sendingRtpParameters,
            answerRtpParameters: sendingRemoteRtpParameters,
            codecOptions,
            extmapAllowMixed: true
          });
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger13.debug("send() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
          this._mapMidTransceiver.set(localId, transceiver);
          return {
            localId,
            rtpParameters: sendingRtpParameters,
            rtpSender: transceiver.sender
          };
        }
        async stopSending(localId) {
          this.assertSendDirection();
          logger13.debug("stopSending() [localId:%s]", localId);
          if (this._closed) {
            return;
          }
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated transceiver not found");
          }
          void transceiver.sender.replaceTrack(null);
          this._pc.removeTrack(transceiver.sender);
          this._remoteSdp.disableMediaSection(transceiver.mid);
          const offer = await this._pc.createOffer();
          logger13.debug("stopSending() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger13.debug("stopSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
          this._mapMidTransceiver.delete(localId);
        }
        async pauseSending(localId) {
          this.assertNotClosed();
          this.assertSendDirection();
          logger13.debug("pauseSending() [localId:%s]", localId);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          transceiver.direction = "inactive";
          this._remoteSdp.pauseMediaSection(localId);
          const offer = await this._pc.createOffer();
          logger13.debug("pauseSending() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger13.debug("pauseSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
        }
        async resumeSending(localId) {
          this.assertNotClosed();
          this.assertSendDirection();
          logger13.debug("resumeSending() [localId:%s]", localId);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          transceiver.direction = "sendonly";
          this._remoteSdp.resumeSendingMediaSection(localId);
          const offer = await this._pc.createOffer();
          logger13.debug("resumeSending() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger13.debug("resumeSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
        }
        async replaceTrack(localId, track) {
          this.assertNotClosed();
          this.assertSendDirection();
          if (track) {
            logger13.debug("replaceTrack() [localId:%s, track.id:%s]", localId, track.id);
          } else {
            logger13.debug("replaceTrack() [localId:%s, no track]", localId);
          }
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          await transceiver.sender.replaceTrack(track);
        }
        async setMaxSpatialLayer(localId, spatialLayer) {
          this.assertNotClosed();
          this.assertSendDirection();
          logger13.debug("setMaxSpatialLayer() [localId:%s, spatialLayer:%s]", localId, spatialLayer);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated transceiver not found");
          }
          const parameters = transceiver.sender.getParameters();
          spatialLayer = parameters.encodings.length - 1 - spatialLayer;
          parameters.encodings.forEach((encoding, idx) => {
            if (idx >= spatialLayer) {
              encoding.active = true;
            } else {
              encoding.active = false;
            }
          });
          await transceiver.sender.setParameters(parameters);
          this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
          const offer = await this._pc.createOffer();
          logger13.debug("setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger13.debug("setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
        }
        async setRtpEncodingParameters(localId, params) {
          this.assertNotClosed();
          this.assertSendDirection();
          logger13.debug("setRtpEncodingParameters() [localId:%s, params:%o]", localId, params);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          const parameters = transceiver.sender.getParameters();
          parameters.encodings.forEach((encoding, idx) => {
            parameters.encodings[idx] = { ...encoding, ...params };
          });
          await transceiver.sender.setParameters(parameters);
          this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
          const offer = await this._pc.createOffer();
          logger13.debug("setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger13.debug("setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
        }
        async getSenderStats(localId) {
          this.assertNotClosed();
          this.assertSendDirection();
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          return transceiver.sender.getStats();
        }
        async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol }) {
          this.assertNotClosed();
          this.assertSendDirection();
          const options = {
            negotiated: true,
            id: this._nextSendSctpStreamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol
          };
          logger13.debug("sendDataChannel() [options:%o]", options);
          const dataChannel = this._pc.createDataChannel(label, options);
          this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
          if (!this._hasDataChannelMediaSection) {
            const offer = await this._pc.createOffer();
            const localSdpObject = sdpTransform.parse(offer.sdp);
            const offerMediaObject = localSdpObject.media.find((m) => m.type === "application");
            if (!this._transportReady) {
              await this.setupTransport({ localDtlsRole: "client", localSdpObject });
            }
            logger13.debug("sendDataChannel() | calling pc.setLocalDescription() [offer:%o]", offer);
            await this._pc.setLocalDescription(offer);
            this._remoteSdp.sendSctpAssociation({ offerMediaObject });
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger13.debug("sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setRemoteDescription(answer);
            this._hasDataChannelMediaSection = true;
          }
          const sctpStreamParameters = {
            streamId: options.id,
            ordered: options.ordered,
            maxPacketLifeTime: options.maxPacketLifeTime,
            maxRetransmits: options.maxRetransmits
          };
          return { dataChannel, sctpStreamParameters };
        }
        async receive(optionsList) {
          this.assertNotClosed();
          this.assertRecvDirection();
          const results = [];
          const mapLocalId = /* @__PURE__ */ new Map();
          for (const options of optionsList) {
            const { trackId, kind, rtpParameters, streamId } = options;
            logger13.debug("receive() [trackId:%s, kind:%s]", trackId, kind);
            const localId = rtpParameters.mid ?? String(this._mapMidTransceiver.size);
            mapLocalId.set(trackId, localId);
            this._remoteSdp.receive({
              mid: localId,
              kind,
              offerRtpParameters: rtpParameters,
              streamId: streamId ?? rtpParameters.rtcp.cname,
              trackId
            });
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger13.debug("receive() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          let answer = await this._pc.createAnswer();
          const localSdpObject = sdpTransform.parse(answer.sdp);
          for (const options of optionsList) {
            const { trackId, rtpParameters } = options;
            const localId = mapLocalId.get(trackId);
            const answerMediaObject = localSdpObject.media.find((m) => String(m.mid) === localId);
            sdpCommonUtils.applyCodecParameters({
              offerRtpParameters: rtpParameters,
              answerMediaObject
            });
            answer = { type: "answer", sdp: sdpTransform.write(localSdpObject) };
          }
          if (!this._transportReady) {
            await this.setupTransport({ localDtlsRole: "client", localSdpObject });
          }
          logger13.debug("receive() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
          for (const options of optionsList) {
            const { trackId } = options;
            const localId = mapLocalId.get(trackId);
            const transceiver = this._pc.getTransceivers().find((t) => t.mid === localId);
            if (!transceiver) {
              throw new Error("new RTCRtpTransceiver not found");
            }
            this._mapMidTransceiver.set(localId, transceiver);
            results.push({
              localId,
              track: transceiver.receiver.track,
              rtpReceiver: transceiver.receiver
            });
          }
          return results;
        }
        async stopReceiving(localIds) {
          this.assertRecvDirection();
          if (this._closed) {
            return;
          }
          for (const localId of localIds) {
            logger13.debug("stopReceiving() [localId:%s]", localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            this._remoteSdp.closeMediaSection(transceiver.mid);
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger13.debug("stopReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          const answer = await this._pc.createAnswer();
          logger13.debug("stopReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
          for (const localId of localIds) {
            this._mapMidTransceiver.delete(localId);
          }
        }
        async pauseReceiving(localIds) {
          this.assertNotClosed();
          this.assertRecvDirection();
          for (const localId of localIds) {
            logger13.debug("pauseReceiving() [localId:%s]", localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            transceiver.direction = "inactive";
            this._remoteSdp.pauseMediaSection(localId);
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger13.debug("pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          const answer = await this._pc.createAnswer();
          logger13.debug("pauseReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
        }
        async resumeReceiving(localIds) {
          this.assertNotClosed();
          this.assertRecvDirection();
          for (const localId of localIds) {
            logger13.debug("resumeReceiving() [localId:%s]", localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            transceiver.direction = "recvonly";
            this._remoteSdp.resumeReceivingMediaSection(localId);
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger13.debug("resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          const answer = await this._pc.createAnswer();
          logger13.debug("resumeReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
        }
        async getReceiverStats(localId) {
          this.assertRecvDirection();
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          return transceiver.receiver.getStats();
        }
        async receiveDataChannel({ sctpStreamParameters, label, protocol }) {
          this.assertNotClosed();
          this.assertRecvDirection();
          const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;
          const options = {
            negotiated: true,
            id: streamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol
          };
          logger13.debug("receiveDataChannel() [options:%o]", options);
          const dataChannel = this._pc.createDataChannel(label, options);
          if (!this._hasDataChannelMediaSection) {
            this._remoteSdp.receiveSctpAssociation();
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger13.debug("receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]", offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            if (!this._transportReady) {
              const localSdpObject = sdpTransform.parse(answer.sdp);
              await this.setupTransport({ localDtlsRole: "client", localSdpObject });
            }
            logger13.debug("receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setLocalDescription(answer);
            this._hasDataChannelMediaSection = true;
          }
          return { dataChannel };
        }
        async setupTransport({ localDtlsRole, localSdpObject }) {
          if (!localSdpObject) {
            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
          }
          const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
            sdpObject: localSdpObject
          });
          dtlsParameters.role = localDtlsRole;
          this._remoteSdp.updateDtlsRole(localDtlsRole === "client" ? "server" : "client");
          await new Promise((resolve, reject) => {
            this.safeEmit("@connect", { dtlsParameters }, resolve, reject);
          });
          this._transportReady = true;
        }
        assertNotClosed() {
          if (this._closed) {
            throw new errors_1.InvalidStateError("method called in a closed handler");
          }
        }
        assertSendDirection() {
          if (this._direction !== "send") {
            throw new Error('method can just be called for handlers with "send" direction');
          }
        }
        assertRecvDirection() {
          if (this._direction !== "recv") {
            throw new Error('method can just be called for handlers with "recv" direction');
          }
        }
      };
      exports.Firefox60 = Firefox60;
    }
  });

  // ../../node_modules/mediasoup-client/lib/handlers/Safari12.js
  var require_Safari12 = __commonJS({
    "../../node_modules/mediasoup-client/lib/handlers/Safari12.js"(exports) {
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Safari12 = void 0;
      var sdpTransform = __importStar(require_lib3());
      var Logger_1 = require_Logger();
      var utils = __importStar(require_utils());
      var ortc = __importStar(require_ortc());
      var sdpCommonUtils = __importStar(require_commonUtils());
      var sdpUnifiedPlanUtils = __importStar(require_unifiedPlanUtils());
      var ortcUtils = __importStar(require_utils2());
      var errors_1 = require_errors();
      var HandlerInterface_1 = require_HandlerInterface();
      var RemoteSdp_1 = require_RemoteSdp();
      var scalabilityModes_1 = require_scalabilityModes();
      var logger13 = new Logger_1.Logger("Safari12");
      var NAME = "Safari12";
      var SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };
      var Safari12 = class _Safari12 extends HandlerInterface_1.HandlerInterface {
        /**
         * Creates a factory function.
         */
        static createFactory() {
          return () => new _Safari12();
        }
        constructor() {
          super();
          this._closed = false;
          this._mapMidTransceiver = /* @__PURE__ */ new Map();
          this._sendStream = new MediaStream();
          this._hasDataChannelMediaSection = false;
          this._nextSendSctpStreamId = 0;
          this._transportReady = false;
        }
        get name() {
          return NAME;
        }
        close() {
          logger13.debug("close()");
          if (this._closed) {
            return;
          }
          this._closed = true;
          if (this._pc) {
            try {
              this._pc.close();
            } catch (error) {
            }
          }
          this.emit("@close");
        }
        async getNativeRtpCapabilities() {
          logger13.debug("getNativeRtpCapabilities()");
          const pc = new RTCPeerConnection({
            iceServers: [],
            iceTransportPolicy: "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require"
          });
          try {
            pc.addTransceiver("audio");
            pc.addTransceiver("video");
            const offer = await pc.createOffer();
            try {
              pc.close();
            } catch (error) {
            }
            const sdpObject = sdpTransform.parse(offer.sdp);
            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
              sdpObject
            });
            ortcUtils.addNackSuppportForOpus(nativeRtpCapabilities);
            return nativeRtpCapabilities;
          } catch (error) {
            try {
              pc.close();
            } catch (error2) {
            }
            throw error;
          }
        }
        async getNativeSctpCapabilities() {
          logger13.debug("getNativeSctpCapabilities()");
          return {
            numStreams: SCTP_NUM_STREAMS
          };
        }
        run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities }) {
          this.assertNotClosed();
          logger13.debug("run()");
          this._direction = direction;
          this._remoteSdp = new RemoteSdp_1.RemoteSdp({
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters
          });
          this._sendingRtpParametersByKind = {
            audio: ortc.getSendingRtpParameters("audio", extendedRtpCapabilities),
            video: ortc.getSendingRtpParameters("video", extendedRtpCapabilities)
          };
          this._sendingRemoteRtpParametersByKind = {
            audio: ortc.getSendingRemoteRtpParameters("audio", extendedRtpCapabilities),
            video: ortc.getSendingRemoteRtpParameters("video", extendedRtpCapabilities)
          };
          if (dtlsParameters.role && dtlsParameters.role !== "auto") {
            this._forcedLocalDtlsRole = dtlsParameters.role === "server" ? "client" : "server";
          }
          this._pc = new RTCPeerConnection({
            iceServers: iceServers ?? [],
            iceTransportPolicy: iceTransportPolicy ?? "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require",
            ...additionalSettings
          }, proprietaryConstraints);
          this._pc.addEventListener("icegatheringstatechange", () => {
            this.emit("@icegatheringstatechange", this._pc.iceGatheringState);
          });
          if (this._pc.connectionState) {
            this._pc.addEventListener("connectionstatechange", () => {
              this.emit("@connectionstatechange", this._pc.connectionState);
            });
          } else {
            this._pc.addEventListener("iceconnectionstatechange", () => {
              logger13.warn("run() | pc.connectionState not supported, using pc.iceConnectionState");
              switch (this._pc.iceConnectionState) {
                case "checking": {
                  this.emit("@connectionstatechange", "connecting");
                  break;
                }
                case "connected":
                case "completed": {
                  this.emit("@connectionstatechange", "connected");
                  break;
                }
                case "failed": {
                  this.emit("@connectionstatechange", "failed");
                  break;
                }
                case "disconnected": {
                  this.emit("@connectionstatechange", "disconnected");
                  break;
                }
                case "closed": {
                  this.emit("@connectionstatechange", "closed");
                  break;
                }
              }
            });
          }
        }
        async updateIceServers(iceServers) {
          this.assertNotClosed();
          logger13.debug("updateIceServers()");
          const configuration = this._pc.getConfiguration();
          configuration.iceServers = iceServers;
          this._pc.setConfiguration(configuration);
        }
        async restartIce(iceParameters) {
          this.assertNotClosed();
          logger13.debug("restartIce()");
          this._remoteSdp.updateIceParameters(iceParameters);
          if (!this._transportReady) {
            return;
          }
          if (this._direction === "send") {
            const offer = await this._pc.createOffer({ iceRestart: true });
            logger13.debug("restartIce() | calling pc.setLocalDescription() [offer:%o]", offer);
            await this._pc.setLocalDescription(offer);
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger13.debug("restartIce() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setRemoteDescription(answer);
          } else {
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger13.debug("restartIce() | calling pc.setRemoteDescription() [offer:%o]", offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger13.debug("restartIce() | calling pc.setLocalDescription() [answer:%o]", answer);
            await this._pc.setLocalDescription(answer);
          }
        }
        async getTransportStats() {
          this.assertNotClosed();
          return this._pc.getStats();
        }
        async send({ track, encodings, codecOptions, codec, onRtpSender }) {
          this.assertNotClosed();
          this.assertSendDirection();
          logger13.debug("send() [kind:%s, track.id:%s]", track.kind, track.id);
          const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);
          sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);
          const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);
          sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);
          const mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();
          const transceiver = this._pc.addTransceiver(track, {
            direction: "sendonly",
            streams: [this._sendStream]
          });
          if (onRtpSender) {
            onRtpSender(transceiver.sender);
          }
          let offer = await this._pc.createOffer();
          let localSdpObject = sdpTransform.parse(offer.sdp);
          let offerMediaObject;
          if (!this._transportReady) {
            await this.setupTransport({
              localDtlsRole: this._forcedLocalDtlsRole ?? "client",
              localSdpObject
            });
          }
          const layers = (0, scalabilityModes_1.parse)((encodings ?? [{}])[0].scalabilityMode);
          if (encodings && encodings.length > 1) {
            logger13.debug("send() | enabling legacy simulcast");
            localSdpObject = sdpTransform.parse(offer.sdp);
            offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
            sdpUnifiedPlanUtils.addLegacySimulcast({
              offerMediaObject,
              numStreams: encodings.length
            });
            offer = { type: "offer", sdp: sdpTransform.write(localSdpObject) };
          }
          logger13.debug("send() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const localId = transceiver.mid;
          sendingRtpParameters.mid = localId;
          localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
          offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
          sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
            offerMediaObject
          });
          sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({
            offerMediaObject
          });
          if (encodings) {
            for (let idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {
              if (encodings[idx]) {
                Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);
              }
            }
          }
          if (sendingRtpParameters.encodings.length > 1 && (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/vp8" || sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/h264")) {
            for (const encoding of sendingRtpParameters.encodings) {
              if (encoding.scalabilityMode) {
                encoding.scalabilityMode = `L1T${layers.temporalLayers}`;
              } else {
                encoding.scalabilityMode = "L1T3";
              }
            }
          }
          this._remoteSdp.send({
            offerMediaObject,
            reuseMid: mediaSectionIdx.reuseMid,
            offerRtpParameters: sendingRtpParameters,
            answerRtpParameters: sendingRemoteRtpParameters,
            codecOptions
          });
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger13.debug("send() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
          this._mapMidTransceiver.set(localId, transceiver);
          return {
            localId,
            rtpParameters: sendingRtpParameters,
            rtpSender: transceiver.sender
          };
        }
        async stopSending(localId) {
          this.assertSendDirection();
          if (this._closed) {
            return;
          }
          logger13.debug("stopSending() [localId:%s]", localId);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          void transceiver.sender.replaceTrack(null);
          this._pc.removeTrack(transceiver.sender);
          const mediaSectionClosed = this._remoteSdp.closeMediaSection(transceiver.mid);
          if (mediaSectionClosed) {
            try {
              transceiver.stop();
            } catch (error) {
            }
          }
          const offer = await this._pc.createOffer();
          logger13.debug("stopSending() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger13.debug("stopSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
          this._mapMidTransceiver.delete(localId);
        }
        async pauseSending(localId) {
          this.assertNotClosed();
          this.assertSendDirection();
          logger13.debug("pauseSending() [localId:%s]", localId);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          transceiver.direction = "inactive";
          this._remoteSdp.pauseMediaSection(localId);
          const offer = await this._pc.createOffer();
          logger13.debug("pauseSending() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger13.debug("pauseSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
        }
        async resumeSending(localId) {
          this.assertNotClosed();
          this.assertSendDirection();
          logger13.debug("resumeSending() [localId:%s]", localId);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          transceiver.direction = "sendonly";
          this._remoteSdp.resumeSendingMediaSection(localId);
          const offer = await this._pc.createOffer();
          logger13.debug("resumeSending() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger13.debug("resumeSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
        }
        async replaceTrack(localId, track) {
          this.assertNotClosed();
          this.assertSendDirection();
          if (track) {
            logger13.debug("replaceTrack() [localId:%s, track.id:%s]", localId, track.id);
          } else {
            logger13.debug("replaceTrack() [localId:%s, no track]", localId);
          }
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          await transceiver.sender.replaceTrack(track);
        }
        async setMaxSpatialLayer(localId, spatialLayer) {
          this.assertNotClosed();
          this.assertSendDirection();
          logger13.debug("setMaxSpatialLayer() [localId:%s, spatialLayer:%s]", localId, spatialLayer);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          const parameters = transceiver.sender.getParameters();
          parameters.encodings.forEach((encoding, idx) => {
            if (idx <= spatialLayer) {
              encoding.active = true;
            } else {
              encoding.active = false;
            }
          });
          await transceiver.sender.setParameters(parameters);
          this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
          const offer = await this._pc.createOffer();
          logger13.debug("setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger13.debug("setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
        }
        async setRtpEncodingParameters(localId, params) {
          this.assertNotClosed();
          this.assertSendDirection();
          logger13.debug("setRtpEncodingParameters() [localId:%s, params:%o]", localId, params);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          const parameters = transceiver.sender.getParameters();
          parameters.encodings.forEach((encoding, idx) => {
            parameters.encodings[idx] = { ...encoding, ...params };
          });
          await transceiver.sender.setParameters(parameters);
          this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
          const offer = await this._pc.createOffer();
          logger13.debug("setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger13.debug("setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
        }
        async getSenderStats(localId) {
          this.assertNotClosed();
          this.assertSendDirection();
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          return transceiver.sender.getStats();
        }
        async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol }) {
          this.assertNotClosed();
          this.assertSendDirection();
          const options = {
            negotiated: true,
            id: this._nextSendSctpStreamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol
          };
          logger13.debug("sendDataChannel() [options:%o]", options);
          const dataChannel = this._pc.createDataChannel(label, options);
          this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
          if (!this._hasDataChannelMediaSection) {
            const offer = await this._pc.createOffer();
            const localSdpObject = sdpTransform.parse(offer.sdp);
            const offerMediaObject = localSdpObject.media.find((m) => m.type === "application");
            if (!this._transportReady) {
              await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                localSdpObject
              });
            }
            logger13.debug("sendDataChannel() | calling pc.setLocalDescription() [offer:%o]", offer);
            await this._pc.setLocalDescription(offer);
            this._remoteSdp.sendSctpAssociation({ offerMediaObject });
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger13.debug("sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setRemoteDescription(answer);
            this._hasDataChannelMediaSection = true;
          }
          const sctpStreamParameters = {
            streamId: options.id,
            ordered: options.ordered,
            maxPacketLifeTime: options.maxPacketLifeTime,
            maxRetransmits: options.maxRetransmits
          };
          return { dataChannel, sctpStreamParameters };
        }
        async receive(optionsList) {
          this.assertNotClosed();
          this.assertRecvDirection();
          const results = [];
          const mapLocalId = /* @__PURE__ */ new Map();
          for (const options of optionsList) {
            const { trackId, kind, rtpParameters, streamId } = options;
            logger13.debug("receive() [trackId:%s, kind:%s]", trackId, kind);
            const localId = rtpParameters.mid ?? String(this._mapMidTransceiver.size);
            mapLocalId.set(trackId, localId);
            this._remoteSdp.receive({
              mid: localId,
              kind,
              offerRtpParameters: rtpParameters,
              streamId: streamId ?? rtpParameters.rtcp.cname,
              trackId
            });
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger13.debug("receive() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          for (const options of optionsList) {
            const { trackId, onRtpReceiver } = options;
            if (onRtpReceiver) {
              const localId = mapLocalId.get(trackId);
              const transceiver = this._pc.getTransceivers().find((t) => t.mid === localId);
              if (!transceiver) {
                throw new Error("transceiver not found");
              }
              onRtpReceiver(transceiver.receiver);
            }
          }
          let answer = await this._pc.createAnswer();
          const localSdpObject = sdpTransform.parse(answer.sdp);
          for (const options of optionsList) {
            const { trackId, rtpParameters } = options;
            const localId = mapLocalId.get(trackId);
            const answerMediaObject = localSdpObject.media.find((m) => String(m.mid) === localId);
            sdpCommonUtils.applyCodecParameters({
              offerRtpParameters: rtpParameters,
              answerMediaObject
            });
          }
          answer = { type: "answer", sdp: sdpTransform.write(localSdpObject) };
          if (!this._transportReady) {
            await this.setupTransport({
              localDtlsRole: this._forcedLocalDtlsRole ?? "client",
              localSdpObject
            });
          }
          logger13.debug("receive() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
          for (const options of optionsList) {
            const { trackId } = options;
            const localId = mapLocalId.get(trackId);
            const transceiver = this._pc.getTransceivers().find((t) => t.mid === localId);
            if (!transceiver) {
              throw new Error("new RTCRtpTransceiver not found");
            }
            this._mapMidTransceiver.set(localId, transceiver);
            results.push({
              localId,
              track: transceiver.receiver.track,
              rtpReceiver: transceiver.receiver
            });
          }
          return results;
        }
        async stopReceiving(localIds) {
          this.assertRecvDirection();
          if (this._closed) {
            return;
          }
          for (const localId of localIds) {
            logger13.debug("stopReceiving() [localId:%s]", localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            this._remoteSdp.closeMediaSection(transceiver.mid);
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger13.debug("stopReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          const answer = await this._pc.createAnswer();
          logger13.debug("stopReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
          for (const localId of localIds) {
            this._mapMidTransceiver.delete(localId);
          }
        }
        async pauseReceiving(localIds) {
          this.assertNotClosed();
          this.assertRecvDirection();
          for (const localId of localIds) {
            logger13.debug("pauseReceiving() [localId:%s]", localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            transceiver.direction = "inactive";
            this._remoteSdp.pauseMediaSection(localId);
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger13.debug("pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          const answer = await this._pc.createAnswer();
          logger13.debug("pauseReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
        }
        async resumeReceiving(localIds) {
          this.assertNotClosed();
          this.assertRecvDirection();
          for (const localId of localIds) {
            logger13.debug("resumeReceiving() [localId:%s]", localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            transceiver.direction = "recvonly";
            this._remoteSdp.resumeReceivingMediaSection(localId);
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger13.debug("resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          const answer = await this._pc.createAnswer();
          logger13.debug("resumeReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
        }
        async getReceiverStats(localId) {
          this.assertNotClosed();
          this.assertRecvDirection();
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          return transceiver.receiver.getStats();
        }
        async receiveDataChannel({ sctpStreamParameters, label, protocol }) {
          this.assertNotClosed();
          this.assertRecvDirection();
          const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;
          const options = {
            negotiated: true,
            id: streamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol
          };
          logger13.debug("receiveDataChannel() [options:%o]", options);
          const dataChannel = this._pc.createDataChannel(label, options);
          if (!this._hasDataChannelMediaSection) {
            this._remoteSdp.receiveSctpAssociation();
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger13.debug("receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]", offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            if (!this._transportReady) {
              const localSdpObject = sdpTransform.parse(answer.sdp);
              await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                localSdpObject
              });
            }
            logger13.debug("receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setLocalDescription(answer);
            this._hasDataChannelMediaSection = true;
          }
          return { dataChannel };
        }
        async setupTransport({ localDtlsRole, localSdpObject }) {
          if (!localSdpObject) {
            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
          }
          const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
            sdpObject: localSdpObject
          });
          dtlsParameters.role = localDtlsRole;
          this._remoteSdp.updateDtlsRole(localDtlsRole === "client" ? "server" : "client");
          await new Promise((resolve, reject) => {
            this.safeEmit("@connect", { dtlsParameters }, resolve, reject);
          });
          this._transportReady = true;
        }
        assertNotClosed() {
          if (this._closed) {
            throw new errors_1.InvalidStateError("method called in a closed handler");
          }
        }
        assertSendDirection() {
          if (this._direction !== "send") {
            throw new Error('method can just be called for handlers with "send" direction');
          }
        }
        assertRecvDirection() {
          if (this._direction !== "recv") {
            throw new Error('method can just be called for handlers with "recv" direction');
          }
        }
      };
      exports.Safari12 = Safari12;
    }
  });

  // ../../node_modules/mediasoup-client/lib/handlers/Safari11.js
  var require_Safari11 = __commonJS({
    "../../node_modules/mediasoup-client/lib/handlers/Safari11.js"(exports) {
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Safari11 = void 0;
      var sdpTransform = __importStar(require_lib3());
      var Logger_1 = require_Logger();
      var utils = __importStar(require_utils());
      var ortc = __importStar(require_ortc());
      var sdpCommonUtils = __importStar(require_commonUtils());
      var sdpPlanBUtils = __importStar(require_planBUtils());
      var HandlerInterface_1 = require_HandlerInterface();
      var RemoteSdp_1 = require_RemoteSdp();
      var logger13 = new Logger_1.Logger("Safari11");
      var NAME = "Safari11";
      var SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };
      var Safari11 = class _Safari11 extends HandlerInterface_1.HandlerInterface {
        /**
         * Creates a factory function.
         */
        static createFactory() {
          return () => new _Safari11();
        }
        constructor() {
          super();
          this._sendStream = new MediaStream();
          this._mapSendLocalIdRtpSender = /* @__PURE__ */ new Map();
          this._nextSendLocalId = 0;
          this._mapRecvLocalIdInfo = /* @__PURE__ */ new Map();
          this._hasDataChannelMediaSection = false;
          this._nextSendSctpStreamId = 0;
          this._transportReady = false;
        }
        get name() {
          return NAME;
        }
        close() {
          logger13.debug("close()");
          if (this._pc) {
            try {
              this._pc.close();
            } catch (error) {
            }
          }
          this.emit("@close");
        }
        async getNativeRtpCapabilities() {
          logger13.debug("getNativeRtpCapabilities()");
          const pc = new RTCPeerConnection({
            iceServers: [],
            iceTransportPolicy: "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require",
            sdpSemantics: "plan-b"
          });
          try {
            const offer = await pc.createOffer({
              offerToReceiveAudio: true,
              offerToReceiveVideo: true
            });
            try {
              pc.close();
            } catch (error) {
            }
            const sdpObject = sdpTransform.parse(offer.sdp);
            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
              sdpObject
            });
            return nativeRtpCapabilities;
          } catch (error) {
            try {
              pc.close();
            } catch (error2) {
            }
            throw error;
          }
        }
        async getNativeSctpCapabilities() {
          logger13.debug("getNativeSctpCapabilities()");
          return {
            numStreams: SCTP_NUM_STREAMS
          };
        }
        run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities }) {
          logger13.debug("run()");
          this._direction = direction;
          this._remoteSdp = new RemoteSdp_1.RemoteSdp({
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
            planB: true
          });
          this._sendingRtpParametersByKind = {
            audio: ortc.getSendingRtpParameters("audio", extendedRtpCapabilities),
            video: ortc.getSendingRtpParameters("video", extendedRtpCapabilities)
          };
          this._sendingRemoteRtpParametersByKind = {
            audio: ortc.getSendingRemoteRtpParameters("audio", extendedRtpCapabilities),
            video: ortc.getSendingRemoteRtpParameters("video", extendedRtpCapabilities)
          };
          if (dtlsParameters.role && dtlsParameters.role !== "auto") {
            this._forcedLocalDtlsRole = dtlsParameters.role === "server" ? "client" : "server";
          }
          this._pc = new RTCPeerConnection({
            iceServers: iceServers ?? [],
            iceTransportPolicy: iceTransportPolicy ?? "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require",
            ...additionalSettings
          }, proprietaryConstraints);
          this._pc.addEventListener("icegatheringstatechange", () => {
            this.emit("@icegatheringstatechange", this._pc.iceGatheringState);
          });
          if (this._pc.connectionState) {
            this._pc.addEventListener("connectionstatechange", () => {
              this.emit("@connectionstatechange", this._pc.connectionState);
            });
          } else {
            this._pc.addEventListener("iceconnectionstatechange", () => {
              logger13.warn("run() | pc.connectionState not supported, using pc.iceConnectionState");
              switch (this._pc.iceConnectionState) {
                case "checking": {
                  this.emit("@connectionstatechange", "connecting");
                  break;
                }
                case "connected":
                case "completed": {
                  this.emit("@connectionstatechange", "connected");
                  break;
                }
                case "failed": {
                  this.emit("@connectionstatechange", "failed");
                  break;
                }
                case "disconnected": {
                  this.emit("@connectionstatechange", "disconnected");
                  break;
                }
                case "closed": {
                  this.emit("@connectionstatechange", "closed");
                  break;
                }
              }
            });
          }
        }
        async updateIceServers(iceServers) {
          logger13.debug("updateIceServers()");
          const configuration = this._pc.getConfiguration();
          configuration.iceServers = iceServers;
          this._pc.setConfiguration(configuration);
        }
        async restartIce(iceParameters) {
          logger13.debug("restartIce()");
          this._remoteSdp.updateIceParameters(iceParameters);
          if (!this._transportReady) {
            return;
          }
          if (this._direction === "send") {
            const offer = await this._pc.createOffer({ iceRestart: true });
            logger13.debug("restartIce() | calling pc.setLocalDescription() [offer:%o]", offer);
            await this._pc.setLocalDescription(offer);
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger13.debug("restartIce() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setRemoteDescription(answer);
          } else {
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger13.debug("restartIce() | calling pc.setRemoteDescription() [offer:%o]", offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger13.debug("restartIce() | calling pc.setLocalDescription() [answer:%o]", answer);
            await this._pc.setLocalDescription(answer);
          }
        }
        async getTransportStats() {
          return this._pc.getStats();
        }
        async send({ track, encodings, codecOptions, codec }) {
          this.assertSendDirection();
          logger13.debug("send() [kind:%s, track.id:%s]", track.kind, track.id);
          if (codec) {
            logger13.warn("send() | codec selection is not available in %s handler", this.name);
          }
          this._sendStream.addTrack(track);
          this._pc.addTrack(track, this._sendStream);
          let offer = await this._pc.createOffer();
          let localSdpObject = sdpTransform.parse(offer.sdp);
          let offerMediaObject;
          const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);
          sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs);
          const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);
          sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs);
          if (!this._transportReady) {
            await this.setupTransport({
              localDtlsRole: this._forcedLocalDtlsRole ?? "client",
              localSdpObject
            });
          }
          if (track.kind === "video" && encodings && encodings.length > 1) {
            logger13.debug("send() | enabling simulcast");
            localSdpObject = sdpTransform.parse(offer.sdp);
            offerMediaObject = localSdpObject.media.find((m) => m.type === "video");
            sdpPlanBUtils.addLegacySimulcast({
              offerMediaObject,
              track,
              numStreams: encodings.length
            });
            offer = { type: "offer", sdp: sdpTransform.write(localSdpObject) };
          }
          logger13.debug("send() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
          offerMediaObject = localSdpObject.media.find((m) => m.type === track.kind);
          sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
            offerMediaObject
          });
          sendingRtpParameters.encodings = sdpPlanBUtils.getRtpEncodings({
            offerMediaObject,
            track
          });
          if (encodings) {
            for (let idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {
              if (encodings[idx]) {
                Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);
              }
            }
          }
          if (sendingRtpParameters.encodings.length > 1 && sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/vp8") {
            for (const encoding of sendingRtpParameters.encodings) {
              encoding.scalabilityMode = "L1T3";
            }
          }
          this._remoteSdp.send({
            offerMediaObject,
            offerRtpParameters: sendingRtpParameters,
            answerRtpParameters: sendingRemoteRtpParameters,
            codecOptions
          });
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger13.debug("send() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
          const localId = String(this._nextSendLocalId);
          this._nextSendLocalId++;
          const rtpSender = this._pc.getSenders().find((s) => s.track === track);
          this._mapSendLocalIdRtpSender.set(localId, rtpSender);
          return {
            localId,
            rtpParameters: sendingRtpParameters,
            rtpSender
          };
        }
        async stopSending(localId) {
          this.assertSendDirection();
          const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
          if (!rtpSender) {
            throw new Error("associated RTCRtpSender not found");
          }
          if (rtpSender.track) {
            this._sendStream.removeTrack(rtpSender.track);
          }
          this._mapSendLocalIdRtpSender.delete(localId);
          const offer = await this._pc.createOffer();
          logger13.debug("stopSending() | calling pc.setLocalDescription() [offer:%o]", offer);
          try {
            await this._pc.setLocalDescription(offer);
          } catch (error) {
            if (this._sendStream.getTracks().length === 0) {
              logger13.warn("stopSending() | ignoring expected error due no sending tracks: %s", error.toString());
              return;
            }
            throw error;
          }
          if (this._pc.signalingState === "stable") {
            return;
          }
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger13.debug("stopSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        async pauseSending(localId) {
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        async resumeSending(localId) {
        }
        async replaceTrack(localId, track) {
          this.assertSendDirection();
          if (track) {
            logger13.debug("replaceTrack() [localId:%s, track.id:%s]", localId, track.id);
          } else {
            logger13.debug("replaceTrack() [localId:%s, no track]", localId);
          }
          const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
          if (!rtpSender) {
            throw new Error("associated RTCRtpSender not found");
          }
          const oldTrack = rtpSender.track;
          await rtpSender.replaceTrack(track);
          if (oldTrack) {
            this._sendStream.removeTrack(oldTrack);
          }
          if (track) {
            this._sendStream.addTrack(track);
          }
        }
        async setMaxSpatialLayer(localId, spatialLayer) {
          this.assertSendDirection();
          logger13.debug("setMaxSpatialLayer() [localId:%s, spatialLayer:%s]", localId, spatialLayer);
          const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
          if (!rtpSender) {
            throw new Error("associated RTCRtpSender not found");
          }
          const parameters = rtpSender.getParameters();
          parameters.encodings.forEach((encoding, idx) => {
            if (idx <= spatialLayer) {
              encoding.active = true;
            } else {
              encoding.active = false;
            }
          });
          await rtpSender.setParameters(parameters);
        }
        async setRtpEncodingParameters(localId, params) {
          this.assertSendDirection();
          logger13.debug("setRtpEncodingParameters() [localId:%s, params:%o]", localId, params);
          const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
          if (!rtpSender) {
            throw new Error("associated RTCRtpSender not found");
          }
          const parameters = rtpSender.getParameters();
          parameters.encodings.forEach((encoding, idx) => {
            parameters.encodings[idx] = { ...encoding, ...params };
          });
          await rtpSender.setParameters(parameters);
        }
        async getSenderStats(localId) {
          this.assertSendDirection();
          const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
          if (!rtpSender) {
            throw new Error("associated RTCRtpSender not found");
          }
          return rtpSender.getStats();
        }
        async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol }) {
          this.assertSendDirection();
          const options = {
            negotiated: true,
            id: this._nextSendSctpStreamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol
          };
          logger13.debug("sendDataChannel() [options:%o]", options);
          const dataChannel = this._pc.createDataChannel(label, options);
          this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
          if (!this._hasDataChannelMediaSection) {
            const offer = await this._pc.createOffer();
            const localSdpObject = sdpTransform.parse(offer.sdp);
            const offerMediaObject = localSdpObject.media.find((m) => m.type === "application");
            if (!this._transportReady) {
              await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                localSdpObject
              });
            }
            logger13.debug("sendDataChannel() | calling pc.setLocalDescription() [offer:%o]", offer);
            await this._pc.setLocalDescription(offer);
            this._remoteSdp.sendSctpAssociation({ offerMediaObject });
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger13.debug("sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setRemoteDescription(answer);
            this._hasDataChannelMediaSection = true;
          }
          const sctpStreamParameters = {
            streamId: options.id,
            ordered: options.ordered,
            maxPacketLifeTime: options.maxPacketLifeTime,
            maxRetransmits: options.maxRetransmits
          };
          return { dataChannel, sctpStreamParameters };
        }
        async receive(optionsList) {
          this.assertRecvDirection();
          const results = [];
          for (const options of optionsList) {
            const { trackId, kind, rtpParameters, streamId } = options;
            logger13.debug("receive() [trackId:%s, kind:%s]", trackId, kind);
            const mid = kind;
            this._remoteSdp.receive({
              mid,
              kind,
              offerRtpParameters: rtpParameters,
              streamId: streamId ?? rtpParameters.rtcp.cname,
              trackId
            });
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger13.debug("receive() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          let answer = await this._pc.createAnswer();
          const localSdpObject = sdpTransform.parse(answer.sdp);
          for (const options of optionsList) {
            const { kind, rtpParameters } = options;
            const mid = kind;
            const answerMediaObject = localSdpObject.media.find((m) => String(m.mid) === mid);
            sdpCommonUtils.applyCodecParameters({
              offerRtpParameters: rtpParameters,
              answerMediaObject
            });
          }
          answer = { type: "answer", sdp: sdpTransform.write(localSdpObject) };
          if (!this._transportReady) {
            await this.setupTransport({
              localDtlsRole: this._forcedLocalDtlsRole ?? "client",
              localSdpObject
            });
          }
          logger13.debug("receive() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
          for (const options of optionsList) {
            const { kind, trackId, rtpParameters } = options;
            const mid = kind;
            const localId = trackId;
            const rtpReceiver = this._pc.getReceivers().find((r) => r.track && r.track.id === localId);
            if (!rtpReceiver) {
              throw new Error("new RTCRtpReceiver not");
            }
            this._mapRecvLocalIdInfo.set(localId, {
              mid,
              rtpParameters,
              rtpReceiver
            });
            results.push({
              localId,
              track: rtpReceiver.track,
              rtpReceiver
            });
          }
          return results;
        }
        async stopReceiving(localIds) {
          this.assertRecvDirection();
          for (const localId of localIds) {
            logger13.debug("stopReceiving() [localId:%s]", localId);
            const { mid, rtpParameters } = this._mapRecvLocalIdInfo.get(localId) ?? {};
            this._mapRecvLocalIdInfo.delete(localId);
            this._remoteSdp.planBStopReceiving({
              mid,
              offerRtpParameters: rtpParameters
            });
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger13.debug("stopReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          const answer = await this._pc.createAnswer();
          logger13.debug("stopReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
        }
        async getReceiverStats(localId) {
          this.assertRecvDirection();
          const { rtpReceiver } = this._mapRecvLocalIdInfo.get(localId) ?? {};
          if (!rtpReceiver) {
            throw new Error("associated RTCRtpReceiver not found");
          }
          return rtpReceiver.getStats();
        }
        async pauseReceiving(localIds) {
        }
        async resumeReceiving(localIds) {
        }
        async receiveDataChannel({ sctpStreamParameters, label, protocol }) {
          this.assertRecvDirection();
          const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;
          const options = {
            negotiated: true,
            id: streamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol
          };
          logger13.debug("receiveDataChannel() [options:%o]", options);
          const dataChannel = this._pc.createDataChannel(label, options);
          if (!this._hasDataChannelMediaSection) {
            this._remoteSdp.receiveSctpAssociation({ oldDataChannelSpec: true });
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger13.debug("receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]", offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            if (!this._transportReady) {
              const localSdpObject = sdpTransform.parse(answer.sdp);
              await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                localSdpObject
              });
            }
            logger13.debug("receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setLocalDescription(answer);
            this._hasDataChannelMediaSection = true;
          }
          return { dataChannel };
        }
        async setupTransport({ localDtlsRole, localSdpObject }) {
          if (!localSdpObject) {
            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
          }
          const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
            sdpObject: localSdpObject
          });
          dtlsParameters.role = localDtlsRole;
          this._remoteSdp.updateDtlsRole(localDtlsRole === "client" ? "server" : "client");
          await new Promise((resolve, reject) => {
            this.safeEmit("@connect", { dtlsParameters }, resolve, reject);
          });
          this._transportReady = true;
        }
        assertSendDirection() {
          if (this._direction !== "send") {
            throw new Error('method can just be called for handlers with "send" direction');
          }
        }
        assertRecvDirection() {
          if (this._direction !== "recv") {
            throw new Error('method can just be called for handlers with "recv" direction');
          }
        }
      };
      exports.Safari11 = Safari11;
    }
  });

  // ../../node_modules/mediasoup-client/lib/handlers/ortc/edgeUtils.js
  var require_edgeUtils = __commonJS({
    "../../node_modules/mediasoup-client/lib/handlers/ortc/edgeUtils.js"(exports) {
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getCapabilities = getCapabilities;
      exports.mangleRtpParameters = mangleRtpParameters;
      var utils = __importStar(require_utils());
      function getCapabilities() {
        const nativeCaps = RTCRtpReceiver.getCapabilities();
        const caps = utils.clone(nativeCaps);
        for (const codec of caps.codecs ?? []) {
          codec.channels = codec.numChannels;
          delete codec.numChannels;
          codec.mimeType = codec.mimeType ?? `${codec.kind}/${codec.name}`;
          if (codec.parameters) {
            const parameters = codec.parameters;
            if (parameters.apt) {
              parameters.apt = Number(parameters.apt);
            }
            if (parameters["packetization-mode"]) {
              parameters["packetization-mode"] = Number(parameters["packetization-mode"]);
            }
          }
          for (const feedback of codec.rtcpFeedback ?? []) {
            if (!feedback.parameter) {
              feedback.parameter = "";
            }
          }
        }
        return caps;
      }
      function mangleRtpParameters(rtpParameters) {
        const params = utils.clone(rtpParameters);
        if (params.mid) {
          params.muxId = params.mid;
          delete params.mid;
        }
        for (const codec of params.codecs) {
          if (codec.channels) {
            codec.numChannels = codec.channels;
            delete codec.channels;
          }
          if (codec.mimeType && !codec.name) {
            codec.name = codec.mimeType.split("/")[1];
          }
          delete codec.mimeType;
        }
        return params;
      }
    }
  });

  // ../../node_modules/mediasoup-client/lib/handlers/Edge11.js
  var require_Edge11 = __commonJS({
    "../../node_modules/mediasoup-client/lib/handlers/Edge11.js"(exports) {
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Edge11 = void 0;
      var Logger_1 = require_Logger();
      var errors_1 = require_errors();
      var utils = __importStar(require_utils());
      var ortc = __importStar(require_ortc());
      var edgeUtils = __importStar(require_edgeUtils());
      var HandlerInterface_1 = require_HandlerInterface();
      var logger13 = new Logger_1.Logger("Edge11");
      var NAME = "Edge11";
      var Edge11 = class _Edge11 extends HandlerInterface_1.HandlerInterface {
        /**
         * Creates a factory function.
         */
        static createFactory() {
          return () => new _Edge11();
        }
        constructor() {
          super();
          this._rtpSenders = /* @__PURE__ */ new Map();
          this._rtpReceivers = /* @__PURE__ */ new Map();
          this._nextSendLocalId = 0;
          this._transportReady = false;
        }
        get name() {
          return NAME;
        }
        close() {
          logger13.debug("close()");
          try {
            this._iceGatherer.close();
          } catch (error) {
          }
          try {
            this._iceTransport.stop();
          } catch (error) {
          }
          try {
            this._dtlsTransport.stop();
          } catch (error) {
          }
          for (const rtpSender of this._rtpSenders.values()) {
            try {
              rtpSender.stop();
            } catch (error) {
            }
          }
          for (const rtpReceiver of this._rtpReceivers.values()) {
            try {
              rtpReceiver.stop();
            } catch (error) {
            }
          }
          this.emit("@close");
        }
        async getNativeRtpCapabilities() {
          logger13.debug("getNativeRtpCapabilities()");
          return edgeUtils.getCapabilities();
        }
        async getNativeSctpCapabilities() {
          logger13.debug("getNativeSctpCapabilities()");
          return {
            numStreams: { OS: 0, MIS: 0 }
          };
        }
        run({
          direction,
          // eslint-disable-line @typescript-eslint/no-unused-vars
          iceParameters,
          iceCandidates,
          dtlsParameters,
          sctpParameters,
          // eslint-disable-line @typescript-eslint/no-unused-vars
          iceServers,
          iceTransportPolicy,
          additionalSettings,
          // eslint-disable-line @typescript-eslint/no-unused-vars
          proprietaryConstraints,
          // eslint-disable-line @typescript-eslint/no-unused-vars
          extendedRtpCapabilities
        }) {
          logger13.debug("run()");
          this._sendingRtpParametersByKind = {
            audio: ortc.getSendingRtpParameters("audio", extendedRtpCapabilities),
            video: ortc.getSendingRtpParameters("video", extendedRtpCapabilities)
          };
          this._remoteIceParameters = iceParameters;
          this._remoteIceCandidates = iceCandidates;
          this._remoteDtlsParameters = dtlsParameters;
          this._cname = `CNAME-${utils.generateRandomNumber()}`;
          this.setIceGatherer({ iceServers, iceTransportPolicy });
          this.setIceTransport();
          this.setDtlsTransport();
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        async updateIceServers(iceServers) {
          throw new errors_1.UnsupportedError("not supported");
        }
        async restartIce(iceParameters) {
          logger13.debug("restartIce()");
          this._remoteIceParameters = iceParameters;
          if (!this._transportReady) {
            return;
          }
          logger13.debug("restartIce() | calling iceTransport.start()");
          this._iceTransport.start(this._iceGatherer, iceParameters, "controlling");
          for (const candidate of this._remoteIceCandidates) {
            this._iceTransport.addRemoteCandidate(candidate);
          }
          this._iceTransport.addRemoteCandidate({});
        }
        async getTransportStats() {
          return this._iceTransport.getStats();
        }
        async send({ track, encodings, codecOptions, codec }) {
          logger13.debug("send() [kind:%s, track.id:%s]", track.kind, track.id);
          if (!this._transportReady) {
            await this.setupTransport({ localDtlsRole: "server" });
          }
          logger13.debug("send() | calling new RTCRtpSender()");
          const rtpSender = new RTCRtpSender(track, this._dtlsTransport);
          const rtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);
          rtpParameters.codecs = ortc.reduceCodecs(rtpParameters.codecs, codec);
          const useRtx = rtpParameters.codecs.some((_codec) => /.+\/rtx$/i.test(_codec.mimeType));
          if (!encodings) {
            encodings = [{}];
          }
          for (const encoding of encodings) {
            encoding.ssrc = utils.generateRandomNumber();
            if (useRtx) {
              encoding.rtx = { ssrc: utils.generateRandomNumber() };
            }
          }
          rtpParameters.encodings = encodings;
          rtpParameters.rtcp = {
            cname: this._cname,
            reducedSize: true,
            mux: true
          };
          const edgeRtpParameters = edgeUtils.mangleRtpParameters(rtpParameters);
          logger13.debug("send() | calling rtpSender.send() [params:%o]", edgeRtpParameters);
          await rtpSender.send(edgeRtpParameters);
          const localId = String(this._nextSendLocalId);
          this._nextSendLocalId++;
          this._rtpSenders.set(localId, rtpSender);
          return { localId, rtpParameters, rtpSender };
        }
        async stopSending(localId) {
          logger13.debug("stopSending() [localId:%s]", localId);
          const rtpSender = this._rtpSenders.get(localId);
          if (!rtpSender) {
            throw new Error("RTCRtpSender not found");
          }
          this._rtpSenders.delete(localId);
          try {
            logger13.debug("stopSending() | calling rtpSender.stop()");
            rtpSender.stop();
          } catch (error) {
            logger13.warn("stopSending() | rtpSender.stop() failed:%o", error);
            throw error;
          }
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        async pauseSending(localId) {
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        async resumeSending(localId) {
        }
        async replaceTrack(localId, track) {
          if (track) {
            logger13.debug("replaceTrack() [localId:%s, track.id:%s]", localId, track.id);
          } else {
            logger13.debug("replaceTrack() [localId:%s, no track]", localId);
          }
          const rtpSender = this._rtpSenders.get(localId);
          if (!rtpSender) {
            throw new Error("RTCRtpSender not found");
          }
          rtpSender.setTrack(track);
        }
        async setMaxSpatialLayer(localId, spatialLayer) {
          logger13.debug("setMaxSpatialLayer() [localId:%s, spatialLayer:%s]", localId, spatialLayer);
          const rtpSender = this._rtpSenders.get(localId);
          if (!rtpSender) {
            throw new Error("RTCRtpSender not found");
          }
          const parameters = rtpSender.getParameters();
          parameters.encodings.forEach((encoding, idx) => {
            if (idx <= spatialLayer) {
              encoding.active = true;
            } else {
              encoding.active = false;
            }
          });
          await rtpSender.setParameters(parameters);
        }
        async setRtpEncodingParameters(localId, params) {
          logger13.debug("setRtpEncodingParameters() [localId:%s, params:%o]", localId, params);
          const rtpSender = this._rtpSenders.get(localId);
          if (!rtpSender) {
            throw new Error("RTCRtpSender not found");
          }
          const parameters = rtpSender.getParameters();
          parameters.encodings.forEach((encoding, idx) => {
            parameters.encodings[idx] = { ...encoding, ...params };
          });
          await rtpSender.setParameters(parameters);
        }
        async getSenderStats(localId) {
          const rtpSender = this._rtpSenders.get(localId);
          if (!rtpSender) {
            throw new Error("RTCRtpSender not found");
          }
          return rtpSender.getStats();
        }
        async sendDataChannel(options) {
          throw new errors_1.UnsupportedError("not implemented");
        }
        async receive(optionsList) {
          const results = [];
          for (const options of optionsList) {
            const { trackId, kind } = options;
            logger13.debug("receive() [trackId:%s, kind:%s]", trackId, kind);
          }
          if (!this._transportReady) {
            await this.setupTransport({ localDtlsRole: "server" });
          }
          for (const options of optionsList) {
            const { trackId, kind, rtpParameters } = options;
            logger13.debug("receive() | calling new RTCRtpReceiver()");
            const rtpReceiver = new RTCRtpReceiver(this._dtlsTransport, kind);
            rtpReceiver.addEventListener("error", (event) => {
              logger13.error('rtpReceiver "error" event [event:%o]', event);
            });
            const edgeRtpParameters = edgeUtils.mangleRtpParameters(rtpParameters);
            logger13.debug("receive() | calling rtpReceiver.receive() [params:%o]", edgeRtpParameters);
            await rtpReceiver.receive(edgeRtpParameters);
            const localId = trackId;
            this._rtpReceivers.set(localId, rtpReceiver);
            results.push({
              localId,
              track: rtpReceiver.track,
              rtpReceiver
            });
          }
          return results;
        }
        async stopReceiving(localIds) {
          for (const localId of localIds) {
            logger13.debug("stopReceiving() [localId:%s]", localId);
            const rtpReceiver = this._rtpReceivers.get(localId);
            if (!rtpReceiver) {
              throw new Error("RTCRtpReceiver not found");
            }
            this._rtpReceivers.delete(localId);
            try {
              logger13.debug("stopReceiving() | calling rtpReceiver.stop()");
              rtpReceiver.stop();
            } catch (error) {
              logger13.warn("stopReceiving() | rtpReceiver.stop() failed:%o", error);
            }
          }
        }
        async pauseReceiving(localIds) {
        }
        async resumeReceiving(localIds) {
        }
        async getReceiverStats(localId) {
          const rtpReceiver = this._rtpReceivers.get(localId);
          if (!rtpReceiver) {
            throw new Error("RTCRtpReceiver not found");
          }
          return rtpReceiver.getStats();
        }
        async receiveDataChannel(options) {
          throw new errors_1.UnsupportedError("not implemented");
        }
        setIceGatherer({ iceServers, iceTransportPolicy }) {
          const iceGatherer = new RTCIceGatherer({
            iceServers: iceServers ?? [],
            gatherPolicy: iceTransportPolicy ?? "all"
          });
          iceGatherer.addEventListener("error", (event) => {
            logger13.error('iceGatherer "error" event [event:%o]', event);
          });
          try {
            iceGatherer.gather();
          } catch (error) {
            logger13.debug("setIceGatherer() | iceGatherer.gather() failed: %s", error.toString());
          }
          this._iceGatherer = iceGatherer;
        }
        setIceTransport() {
          const iceTransport = new RTCIceTransport(this._iceGatherer);
          iceTransport.addEventListener("statechange", () => {
            switch (iceTransport.state) {
              case "checking": {
                this.emit("@connectionstatechange", "connecting");
                break;
              }
              case "connected":
              case "completed": {
                this.emit("@connectionstatechange", "connected");
                break;
              }
              case "failed": {
                this.emit("@connectionstatechange", "failed");
                break;
              }
              case "disconnected": {
                this.emit("@connectionstatechange", "disconnected");
                break;
              }
              case "closed": {
                this.emit("@connectionstatechange", "closed");
                break;
              }
            }
          });
          iceTransport.addEventListener("icestatechange", () => {
            switch (iceTransport.state) {
              case "checking": {
                this.emit("@connectionstatechange", "connecting");
                break;
              }
              case "connected":
              case "completed": {
                this.emit("@connectionstatechange", "connected");
                break;
              }
              case "failed": {
                this.emit("@connectionstatechange", "failed");
                break;
              }
              case "disconnected": {
                this.emit("@connectionstatechange", "disconnected");
                break;
              }
              case "closed": {
                this.emit("@connectionstatechange", "closed");
                break;
              }
            }
          });
          iceTransport.addEventListener("candidatepairchange", (event) => {
            logger13.debug('iceTransport "candidatepairchange" event [pair:%o]', event.pair);
          });
          this._iceTransport = iceTransport;
        }
        setDtlsTransport() {
          const dtlsTransport = new RTCDtlsTransport(this._iceTransport);
          dtlsTransport.addEventListener("statechange", () => {
            logger13.debug('dtlsTransport "statechange" event [state:%s]', dtlsTransport.state);
          });
          dtlsTransport.addEventListener("dtlsstatechange", () => {
            logger13.debug('dtlsTransport "dtlsstatechange" event [state:%s]', dtlsTransport.state);
            if (dtlsTransport.state === "closed") {
              this.emit("@connectionstatechange", "closed");
            }
          });
          dtlsTransport.addEventListener("error", (event) => {
            logger13.error('dtlsTransport "error" event [event:%o]', event);
          });
          this._dtlsTransport = dtlsTransport;
        }
        async setupTransport({ localDtlsRole }) {
          logger13.debug("setupTransport()");
          const dtlsParameters = this._dtlsTransport.getLocalParameters();
          dtlsParameters.role = localDtlsRole;
          await new Promise((resolve, reject) => {
            this.safeEmit("@connect", { dtlsParameters }, resolve, reject);
          });
          this._iceTransport.start(this._iceGatherer, this._remoteIceParameters, "controlling");
          for (const candidate of this._remoteIceCandidates) {
            this._iceTransport.addRemoteCandidate(candidate);
          }
          this._iceTransport.addRemoteCandidate({});
          this._remoteDtlsParameters.fingerprints = this._remoteDtlsParameters.fingerprints.filter((fingerprint) => {
            return fingerprint.algorithm === "sha-256" || fingerprint.algorithm === "sha-384" || fingerprint.algorithm === "sha-512";
          });
          this._dtlsTransport.start(this._remoteDtlsParameters);
          this._transportReady = true;
        }
      };
      exports.Edge11 = Edge11;
    }
  });

  // ../../node_modules/mediasoup-client/lib/handlers/ReactNativeUnifiedPlan.js
  var require_ReactNativeUnifiedPlan = __commonJS({
    "../../node_modules/mediasoup-client/lib/handlers/ReactNativeUnifiedPlan.js"(exports) {
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ReactNativeUnifiedPlan = void 0;
      var sdpTransform = __importStar(require_lib3());
      var Logger_1 = require_Logger();
      var utils = __importStar(require_utils());
      var ortc = __importStar(require_ortc());
      var sdpCommonUtils = __importStar(require_commonUtils());
      var sdpUnifiedPlanUtils = __importStar(require_unifiedPlanUtils());
      var ortcUtils = __importStar(require_utils2());
      var errors_1 = require_errors();
      var HandlerInterface_1 = require_HandlerInterface();
      var RemoteSdp_1 = require_RemoteSdp();
      var scalabilityModes_1 = require_scalabilityModes();
      var logger13 = new Logger_1.Logger("ReactNativeUnifiedPlan");
      var NAME = "ReactNativeUnifiedPlan";
      var SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };
      var ReactNativeUnifiedPlan = class _ReactNativeUnifiedPlan extends HandlerInterface_1.HandlerInterface {
        /**
         * Creates a factory function.
         */
        static createFactory() {
          return () => new _ReactNativeUnifiedPlan();
        }
        constructor() {
          super();
          this._closed = false;
          this._mapMidTransceiver = /* @__PURE__ */ new Map();
          this._sendStream = new MediaStream();
          this._hasDataChannelMediaSection = false;
          this._nextSendSctpStreamId = 0;
          this._transportReady = false;
        }
        get name() {
          return NAME;
        }
        close() {
          logger13.debug("close()");
          if (this._closed) {
            return;
          }
          this._closed = true;
          this._sendStream.release(
            /* releaseTracks */
            false
          );
          if (this._pc) {
            try {
              this._pc.close();
            } catch (error) {
            }
          }
          this.emit("@close");
        }
        async getNativeRtpCapabilities() {
          logger13.debug("getNativeRtpCapabilities()");
          const pc = new RTCPeerConnection({
            iceServers: [],
            iceTransportPolicy: "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require",
            sdpSemantics: "unified-plan"
          });
          try {
            pc.addTransceiver("audio");
            pc.addTransceiver("video");
            const offer = await pc.createOffer();
            try {
              pc.close();
            } catch (error) {
            }
            const sdpObject = sdpTransform.parse(offer.sdp);
            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
              sdpObject
            });
            ortcUtils.addNackSuppportForOpus(nativeRtpCapabilities);
            return nativeRtpCapabilities;
          } catch (error) {
            try {
              pc.close();
            } catch (error2) {
            }
            throw error;
          }
        }
        async getNativeSctpCapabilities() {
          logger13.debug("getNativeSctpCapabilities()");
          return {
            numStreams: SCTP_NUM_STREAMS
          };
        }
        run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities }) {
          this.assertNotClosed();
          logger13.debug("run()");
          this._direction = direction;
          this._remoteSdp = new RemoteSdp_1.RemoteSdp({
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters
          });
          this._sendingRtpParametersByKind = {
            audio: ortc.getSendingRtpParameters("audio", extendedRtpCapabilities),
            video: ortc.getSendingRtpParameters("video", extendedRtpCapabilities)
          };
          this._sendingRemoteRtpParametersByKind = {
            audio: ortc.getSendingRemoteRtpParameters("audio", extendedRtpCapabilities),
            video: ortc.getSendingRemoteRtpParameters("video", extendedRtpCapabilities)
          };
          if (dtlsParameters.role && dtlsParameters.role !== "auto") {
            this._forcedLocalDtlsRole = dtlsParameters.role === "server" ? "client" : "server";
          }
          this._pc = new RTCPeerConnection({
            iceServers: iceServers ?? [],
            iceTransportPolicy: iceTransportPolicy ?? "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require",
            sdpSemantics: "unified-plan",
            ...additionalSettings
          }, proprietaryConstraints);
          this._pc.addEventListener("icegatheringstatechange", () => {
            this.emit("@icegatheringstatechange", this._pc.iceGatheringState);
          });
          if (this._pc.connectionState) {
            this._pc.addEventListener("connectionstatechange", () => {
              this.emit("@connectionstatechange", this._pc.connectionState);
            });
          } else {
            this._pc.addEventListener("iceconnectionstatechange", () => {
              logger13.warn("run() | pc.connectionState not supported, using pc.iceConnectionState");
              switch (this._pc.iceConnectionState) {
                case "checking": {
                  this.emit("@connectionstatechange", "connecting");
                  break;
                }
                case "connected":
                case "completed": {
                  this.emit("@connectionstatechange", "connected");
                  break;
                }
                case "failed": {
                  this.emit("@connectionstatechange", "failed");
                  break;
                }
                case "disconnected": {
                  this.emit("@connectionstatechange", "disconnected");
                  break;
                }
                case "closed": {
                  this.emit("@connectionstatechange", "closed");
                  break;
                }
              }
            });
          }
        }
        async updateIceServers(iceServers) {
          this.assertNotClosed();
          logger13.debug("updateIceServers()");
          const configuration = this._pc.getConfiguration();
          configuration.iceServers = iceServers;
          this._pc.setConfiguration(configuration);
        }
        async restartIce(iceParameters) {
          this.assertNotClosed();
          logger13.debug("restartIce()");
          this._remoteSdp.updateIceParameters(iceParameters);
          if (!this._transportReady) {
            return;
          }
          if (this._direction === "send") {
            const offer = await this._pc.createOffer({ iceRestart: true });
            logger13.debug("restartIce() | calling pc.setLocalDescription() [offer:%o]", offer);
            await this._pc.setLocalDescription(offer);
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger13.debug("restartIce() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setRemoteDescription(answer);
          } else {
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger13.debug("restartIce() | calling pc.setRemoteDescription() [offer:%o]", offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger13.debug("restartIce() | calling pc.setLocalDescription() [answer:%o]", answer);
            await this._pc.setLocalDescription(answer);
          }
        }
        async getTransportStats() {
          this.assertNotClosed();
          return this._pc.getStats();
        }
        async send({ track, encodings, codecOptions, codec, onRtpSender }) {
          this.assertNotClosed();
          this.assertSendDirection();
          logger13.debug("send() [kind:%s, track.id:%s]", track.kind, track.id);
          if (encodings && encodings.length > 1) {
            encodings.forEach((encoding, idx) => {
              encoding.rid = `r${idx}`;
            });
          }
          const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);
          sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);
          const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);
          sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);
          const mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();
          const transceiver = this._pc.addTransceiver(track, {
            direction: "sendonly",
            streams: [this._sendStream],
            sendEncodings: encodings
          });
          if (onRtpSender) {
            onRtpSender(transceiver.sender);
          }
          let offer = await this._pc.createOffer();
          let localSdpObject = sdpTransform.parse(offer.sdp);
          let offerMediaObject;
          if (!this._transportReady) {
            await this.setupTransport({
              localDtlsRole: this._forcedLocalDtlsRole ?? "client",
              localSdpObject
            });
          }
          let hackVp9Svc = false;
          const layers = (0, scalabilityModes_1.parse)((encodings ?? [{}])[0].scalabilityMode);
          if (encodings && encodings.length === 1 && layers.spatialLayers > 1 && sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/vp9") {
            logger13.debug("send() | enabling legacy simulcast for VP9 SVC");
            hackVp9Svc = true;
            localSdpObject = sdpTransform.parse(offer.sdp);
            offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
            sdpUnifiedPlanUtils.addLegacySimulcast({
              offerMediaObject,
              numStreams: layers.spatialLayers
            });
            offer = { type: "offer", sdp: sdpTransform.write(localSdpObject) };
          }
          logger13.debug("send() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          let localId = transceiver.mid ?? void 0;
          if (!localId) {
            logger13.warn("send() | missing transceiver.mid (bug in react-native-webrtc, using a workaround");
          }
          sendingRtpParameters.mid = localId;
          localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
          offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
          sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
            offerMediaObject
          });
          if (!encodings) {
            sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({
              offerMediaObject
            });
          } else if (encodings.length === 1) {
            let newEncodings = sdpUnifiedPlanUtils.getRtpEncodings({
              offerMediaObject
            });
            Object.assign(newEncodings[0], encodings[0]);
            if (hackVp9Svc) {
              newEncodings = [newEncodings[0]];
            }
            sendingRtpParameters.encodings = newEncodings;
          } else {
            sendingRtpParameters.encodings = encodings;
          }
          if (sendingRtpParameters.encodings.length > 1 && (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/vp8" || sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/h264")) {
            for (const encoding of sendingRtpParameters.encodings) {
              if (encoding.scalabilityMode) {
                encoding.scalabilityMode = `L1T${layers.temporalLayers}`;
              } else {
                encoding.scalabilityMode = "L1T3";
              }
            }
          }
          this._remoteSdp.send({
            offerMediaObject,
            reuseMid: mediaSectionIdx.reuseMid,
            offerRtpParameters: sendingRtpParameters,
            answerRtpParameters: sendingRemoteRtpParameters,
            codecOptions,
            extmapAllowMixed: true
          });
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger13.debug("send() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
          if (!localId) {
            localId = transceiver.mid;
            sendingRtpParameters.mid = localId;
          }
          this._mapMidTransceiver.set(localId, transceiver);
          return {
            localId,
            rtpParameters: sendingRtpParameters,
            rtpSender: transceiver.sender
          };
        }
        async stopSending(localId) {
          this.assertSendDirection();
          if (this._closed) {
            return;
          }
          logger13.debug("stopSending() [localId:%s]", localId);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          void transceiver.sender.replaceTrack(null);
          this._pc.removeTrack(transceiver.sender);
          const mediaSectionClosed = this._remoteSdp.closeMediaSection(transceiver.mid);
          if (mediaSectionClosed) {
            try {
              transceiver.stop();
            } catch (error) {
            }
          }
          const offer = await this._pc.createOffer();
          logger13.debug("stopSending() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger13.debug("stopSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
          this._mapMidTransceiver.delete(localId);
        }
        async pauseSending(localId) {
          this.assertNotClosed();
          this.assertSendDirection();
          logger13.debug("pauseSending() [localId:%s]", localId);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          transceiver.direction = "inactive";
          this._remoteSdp.pauseMediaSection(localId);
          const offer = await this._pc.createOffer();
          logger13.debug("pauseSending() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger13.debug("pauseSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
        }
        async resumeSending(localId) {
          this.assertNotClosed();
          this.assertSendDirection();
          logger13.debug("resumeSending() [localId:%s]", localId);
          const transceiver = this._mapMidTransceiver.get(localId);
          this._remoteSdp.resumeSendingMediaSection(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          transceiver.direction = "sendonly";
          const offer = await this._pc.createOffer();
          logger13.debug("resumeSending() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger13.debug("resumeSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
        }
        async replaceTrack(localId, track) {
          this.assertNotClosed();
          this.assertSendDirection();
          if (track) {
            logger13.debug("replaceTrack() [localId:%s, track.id:%s]", localId, track.id);
          } else {
            logger13.debug("replaceTrack() [localId:%s, no track]", localId);
          }
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          await transceiver.sender.replaceTrack(track);
        }
        async setMaxSpatialLayer(localId, spatialLayer) {
          this.assertNotClosed();
          this.assertSendDirection();
          logger13.debug("setMaxSpatialLayer() [localId:%s, spatialLayer:%s]", localId, spatialLayer);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          const parameters = transceiver.sender.getParameters();
          parameters.encodings.forEach((encoding, idx) => {
            if (idx <= spatialLayer) {
              encoding.active = true;
            } else {
              encoding.active = false;
            }
          });
          await transceiver.sender.setParameters(parameters);
          this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
          const offer = await this._pc.createOffer();
          logger13.debug("setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger13.debug("setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
        }
        async setRtpEncodingParameters(localId, params) {
          this.assertNotClosed();
          this.assertSendDirection();
          logger13.debug("setRtpEncodingParameters() [localId:%s, params:%o]", localId, params);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          const parameters = transceiver.sender.getParameters();
          parameters.encodings.forEach((encoding, idx) => {
            parameters.encodings[idx] = { ...encoding, ...params };
          });
          await transceiver.sender.setParameters(parameters);
          this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
          const offer = await this._pc.createOffer();
          logger13.debug("setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger13.debug("setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
        }
        async getSenderStats(localId) {
          this.assertNotClosed();
          this.assertSendDirection();
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          return transceiver.sender.getStats();
        }
        async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol }) {
          this.assertNotClosed();
          this.assertSendDirection();
          const options = {
            negotiated: true,
            id: this._nextSendSctpStreamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol
          };
          logger13.debug("sendDataChannel() [options:%o]", options);
          const dataChannel = this._pc.createDataChannel(label, options);
          this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
          if (!this._hasDataChannelMediaSection) {
            const offer = await this._pc.createOffer();
            const localSdpObject = sdpTransform.parse(offer.sdp);
            const offerMediaObject = localSdpObject.media.find((m) => m.type === "application");
            if (!this._transportReady) {
              await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                localSdpObject
              });
            }
            logger13.debug("sendDataChannel() | calling pc.setLocalDescription() [offer:%o]", offer);
            await this._pc.setLocalDescription(offer);
            this._remoteSdp.sendSctpAssociation({ offerMediaObject });
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger13.debug("sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setRemoteDescription(answer);
            this._hasDataChannelMediaSection = true;
          }
          const sctpStreamParameters = {
            streamId: options.id,
            ordered: options.ordered,
            maxPacketLifeTime: options.maxPacketLifeTime,
            maxRetransmits: options.maxRetransmits
          };
          return { dataChannel, sctpStreamParameters };
        }
        async receive(optionsList) {
          this.assertNotClosed();
          this.assertRecvDirection();
          const results = [];
          const mapLocalId = /* @__PURE__ */ new Map();
          for (const options of optionsList) {
            const { trackId, kind, rtpParameters, streamId } = options;
            logger13.debug("receive() [trackId:%s, kind:%s]", trackId, kind);
            const localId = rtpParameters.mid ?? String(this._mapMidTransceiver.size);
            mapLocalId.set(trackId, localId);
            this._remoteSdp.receive({
              mid: localId,
              kind,
              offerRtpParameters: rtpParameters,
              streamId: streamId ?? rtpParameters.rtcp.cname,
              trackId
            });
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger13.debug("receive() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          for (const options of optionsList) {
            const { trackId, onRtpReceiver } = options;
            if (onRtpReceiver) {
              const localId = mapLocalId.get(trackId);
              const transceiver = this._pc.getTransceivers().find((t) => t.mid === localId);
              if (!transceiver) {
                throw new Error("transceiver not found");
              }
              onRtpReceiver(transceiver.receiver);
            }
          }
          let answer = await this._pc.createAnswer();
          const localSdpObject = sdpTransform.parse(answer.sdp);
          for (const options of optionsList) {
            const { trackId, rtpParameters } = options;
            const localId = mapLocalId.get(trackId);
            const answerMediaObject = localSdpObject.media.find((m) => String(m.mid) === localId);
            sdpCommonUtils.applyCodecParameters({
              offerRtpParameters: rtpParameters,
              answerMediaObject
            });
          }
          answer = { type: "answer", sdp: sdpTransform.write(localSdpObject) };
          if (!this._transportReady) {
            await this.setupTransport({
              localDtlsRole: this._forcedLocalDtlsRole ?? "client",
              localSdpObject
            });
          }
          logger13.debug("receive() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
          for (const options of optionsList) {
            const { trackId } = options;
            const localId = mapLocalId.get(trackId);
            const transceiver = this._pc.getTransceivers().find((t) => t.mid === localId);
            if (!transceiver) {
              throw new Error("new RTCRtpTransceiver not found");
            } else {
              this._mapMidTransceiver.set(localId, transceiver);
              results.push({
                localId,
                track: transceiver.receiver.track,
                rtpReceiver: transceiver.receiver
              });
            }
          }
          return results;
        }
        async stopReceiving(localIds) {
          this.assertRecvDirection();
          if (this._closed) {
            return;
          }
          for (const localId of localIds) {
            logger13.debug("stopReceiving() [localId:%s]", localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            this._remoteSdp.closeMediaSection(transceiver.mid);
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger13.debug("stopReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          const answer = await this._pc.createAnswer();
          logger13.debug("stopReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
          for (const localId of localIds) {
            this._mapMidTransceiver.delete(localId);
          }
        }
        async pauseReceiving(localIds) {
          this.assertNotClosed();
          this.assertRecvDirection();
          for (const localId of localIds) {
            logger13.debug("pauseReceiving() [localId:%s]", localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            transceiver.direction = "inactive";
            this._remoteSdp.pauseMediaSection(localId);
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger13.debug("pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          const answer = await this._pc.createAnswer();
          logger13.debug("pauseReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
        }
        async resumeReceiving(localIds) {
          this.assertNotClosed();
          this.assertRecvDirection();
          for (const localId of localIds) {
            logger13.debug("resumeReceiving() [localId:%s]", localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            transceiver.direction = "recvonly";
            this._remoteSdp.resumeReceivingMediaSection(localId);
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger13.debug("resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          const answer = await this._pc.createAnswer();
          logger13.debug("resumeReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
        }
        async getReceiverStats(localId) {
          this.assertNotClosed();
          this.assertRecvDirection();
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          return transceiver.receiver.getStats();
        }
        async receiveDataChannel({ sctpStreamParameters, label, protocol }) {
          this.assertNotClosed();
          this.assertRecvDirection();
          const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;
          const options = {
            negotiated: true,
            id: streamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol
          };
          logger13.debug("receiveDataChannel() [options:%o]", options);
          const dataChannel = this._pc.createDataChannel(label, options);
          if (!this._hasDataChannelMediaSection) {
            this._remoteSdp.receiveSctpAssociation();
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger13.debug("receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]", offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            if (!this._transportReady) {
              const localSdpObject = sdpTransform.parse(answer.sdp);
              await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                localSdpObject
              });
            }
            logger13.debug("receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setLocalDescription(answer);
            this._hasDataChannelMediaSection = true;
          }
          return { dataChannel };
        }
        async setupTransport({ localDtlsRole, localSdpObject }) {
          if (!localSdpObject) {
            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
          }
          const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
            sdpObject: localSdpObject
          });
          dtlsParameters.role = localDtlsRole;
          this._remoteSdp.updateDtlsRole(localDtlsRole === "client" ? "server" : "client");
          await new Promise((resolve, reject) => {
            this.safeEmit("@connect", { dtlsParameters }, resolve, reject);
          });
          this._transportReady = true;
        }
        assertNotClosed() {
          if (this._closed) {
            throw new errors_1.InvalidStateError("method called in a closed handler");
          }
        }
        assertSendDirection() {
          if (this._direction !== "send") {
            throw new Error('method can just be called for handlers with "send" direction');
          }
        }
        assertRecvDirection() {
          if (this._direction !== "recv") {
            throw new Error('method can just be called for handlers with "recv" direction');
          }
        }
      };
      exports.ReactNativeUnifiedPlan = ReactNativeUnifiedPlan;
    }
  });

  // ../../node_modules/mediasoup-client/lib/handlers/ReactNative.js
  var require_ReactNative = __commonJS({
    "../../node_modules/mediasoup-client/lib/handlers/ReactNative.js"(exports) {
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ReactNative = void 0;
      var sdpTransform = __importStar(require_lib3());
      var Logger_1 = require_Logger();
      var errors_1 = require_errors();
      var utils = __importStar(require_utils());
      var ortc = __importStar(require_ortc());
      var sdpCommonUtils = __importStar(require_commonUtils());
      var sdpPlanBUtils = __importStar(require_planBUtils());
      var HandlerInterface_1 = require_HandlerInterface();
      var RemoteSdp_1 = require_RemoteSdp();
      var logger13 = new Logger_1.Logger("ReactNative");
      var NAME = "ReactNative";
      var SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };
      var ReactNative = class _ReactNative extends HandlerInterface_1.HandlerInterface {
        /**
         * Creates a factory function.
         */
        static createFactory() {
          return () => new _ReactNative();
        }
        constructor() {
          super();
          this._sendStream = new MediaStream();
          this._mapSendLocalIdTrack = /* @__PURE__ */ new Map();
          this._nextSendLocalId = 0;
          this._mapRecvLocalIdInfo = /* @__PURE__ */ new Map();
          this._hasDataChannelMediaSection = false;
          this._nextSendSctpStreamId = 0;
          this._transportReady = false;
        }
        get name() {
          return NAME;
        }
        close() {
          logger13.debug("close()");
          this._sendStream.release(
            /* releaseTracks */
            false
          );
          if (this._pc) {
            try {
              this._pc.close();
            } catch (error) {
            }
          }
          this.emit("@close");
        }
        async getNativeRtpCapabilities() {
          logger13.debug("getNativeRtpCapabilities()");
          const pc = new RTCPeerConnection({
            iceServers: [],
            iceTransportPolicy: "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require",
            sdpSemantics: "plan-b"
          });
          try {
            const offer = await pc.createOffer({
              offerToReceiveAudio: true,
              offerToReceiveVideo: true
            });
            try {
              pc.close();
            } catch (error) {
            }
            const sdpObject = sdpTransform.parse(offer.sdp);
            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
              sdpObject
            });
            return nativeRtpCapabilities;
          } catch (error) {
            try {
              pc.close();
            } catch (error2) {
            }
            throw error;
          }
        }
        async getNativeSctpCapabilities() {
          logger13.debug("getNativeSctpCapabilities()");
          return {
            numStreams: SCTP_NUM_STREAMS
          };
        }
        run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities }) {
          logger13.debug("run()");
          this._direction = direction;
          this._remoteSdp = new RemoteSdp_1.RemoteSdp({
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
            planB: true
          });
          this._sendingRtpParametersByKind = {
            audio: ortc.getSendingRtpParameters("audio", extendedRtpCapabilities),
            video: ortc.getSendingRtpParameters("video", extendedRtpCapabilities)
          };
          this._sendingRemoteRtpParametersByKind = {
            audio: ortc.getSendingRemoteRtpParameters("audio", extendedRtpCapabilities),
            video: ortc.getSendingRemoteRtpParameters("video", extendedRtpCapabilities)
          };
          if (dtlsParameters.role && dtlsParameters.role !== "auto") {
            this._forcedLocalDtlsRole = dtlsParameters.role === "server" ? "client" : "server";
          }
          this._pc = new RTCPeerConnection({
            iceServers: iceServers ?? [],
            iceTransportPolicy: iceTransportPolicy ?? "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require",
            sdpSemantics: "plan-b",
            ...additionalSettings
          }, proprietaryConstraints);
          this._pc.addEventListener("icegatheringstatechange", () => {
            this.emit("@icegatheringstatechange", this._pc.iceGatheringState);
          });
          if (this._pc.connectionState) {
            this._pc.addEventListener("connectionstatechange", () => {
              this.emit("@connectionstatechange", this._pc.connectionState);
            });
          } else {
            this._pc.addEventListener("iceconnectionstatechange", () => {
              logger13.warn("run() | pc.connectionState not supported, using pc.iceConnectionState");
              switch (this._pc.iceConnectionState) {
                case "checking": {
                  this.emit("@connectionstatechange", "connecting");
                  break;
                }
                case "connected":
                case "completed": {
                  this.emit("@connectionstatechange", "connected");
                  break;
                }
                case "failed": {
                  this.emit("@connectionstatechange", "failed");
                  break;
                }
                case "disconnected": {
                  this.emit("@connectionstatechange", "disconnected");
                  break;
                }
                case "closed": {
                  this.emit("@connectionstatechange", "closed");
                  break;
                }
              }
            });
          }
        }
        async updateIceServers(iceServers) {
          logger13.debug("updateIceServers()");
          const configuration = this._pc.getConfiguration();
          configuration.iceServers = iceServers;
          this._pc.setConfiguration(configuration);
        }
        async restartIce(iceParameters) {
          logger13.debug("restartIce()");
          this._remoteSdp.updateIceParameters(iceParameters);
          if (!this._transportReady) {
            return;
          }
          if (this._direction === "send") {
            const offer = await this._pc.createOffer({ iceRestart: true });
            logger13.debug("restartIce() | calling pc.setLocalDescription() [offer:%o]", offer);
            await this._pc.setLocalDescription(offer);
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger13.debug("restartIce() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setRemoteDescription(answer);
          } else {
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger13.debug("restartIce() | calling pc.setRemoteDescription() [offer:%o]", offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger13.debug("restartIce() | calling pc.setLocalDescription() [answer:%o]", answer);
            await this._pc.setLocalDescription(answer);
          }
        }
        async getTransportStats() {
          return this._pc.getStats();
        }
        async send({ track, encodings, codecOptions, codec }) {
          this.assertSendDirection();
          logger13.debug("send() [kind:%s, track.id:%s]", track.kind, track.id);
          if (codec) {
            logger13.warn("send() | codec selection is not available in %s handler", this.name);
          }
          this._sendStream.addTrack(track);
          this._pc.addStream(this._sendStream);
          let offer = await this._pc.createOffer();
          let localSdpObject = sdpTransform.parse(offer.sdp);
          let offerMediaObject;
          const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);
          sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs);
          const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);
          sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs);
          if (!this._transportReady) {
            await this.setupTransport({
              localDtlsRole: this._forcedLocalDtlsRole ?? "client",
              localSdpObject
            });
          }
          if (track.kind === "video" && encodings && encodings.length > 1) {
            logger13.debug("send() | enabling simulcast");
            localSdpObject = sdpTransform.parse(offer.sdp);
            offerMediaObject = localSdpObject.media.find((m) => m.type === "video");
            sdpPlanBUtils.addLegacySimulcast({
              offerMediaObject,
              track,
              numStreams: encodings.length
            });
            offer = { type: "offer", sdp: sdpTransform.write(localSdpObject) };
          }
          logger13.debug("send() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
          offerMediaObject = localSdpObject.media.find((m) => m.type === track.kind);
          sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
            offerMediaObject
          });
          sendingRtpParameters.encodings = sdpPlanBUtils.getRtpEncodings({
            offerMediaObject,
            track
          });
          if (encodings) {
            for (let idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {
              if (encodings[idx]) {
                Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);
              }
            }
          }
          if (sendingRtpParameters.encodings.length > 1 && (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/vp8" || sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/h264")) {
            for (const encoding of sendingRtpParameters.encodings) {
              encoding.scalabilityMode = "L1T3";
            }
          }
          this._remoteSdp.send({
            offerMediaObject,
            offerRtpParameters: sendingRtpParameters,
            answerRtpParameters: sendingRemoteRtpParameters,
            codecOptions
          });
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger13.debug("send() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
          const localId = String(this._nextSendLocalId);
          this._nextSendLocalId++;
          this._mapSendLocalIdTrack.set(localId, track);
          return {
            localId,
            rtpParameters: sendingRtpParameters
          };
        }
        async stopSending(localId) {
          this.assertSendDirection();
          logger13.debug("stopSending() [localId:%s]", localId);
          const track = this._mapSendLocalIdTrack.get(localId);
          if (!track) {
            throw new Error("track not found");
          }
          this._mapSendLocalIdTrack.delete(localId);
          this._sendStream.removeTrack(track);
          this._pc.addStream(this._sendStream);
          const offer = await this._pc.createOffer();
          logger13.debug("stopSending() | calling pc.setLocalDescription() [offer:%o]", offer);
          try {
            await this._pc.setLocalDescription(offer);
          } catch (error) {
            if (this._sendStream.getTracks().length === 0) {
              logger13.warn("stopSending() | ignoring expected error due no sending tracks: %s", error.toString());
              return;
            }
            throw error;
          }
          if (this._pc.signalingState === "stable") {
            return;
          }
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger13.debug("stopSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        async pauseSending(localId) {
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        async resumeSending(localId) {
        }
        async replaceTrack(localId, track) {
          throw new errors_1.UnsupportedError("not implemented");
        }
        async setMaxSpatialLayer(localId, spatialLayer) {
          throw new errors_1.UnsupportedError("not implemented");
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        async setRtpEncodingParameters(localId, params) {
          throw new errors_1.UnsupportedError("not implemented");
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        async getSenderStats(localId) {
          throw new errors_1.UnsupportedError("not implemented");
        }
        async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol }) {
          this.assertSendDirection();
          const options = {
            negotiated: true,
            id: this._nextSendSctpStreamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmitTime: maxPacketLifeTime,
            // NOTE: Old spec.
            maxRetransmits,
            protocol
          };
          logger13.debug("sendDataChannel() [options:%o]", options);
          const dataChannel = this._pc.createDataChannel(label, options);
          this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
          if (!this._hasDataChannelMediaSection) {
            const offer = await this._pc.createOffer();
            const localSdpObject = sdpTransform.parse(offer.sdp);
            const offerMediaObject = localSdpObject.media.find((m) => m.type === "application");
            if (!this._transportReady) {
              await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                localSdpObject
              });
            }
            logger13.debug("sendDataChannel() | calling pc.setLocalDescription() [offer:%o]", offer);
            await this._pc.setLocalDescription(offer);
            this._remoteSdp.sendSctpAssociation({ offerMediaObject });
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger13.debug("sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setRemoteDescription(answer);
            this._hasDataChannelMediaSection = true;
          }
          const sctpStreamParameters = {
            streamId: options.id,
            ordered: options.ordered,
            maxPacketLifeTime: options.maxPacketLifeTime,
            maxRetransmits: options.maxRetransmits
          };
          return { dataChannel, sctpStreamParameters };
        }
        async receive(optionsList) {
          this.assertRecvDirection();
          const results = [];
          const mapStreamId = /* @__PURE__ */ new Map();
          for (const options of optionsList) {
            const { trackId, kind, rtpParameters } = options;
            logger13.debug("receive() [trackId:%s, kind:%s]", trackId, kind);
            const mid = kind;
            let streamId = options.streamId ?? rtpParameters.rtcp.cname;
            logger13.debug("receive() | forcing a random remote streamId to avoid well known bug in react-native-webrtc");
            streamId += `-hack-${utils.generateRandomNumber()}`;
            mapStreamId.set(trackId, streamId);
            this._remoteSdp.receive({
              mid,
              kind,
              offerRtpParameters: rtpParameters,
              streamId,
              trackId
            });
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger13.debug("receive() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          let answer = await this._pc.createAnswer();
          const localSdpObject = sdpTransform.parse(answer.sdp);
          for (const options of optionsList) {
            const { kind, rtpParameters } = options;
            const mid = kind;
            const answerMediaObject = localSdpObject.media.find((m) => String(m.mid) === mid);
            sdpCommonUtils.applyCodecParameters({
              offerRtpParameters: rtpParameters,
              answerMediaObject
            });
          }
          answer = { type: "answer", sdp: sdpTransform.write(localSdpObject) };
          if (!this._transportReady) {
            await this.setupTransport({
              localDtlsRole: this._forcedLocalDtlsRole ?? "client",
              localSdpObject
            });
          }
          logger13.debug("receive() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
          for (const options of optionsList) {
            const { kind, trackId, rtpParameters } = options;
            const localId = trackId;
            const mid = kind;
            const streamId = mapStreamId.get(trackId);
            const stream = this._pc.getRemoteStreams().find((s) => s.id === streamId);
            const track = stream.getTrackById(localId);
            if (!track) {
              throw new Error("remote track not found");
            }
            this._mapRecvLocalIdInfo.set(localId, { mid, rtpParameters });
            results.push({ localId, track });
          }
          return results;
        }
        async stopReceiving(localIds) {
          this.assertRecvDirection();
          for (const localId of localIds) {
            logger13.debug("stopReceiving() [localId:%s]", localId);
            const { mid, rtpParameters } = this._mapRecvLocalIdInfo.get(localId) ?? {};
            this._mapRecvLocalIdInfo.delete(localId);
            this._remoteSdp.planBStopReceiving({
              mid,
              offerRtpParameters: rtpParameters
            });
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger13.debug("stopReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          const answer = await this._pc.createAnswer();
          logger13.debug("stopReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
        }
        async pauseReceiving(localIds) {
        }
        async resumeReceiving(localIds) {
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        async getReceiverStats(localId) {
          throw new errors_1.UnsupportedError("not implemented");
        }
        async receiveDataChannel({ sctpStreamParameters, label, protocol }) {
          this.assertRecvDirection();
          const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;
          const options = {
            negotiated: true,
            id: streamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmitTime: maxPacketLifeTime,
            // NOTE: Old spec.
            maxRetransmits,
            protocol
          };
          logger13.debug("receiveDataChannel() [options:%o]", options);
          const dataChannel = this._pc.createDataChannel(label, options);
          if (!this._hasDataChannelMediaSection) {
            this._remoteSdp.receiveSctpAssociation({ oldDataChannelSpec: true });
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger13.debug("receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]", offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            if (!this._transportReady) {
              const localSdpObject = sdpTransform.parse(answer.sdp);
              await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                localSdpObject
              });
            }
            logger13.debug("receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setLocalDescription(answer);
            this._hasDataChannelMediaSection = true;
          }
          return { dataChannel };
        }
        async setupTransport({ localDtlsRole, localSdpObject }) {
          if (!localSdpObject) {
            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
          }
          const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
            sdpObject: localSdpObject
          });
          dtlsParameters.role = localDtlsRole;
          this._remoteSdp.updateDtlsRole(localDtlsRole === "client" ? "server" : "client");
          await new Promise((resolve, reject) => {
            this.safeEmit("@connect", { dtlsParameters }, resolve, reject);
          });
          this._transportReady = true;
        }
        assertSendDirection() {
          if (this._direction !== "send") {
            throw new Error('method can just be called for handlers with "send" direction');
          }
        }
        assertRecvDirection() {
          if (this._direction !== "recv") {
            throw new Error('method can just be called for handlers with "recv" direction');
          }
        }
      };
      exports.ReactNative = ReactNative;
    }
  });

  // ../../node_modules/mediasoup-client/lib/Device.js
  var require_Device = __commonJS({
    "../../node_modules/mediasoup-client/lib/Device.js"(exports) {
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Device = void 0;
      exports.detectDevice = detectDevice2;
      var ua_parser_js_1 = require_ua_parser();
      var Logger_1 = require_Logger();
      var enhancedEvents_1 = require_enhancedEvents();
      var errors_1 = require_errors();
      var utils = __importStar(require_utils());
      var ortc = __importStar(require_ortc());
      var Transport_1 = require_Transport();
      var Chrome111_1 = require_Chrome111();
      var Chrome74_1 = require_Chrome74();
      var Chrome70_1 = require_Chrome70();
      var Chrome67_1 = require_Chrome67();
      var Chrome55_1 = require_Chrome55();
      var Firefox120_1 = require_Firefox120();
      var Firefox60_1 = require_Firefox60();
      var Safari12_1 = require_Safari12();
      var Safari11_1 = require_Safari11();
      var Edge11_1 = require_Edge11();
      var ReactNativeUnifiedPlan_1 = require_ReactNativeUnifiedPlan();
      var ReactNative_1 = require_ReactNative();
      var logger13 = new Logger_1.Logger("Device");
      function detectDevice2() {
        if (typeof navigator === "object" && navigator.product === "ReactNative") {
          logger13.debug("detectDevice() | React-Native detected");
          if (typeof RTCPeerConnection === "undefined") {
            logger13.warn("detectDevice() | unsupported react-native-webrtc without RTCPeerConnection, forgot to call registerGlobals()?");
            return void 0;
          }
          if (typeof RTCRtpTransceiver !== "undefined") {
            logger13.debug("detectDevice() | ReactNative UnifiedPlan handler chosen");
            return "ReactNativeUnifiedPlan";
          } else {
            logger13.debug("detectDevice() | ReactNative PlanB handler chosen");
            return "ReactNative";
          }
        } else if (typeof navigator === "object" && typeof navigator.userAgent === "string") {
          const ua = navigator.userAgent;
          const uaParser = new ua_parser_js_1.UAParser(ua);
          logger13.debug("detectDevice() | browser detected [ua:%s, parsed:%o]", ua, uaParser.getResult());
          const browser = uaParser.getBrowser();
          const browserName = browser.name?.toLowerCase();
          const browserVersion = parseInt(browser.major ?? "0");
          const engine = uaParser.getEngine();
          const engineName = engine.name?.toLowerCase();
          const os = uaParser.getOS();
          const osName = os.name?.toLowerCase();
          const osVersion = parseFloat(os.version ?? "0");
          const device = uaParser.getDevice();
          const deviceModel = device.model?.toLowerCase();
          const isIOS = osName === "ios" || deviceModel === "ipad";
          const isChrome = browserName && [
            "chrome",
            "chromium",
            "mobile chrome",
            "chrome webview",
            "chrome headless"
          ].includes(browserName);
          const isFirefox = browserName && ["firefox", "mobile firefox", "mobile focus"].includes(browserName);
          const isSafari = browserName && ["safari", "mobile safari"].includes(browserName);
          const isEdge = browserName && ["edge"].includes(browserName);
          if ((isChrome || isEdge) && !isIOS && browserVersion >= 111) {
            return "Chrome111";
          } else if (isChrome && !isIOS && browserVersion >= 74 || isEdge && !isIOS && browserVersion >= 88) {
            return "Chrome74";
          } else if (isChrome && !isIOS && browserVersion >= 70) {
            return "Chrome70";
          } else if (isChrome && !isIOS && browserVersion >= 67) {
            return "Chrome67";
          } else if (isChrome && !isIOS && browserVersion >= 55) {
            return "Chrome55";
          } else if (isFirefox && !isIOS && browserVersion >= 120) {
            return "Firefox120";
          } else if (isFirefox && !isIOS && browserVersion >= 60) {
            return "Firefox60";
          } else if (isFirefox && isIOS && osVersion >= 14.3) {
            return "Safari12";
          } else if (isSafari && browserVersion >= 12 && typeof RTCRtpTransceiver !== "undefined" && RTCRtpTransceiver.prototype.hasOwnProperty("currentDirection")) {
            return "Safari12";
          } else if (isSafari && browserVersion >= 11) {
            return "Safari11";
          } else if (isEdge && !isIOS && browserVersion >= 11 && browserVersion <= 18) {
            return "Edge11";
          } else if (engineName === "webkit" && isIOS && typeof RTCRtpTransceiver !== "undefined" && RTCRtpTransceiver.prototype.hasOwnProperty("currentDirection")) {
            return "Safari12";
          } else if (engineName === "blink") {
            const match = ua.match(/(?:(?:Chrome|Chromium))[ /](\w+)/i);
            if (match) {
              const version = Number(match[1]);
              if (version >= 111) {
                return "Chrome111";
              } else if (version >= 74) {
                return "Chrome74";
              } else if (version >= 70) {
                return "Chrome70";
              } else if (version >= 67) {
                return "Chrome67";
              } else {
                return "Chrome55";
              }
            } else {
              return "Chrome111";
            }
          } else {
            logger13.warn("detectDevice() | browser not supported [name:%s, version:%s]", browserName, browserVersion);
            return void 0;
          }
        } else {
          logger13.warn("detectDevice() | unknown device");
          return void 0;
        }
      }
      var Device2 = class {
        /**
         * Create a new Device to connect to mediasoup server.
         *
         * @throws {UnsupportedError} if device is not supported.
         */
        constructor({ handlerName, handlerFactory, Handler } = {}) {
          this._loaded = false;
          this._observer = new enhancedEvents_1.EnhancedEventEmitter();
          logger13.debug("constructor()");
          if (Handler) {
            logger13.warn("constructor() | Handler option is DEPRECATED, use handlerName or handlerFactory instead");
            if (typeof Handler === "string") {
              handlerName = Handler;
            } else {
              throw new TypeError("non string Handler option no longer supported, use handlerFactory instead");
            }
          }
          if (handlerName && handlerFactory) {
            throw new TypeError("just one of handlerName or handlerInterface can be given");
          }
          if (handlerFactory) {
            this._handlerFactory = handlerFactory;
          } else {
            if (handlerName) {
              logger13.debug("constructor() | handler given: %s", handlerName);
            } else {
              handlerName = detectDevice2();
              if (handlerName) {
                logger13.debug("constructor() | detected handler: %s", handlerName);
              } else {
                throw new errors_1.UnsupportedError("device not supported");
              }
            }
            switch (handlerName) {
              case "Chrome111": {
                this._handlerFactory = Chrome111_1.Chrome111.createFactory();
                break;
              }
              case "Chrome74": {
                this._handlerFactory = Chrome74_1.Chrome74.createFactory();
                break;
              }
              case "Chrome70": {
                this._handlerFactory = Chrome70_1.Chrome70.createFactory();
                break;
              }
              case "Chrome67": {
                this._handlerFactory = Chrome67_1.Chrome67.createFactory();
                break;
              }
              case "Chrome55": {
                this._handlerFactory = Chrome55_1.Chrome55.createFactory();
                break;
              }
              case "Firefox120": {
                this._handlerFactory = Firefox120_1.Firefox120.createFactory();
                break;
              }
              case "Firefox60": {
                this._handlerFactory = Firefox60_1.Firefox60.createFactory();
                break;
              }
              case "Safari12": {
                this._handlerFactory = Safari12_1.Safari12.createFactory();
                break;
              }
              case "Safari11": {
                this._handlerFactory = Safari11_1.Safari11.createFactory();
                break;
              }
              case "Edge11": {
                this._handlerFactory = Edge11_1.Edge11.createFactory();
                break;
              }
              case "ReactNativeUnifiedPlan": {
                this._handlerFactory = ReactNativeUnifiedPlan_1.ReactNativeUnifiedPlan.createFactory();
                break;
              }
              case "ReactNative": {
                this._handlerFactory = ReactNative_1.ReactNative.createFactory();
                break;
              }
              default: {
                throw new TypeError(`unknown handlerName "${handlerName}"`);
              }
            }
          }
          const handler = this._handlerFactory();
          this._handlerName = handler.name;
          handler.close();
          this._extendedRtpCapabilities = void 0;
          this._recvRtpCapabilities = void 0;
          this._canProduceByKind = {
            audio: false,
            video: false
          };
          this._sctpCapabilities = void 0;
        }
        /**
         * The RTC handler name.
         */
        get handlerName() {
          return this._handlerName;
        }
        /**
         * Whether the Device is loaded.
         */
        get loaded() {
          return this._loaded;
        }
        /**
         * RTP capabilities of the Device for receiving media.
         *
         * @throws {InvalidStateError} if not loaded.
         */
        get rtpCapabilities() {
          if (!this._loaded) {
            throw new errors_1.InvalidStateError("not loaded");
          }
          return this._recvRtpCapabilities;
        }
        /**
         * SCTP capabilities of the Device.
         *
         * @throws {InvalidStateError} if not loaded.
         */
        get sctpCapabilities() {
          if (!this._loaded) {
            throw new errors_1.InvalidStateError("not loaded");
          }
          return this._sctpCapabilities;
        }
        get observer() {
          return this._observer;
        }
        /**
         * Initialize the Device.
         */
        async load({ routerRtpCapabilities }) {
          logger13.debug("load() [routerRtpCapabilities:%o]", routerRtpCapabilities);
          let handler;
          try {
            if (this._loaded) {
              throw new errors_1.InvalidStateError("already loaded");
            }
            const clonedRouterRtpCapabilities = utils.clone(routerRtpCapabilities);
            ortc.validateRtpCapabilities(clonedRouterRtpCapabilities);
            handler = this._handlerFactory();
            const nativeRtpCapabilities = await handler.getNativeRtpCapabilities();
            logger13.debug("load() | got native RTP capabilities:%o", nativeRtpCapabilities);
            const clonedNativeRtpCapabilities = utils.clone(nativeRtpCapabilities);
            ortc.validateRtpCapabilities(clonedNativeRtpCapabilities);
            this._extendedRtpCapabilities = ortc.getExtendedRtpCapabilities(clonedNativeRtpCapabilities, clonedRouterRtpCapabilities);
            logger13.debug("load() | got extended RTP capabilities:%o", this._extendedRtpCapabilities);
            this._canProduceByKind.audio = ortc.canSend("audio", this._extendedRtpCapabilities);
            this._canProduceByKind.video = ortc.canSend("video", this._extendedRtpCapabilities);
            this._recvRtpCapabilities = ortc.getRecvRtpCapabilities(this._extendedRtpCapabilities);
            ortc.validateRtpCapabilities(this._recvRtpCapabilities);
            logger13.debug("load() | got receiving RTP capabilities:%o", this._recvRtpCapabilities);
            this._sctpCapabilities = await handler.getNativeSctpCapabilities();
            logger13.debug("load() | got native SCTP capabilities:%o", this._sctpCapabilities);
            ortc.validateSctpCapabilities(this._sctpCapabilities);
            logger13.debug("load() succeeded");
            this._loaded = true;
            handler.close();
          } catch (error) {
            if (handler) {
              handler.close();
            }
            throw error;
          }
        }
        /**
         * Whether we can produce audio/video.
         *
         * @throws {InvalidStateError} if not loaded.
         * @throws {TypeError} if wrong arguments.
         */
        canProduce(kind) {
          if (!this._loaded) {
            throw new errors_1.InvalidStateError("not loaded");
          } else if (kind !== "audio" && kind !== "video") {
            throw new TypeError(`invalid kind "${kind}"`);
          }
          return this._canProduceByKind[kind];
        }
        /**
         * Creates a Transport for sending media.
         *
         * @throws {InvalidStateError} if not loaded.
         * @throws {TypeError} if wrong arguments.
         */
        createSendTransport({ id, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, appData }) {
          logger13.debug("createSendTransport()");
          return this.createTransport({
            direction: "send",
            id,
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
            iceServers,
            iceTransportPolicy,
            additionalSettings,
            proprietaryConstraints,
            appData
          });
        }
        /**
         * Creates a Transport for receiving media.
         *
         * @throws {InvalidStateError} if not loaded.
         * @throws {TypeError} if wrong arguments.
         */
        createRecvTransport({ id, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, appData }) {
          logger13.debug("createRecvTransport()");
          return this.createTransport({
            direction: "recv",
            id,
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
            iceServers,
            iceTransportPolicy,
            additionalSettings,
            proprietaryConstraints,
            appData
          });
        }
        createTransport({ direction, id, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, appData }) {
          if (!this._loaded) {
            throw new errors_1.InvalidStateError("not loaded");
          } else if (typeof id !== "string") {
            throw new TypeError("missing id");
          } else if (typeof iceParameters !== "object") {
            throw new TypeError("missing iceParameters");
          } else if (!Array.isArray(iceCandidates)) {
            throw new TypeError("missing iceCandidates");
          } else if (typeof dtlsParameters !== "object") {
            throw new TypeError("missing dtlsParameters");
          } else if (sctpParameters && typeof sctpParameters !== "object") {
            throw new TypeError("wrong sctpParameters");
          } else if (appData && typeof appData !== "object") {
            throw new TypeError("if given, appData must be an object");
          }
          const transport = new Transport_1.Transport({
            direction,
            id,
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
            iceServers,
            iceTransportPolicy,
            additionalSettings,
            proprietaryConstraints,
            appData,
            handlerFactory: this._handlerFactory,
            extendedRtpCapabilities: this._extendedRtpCapabilities,
            canProduceByKind: this._canProduceByKind
          });
          this._observer.safeEmit("newtransport", transport);
          return transport;
        }
      };
      exports.Device = Device2;
    }
  });

  // ../../node_modules/mediasoup-client/lib/RtpParameters.js
  var require_RtpParameters = __commonJS({
    "../../node_modules/mediasoup-client/lib/RtpParameters.js"(exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
    }
  });

  // ../../node_modules/mediasoup-client/lib/SctpParameters.js
  var require_SctpParameters = __commonJS({
    "../../node_modules/mediasoup-client/lib/SctpParameters.js"(exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
    }
  });

  // ../../node_modules/mediasoup-client/lib/types.js
  var require_types = __commonJS({
    "../../node_modules/mediasoup-client/lib/types.js"(exports) {
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      });
      var __exportStar = exports && exports.__exportStar || function(m, exports2) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      __exportStar(require_Device(), exports);
      __exportStar(require_Transport(), exports);
      __exportStar(require_Producer(), exports);
      __exportStar(require_Consumer(), exports);
      __exportStar(require_DataProducer(), exports);
      __exportStar(require_DataConsumer(), exports);
      __exportStar(require_RtpParameters(), exports);
      __exportStar(require_SctpParameters(), exports);
      __exportStar(require_HandlerInterface(), exports);
      __exportStar(require_errors(), exports);
    }
  });

  // ../../node_modules/mediasoup-client/lib/index.js
  var require_lib4 = __commonJS({
    "../../node_modules/mediasoup-client/lib/index.js"(exports) {
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.debug = exports.parseScalabilityMode = exports.detectDevice = exports.Device = exports.version = exports.types = void 0;
      var debug_1 = __importDefault(require_browser());
      exports.debug = debug_1.default;
      var Device_1 = require_Device();
      Object.defineProperty(exports, "Device", { enumerable: true, get: function() {
        return Device_1.Device;
      } });
      Object.defineProperty(exports, "detectDevice", { enumerable: true, get: function() {
        return Device_1.detectDevice;
      } });
      var types = __importStar(require_types());
      exports.types = types;
      exports.version = "3.7.16";
      var scalabilityModes_1 = require_scalabilityModes();
      Object.defineProperty(exports, "parseScalabilityMode", { enumerable: true, get: function() {
        return scalabilityModes_1.parse;
      } });
    }
  });

  // ../../node_modules/events/events.js
  var require_events2 = __commonJS({
    "../../node_modules/events/events.js"(exports, module) {
      var R = typeof Reflect === "object" ? Reflect : null;
      var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
        return Function.prototype.apply.call(target, receiver, args);
      };
      var ReflectOwnKeys;
      if (R && typeof R.ownKeys === "function") {
        ReflectOwnKeys = R.ownKeys;
      } else if (Object.getOwnPropertySymbols) {
        ReflectOwnKeys = function ReflectOwnKeys2(target) {
          return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
        };
      } else {
        ReflectOwnKeys = function ReflectOwnKeys2(target) {
          return Object.getOwnPropertyNames(target);
        };
      }
      function ProcessEmitWarning(warning) {
        if (console && console.warn) console.warn(warning);
      }
      var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
        return value !== value;
      };
      function EventEmitter2() {
        EventEmitter2.init.call(this);
      }
      module.exports = EventEmitter2;
      module.exports.once = once;
      EventEmitter2.EventEmitter = EventEmitter2;
      EventEmitter2.prototype._events = void 0;
      EventEmitter2.prototype._eventsCount = 0;
      EventEmitter2.prototype._maxListeners = void 0;
      var defaultMaxListeners = 10;
      function checkListener(listener) {
        if (typeof listener !== "function") {
          throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
        }
      }
      Object.defineProperty(EventEmitter2, "defaultMaxListeners", {
        enumerable: true,
        get: function() {
          return defaultMaxListeners;
        },
        set: function(arg) {
          if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
            throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
          }
          defaultMaxListeners = arg;
        }
      });
      EventEmitter2.init = function() {
        if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        }
        this._maxListeners = this._maxListeners || void 0;
      };
      EventEmitter2.prototype.setMaxListeners = function setMaxListeners(n) {
        if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
          throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
        }
        this._maxListeners = n;
        return this;
      };
      function _getMaxListeners(that) {
        if (that._maxListeners === void 0)
          return EventEmitter2.defaultMaxListeners;
        return that._maxListeners;
      }
      EventEmitter2.prototype.getMaxListeners = function getMaxListeners() {
        return _getMaxListeners(this);
      };
      EventEmitter2.prototype.emit = function emit(type) {
        var args = [];
        for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
        var doError = type === "error";
        var events = this._events;
        if (events !== void 0)
          doError = doError && events.error === void 0;
        else if (!doError)
          return false;
        if (doError) {
          var er;
          if (args.length > 0)
            er = args[0];
          if (er instanceof Error) {
            throw er;
          }
          var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
          err.context = er;
          throw err;
        }
        var handler = events[type];
        if (handler === void 0)
          return false;
        if (typeof handler === "function") {
          ReflectApply(handler, this, args);
        } else {
          var len = handler.length;
          var listeners = arrayClone(handler, len);
          for (var i = 0; i < len; ++i)
            ReflectApply(listeners[i], this, args);
        }
        return true;
      };
      function _addListener(target, type, listener, prepend) {
        var m;
        var events;
        var existing;
        checkListener(listener);
        events = target._events;
        if (events === void 0) {
          events = target._events = /* @__PURE__ */ Object.create(null);
          target._eventsCount = 0;
        } else {
          if (events.newListener !== void 0) {
            target.emit(
              "newListener",
              type,
              listener.listener ? listener.listener : listener
            );
            events = target._events;
          }
          existing = events[type];
        }
        if (existing === void 0) {
          existing = events[type] = listener;
          ++target._eventsCount;
        } else {
          if (typeof existing === "function") {
            existing = events[type] = prepend ? [listener, existing] : [existing, listener];
          } else if (prepend) {
            existing.unshift(listener);
          } else {
            existing.push(listener);
          }
          m = _getMaxListeners(target);
          if (m > 0 && existing.length > m && !existing.warned) {
            existing.warned = true;
            var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
            w.name = "MaxListenersExceededWarning";
            w.emitter = target;
            w.type = type;
            w.count = existing.length;
            ProcessEmitWarning(w);
          }
        }
        return target;
      }
      EventEmitter2.prototype.addListener = function addListener(type, listener) {
        return _addListener(this, type, listener, false);
      };
      EventEmitter2.prototype.on = EventEmitter2.prototype.addListener;
      EventEmitter2.prototype.prependListener = function prependListener(type, listener) {
        return _addListener(this, type, listener, true);
      };
      function onceWrapper() {
        if (!this.fired) {
          this.target.removeListener(this.type, this.wrapFn);
          this.fired = true;
          if (arguments.length === 0)
            return this.listener.call(this.target);
          return this.listener.apply(this.target, arguments);
        }
      }
      function _onceWrap(target, type, listener) {
        var state = { fired: false, wrapFn: void 0, target, type, listener };
        var wrapped = onceWrapper.bind(state);
        wrapped.listener = listener;
        state.wrapFn = wrapped;
        return wrapped;
      }
      EventEmitter2.prototype.once = function once2(type, listener) {
        checkListener(listener);
        this.on(type, _onceWrap(this, type, listener));
        return this;
      };
      EventEmitter2.prototype.prependOnceListener = function prependOnceListener(type, listener) {
        checkListener(listener);
        this.prependListener(type, _onceWrap(this, type, listener));
        return this;
      };
      EventEmitter2.prototype.removeListener = function removeListener(type, listener) {
        var list, events, position, i, originalListener;
        checkListener(listener);
        events = this._events;
        if (events === void 0)
          return this;
        list = events[type];
        if (list === void 0)
          return this;
        if (list === listener || list.listener === listener) {
          if (--this._eventsCount === 0)
            this._events = /* @__PURE__ */ Object.create(null);
          else {
            delete events[type];
            if (events.removeListener)
              this.emit("removeListener", type, list.listener || listener);
          }
        } else if (typeof list !== "function") {
          position = -1;
          for (i = list.length - 1; i >= 0; i--) {
            if (list[i] === listener || list[i].listener === listener) {
              originalListener = list[i].listener;
              position = i;
              break;
            }
          }
          if (position < 0)
            return this;
          if (position === 0)
            list.shift();
          else {
            spliceOne(list, position);
          }
          if (list.length === 1)
            events[type] = list[0];
          if (events.removeListener !== void 0)
            this.emit("removeListener", type, originalListener || listener);
        }
        return this;
      };
      EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
      EventEmitter2.prototype.removeAllListeners = function removeAllListeners(type) {
        var listeners, events, i;
        events = this._events;
        if (events === void 0)
          return this;
        if (events.removeListener === void 0) {
          if (arguments.length === 0) {
            this._events = /* @__PURE__ */ Object.create(null);
            this._eventsCount = 0;
          } else if (events[type] !== void 0) {
            if (--this._eventsCount === 0)
              this._events = /* @__PURE__ */ Object.create(null);
            else
              delete events[type];
          }
          return this;
        }
        if (arguments.length === 0) {
          var keys = Object.keys(events);
          var key;
          for (i = 0; i < keys.length; ++i) {
            key = keys[i];
            if (key === "removeListener") continue;
            this.removeAllListeners(key);
          }
          this.removeAllListeners("removeListener");
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
          return this;
        }
        listeners = events[type];
        if (typeof listeners === "function") {
          this.removeListener(type, listeners);
        } else if (listeners !== void 0) {
          for (i = listeners.length - 1; i >= 0; i--) {
            this.removeListener(type, listeners[i]);
          }
        }
        return this;
      };
      function _listeners(target, type, unwrap) {
        var events = target._events;
        if (events === void 0)
          return [];
        var evlistener = events[type];
        if (evlistener === void 0)
          return [];
        if (typeof evlistener === "function")
          return unwrap ? [evlistener.listener || evlistener] : [evlistener];
        return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
      }
      EventEmitter2.prototype.listeners = function listeners(type) {
        return _listeners(this, type, true);
      };
      EventEmitter2.prototype.rawListeners = function rawListeners(type) {
        return _listeners(this, type, false);
      };
      EventEmitter2.listenerCount = function(emitter, type) {
        if (typeof emitter.listenerCount === "function") {
          return emitter.listenerCount(type);
        } else {
          return listenerCount.call(emitter, type);
        }
      };
      EventEmitter2.prototype.listenerCount = listenerCount;
      function listenerCount(type) {
        var events = this._events;
        if (events !== void 0) {
          var evlistener = events[type];
          if (typeof evlistener === "function") {
            return 1;
          } else if (evlistener !== void 0) {
            return evlistener.length;
          }
        }
        return 0;
      }
      EventEmitter2.prototype.eventNames = function eventNames() {
        return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
      };
      function arrayClone(arr, n) {
        var copy = new Array(n);
        for (var i = 0; i < n; ++i)
          copy[i] = arr[i];
        return copy;
      }
      function spliceOne(list, index) {
        for (; index + 1 < list.length; index++)
          list[index] = list[index + 1];
        list.pop();
      }
      function unwrapListeners(arr) {
        var ret = new Array(arr.length);
        for (var i = 0; i < ret.length; ++i) {
          ret[i] = arr[i].listener || arr[i];
        }
        return ret;
      }
      function once(emitter, name) {
        return new Promise(function(resolve, reject) {
          function errorListener(err) {
            emitter.removeListener(name, resolver);
            reject(err);
          }
          function resolver() {
            if (typeof emitter.removeListener === "function") {
              emitter.removeListener("error", errorListener);
            }
            resolve([].slice.call(arguments));
          }
          eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
          if (name !== "error") {
            addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
          }
        });
      }
      function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
        if (typeof emitter.on === "function") {
          eventTargetAgnosticAddListener(emitter, "error", handler, flags);
        }
      }
      function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
        if (typeof emitter.on === "function") {
          if (flags.once) {
            emitter.once(name, listener);
          } else {
            emitter.on(name, listener);
          }
        } else if (typeof emitter.addEventListener === "function") {
          emitter.addEventListener(name, function wrapListener(arg) {
            if (flags.once) {
              emitter.removeEventListener(name, wrapListener);
            }
            listener(arg);
          });
        } else {
          throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
        }
      }
    }
  });

  // src/LocalPeer.ts
  var import_mediasoup_client = __toESM(require_lib4());

  // src/common-js/EnhancedEventEmitter.ts
  var import_events = __toESM(require_events2());
  var EnhancedEventEmitter = class {
    emitter;
    constructor() {
      this.emitter = new import_events.EventEmitter();
      this.emitter.setMaxListeners(Number.POSITIVE_INFINITY);
    }
    on(eventName, listener) {
      this.emitter.on(
        eventName,
        // biome-ignore lint/suspicious/noExplicitAny: need to override the type because default it's any[ and we cannot assign E[K] to any[]
        listener
      );
      return this;
    }
    off(eventName, listener) {
      this.emitter.off(
        eventName,
        // biome-ignore lint/suspicious/noExplicitAny: <explanation>
        listener
      );
      return this;
    }
    listenerCount(eventName) {
      return this.emitter.listenerCount(eventName);
    }
    listeners(eventName) {
      return this.emitter.listeners(eventName);
    }
    emit(eventName, ...args) {
      return this.emitter.emit(eventName, ...args);
    }
    safeEmit(eventName, ...args) {
      return this.emitter.emit(eventName, ...args);
    }
    once(eventName, listener) {
      this.emitter.once(
        eventName,
        // biome-ignore lint/suspicious/noExplicitAny: <explanation>
        listener
      );
      return this;
    }
    removeAllListeners(eventName) {
      if (eventName) {
        this.emitter.removeAllListeners(eventName);
      } else {
        this.emitter.removeAllListeners();
      }
      return this;
    }
  };

  // src/constants/rtpConstants.ts
  var VIDEO_CONSTRAINTS = {
    qvga: { width: { ideal: 320 }, height: { ideal: 240 } },
    vga: { width: { ideal: 640 }, height: { ideal: 480 } },
    hd: { width: { ideal: 1280 }, height: { ideal: 720 } },
    fHd: { width: { ideal: 1920 }, height: { ideal: 1080 } },
    qHd: { width: { ideal: 4096 }, height: { ideal: 2160 } }
  };
  var WEBCAM_SIMULCAST_ENCODINGS = [
    {
      scaleResolutionDownBy: 4,
      maxBitrate: 3e5,
      // 300kbps
      rid: "r0",
      scalabilityMode: "S1T3",
      maxFramerate: 15
    },
    {
      scaleResolutionDownBy: 2,
      maxBitrate: 6e5,
      // 600kbps
      rid: "r1",
      scalabilityMode: "S1T3",
      maxFramerate: 30
    },
    {
      scaleResolutionDownBy: 1,
      maxBitrate: 9e6,
      // 900kbps
      rid: "r2",
      scalabilityMode: "S1T3",
      maxFramerate: 30
    }
  ];
  var encodingViaMediaType = {
    video: WEBCAM_SIMULCAST_ENCODINGS,
    "screen-share-video": void 0,
    audio: [{ maxBitrate: 128e3 }]
  };
  var codecOptionsViaKind = {
    audio: { opusStereo: true, opusFec: true, opusDtx: true },
    video: { videoGoogleStartBitrate: 1e3 }
  };

  // src/constants/deviceConstraints.ts
  var videoDefaultConstraints = {
    video: {
      ...VIDEO_CONSTRAINTS.hd
    }
  };
  var audioConstraints = {
    audio: {
      echoCancellation: true,
      noiseSuppression: true
    }
  };
  var shareConstraints = {
    video: {
      displaySurface: "monitor",
      logicalSurface: true,
      cursor: true,
      width: { ideal: 1920, max: 1920 },
      height: { ideal: 1080, max: 1080 },
      frameRate: { ideal: 25, max: 30 }
    },
    audio: {
      echoCancellation: true,
      noiseSuppression: true
    }
  };
  var defaultMediaConstraints = {
    cam: videoDefaultConstraints,
    mic: audioConstraints,
    screen: shareConstraints
  };
  var deviceConstraints_default = defaultMediaConstraints;

  // src/helpers/index.ts
  var getMediaStreamKind = (stream) => {
    let kind = null;
    const tracks = stream.getTracks();
    for (const track of tracks) {
      if (track.kind === "audio") {
        kind = "audio";
        break;
      }
      if (track.kind === "video") {
        kind = "video";
        break;
      }
    }
    if (!kind) {
      throw new Error("Stream Kind Not Found");
    }
    return kind;
  };
  var getMediaDeviceKind = (track) => {
    if (track.kind === "audio") {
      return "mic";
    }
    if (track.kind === "video") {
      const settings = track.getSettings();
      if (settings.displaySurface) {
        return "screen";
      }
      return "cam";
    }
    return "cam";
  };
  var getMediaTrack = (data) => {
    const { stream, kind } = data;
    const tracks = stream.getTracks();
    for (const track of tracks) {
      if (track.kind === kind) {
        return track;
      }
    }
    throw new Error("Track Not Found");
  };
  var estimateSize = (obj) => {
    const str = JSON.stringify(obj);
    return new TextEncoder().encode(str).length;
  };
  var isReactNative = () => typeof navigator !== "undefined" && navigator.product === "ReactNative";

  // src/logger.ts
  var COLORS = {
    black: "\x1B[30m",
    red: "\x1B[31m",
    green: "\x1B[32m",
    yellow: "\x1B[33m",
    blue: "\x1B[34m",
    magenta: "\x1B[35m",
    cyan: "\x1B[36m",
    white: "\x1B[37m",
    default: "\x1B[39m"
  };
  var defaultLevel = "error";
  var created = Date.now();
  function createDefaultLoggerFactory() {
    return () => {
      const trace = (...args) => {
        console.trace(...args);
      };
      const debug = (...args) => {
        console.debug(...args);
      };
      const info = (...args) => {
        console.info(...args);
      };
      const warn = (...args) => {
        console.warn(...args);
      };
      const error = (...args) => {
        console.error(...args);
      };
      return {
        trace,
        debug,
        info,
        warn,
        error
      };
    };
  }
  var wrapLogger = (logger13, moduleName, logLevel) => {
    let isTrace = false;
    let isDebug = false;
    let isInfo = false;
    let isWarning = false;
    let isError = false;
    let _level = logLevel;
    let _logger = logger13;
    const tracePrefix = `${COLORS.magenta}[TRACE]${COLORS.default} ${moduleName}`;
    const debugPrefix = `${COLORS.cyan}[DEBUG]${COLORS.default} ${moduleName}`;
    const infoPrefix = `${COLORS.green}[INFO]${COLORS.default} ${moduleName}`;
    const warnPrefix = `${COLORS.yellow}[WARN]${COLORS.default} ${moduleName}`;
    const errorPrefix = `${COLORS.red}[ERROR]${COLORS.default} ${moduleName}`;
    const result = new class {
      init() {
        isTrace = ["trace"].includes(_level ?? defaultLevel);
        isDebug = ["trace", "debug"].includes(_level ?? defaultLevel);
        isInfo = ["trace", "debug", "info"].includes(_level ?? defaultLevel);
        isWarning = ["trace", "debug", "info", "warn"].includes(
          _level ?? defaultLevel
        );
        isError = ["trace", "debug", "info", "warn", "error"].includes(
          _level ?? defaultLevel
        );
      }
      get logger() {
        return _logger;
      }
      set logger(value) {
        _logger = value;
      }
      get level() {
        return _level;
      }
      set level(value) {
        _level = value;
      }
      // biome-ignore lint/suspicious/noExplicitAny: need any
      trace(...args) {
        if (isTrace) {
          const elapsedInMs = `${COLORS.magenta}+${Date.now() - created}ms${COLORS.default}`;
          logger13.trace(tracePrefix, ...args, elapsedInMs);
        }
      }
      // biome-ignore lint/suspicious/noExplicitAny: need any
      debug(...args) {
        if (isDebug) {
          const elapsedInMs = `${COLORS.magenta}+${Date.now() - created}ms${COLORS.default}`;
          logger13.debug(debugPrefix, ...args, elapsedInMs);
        }
      }
      // biome-ignore lint/suspicious/noExplicitAny: need any
      info(...args) {
        if (isInfo) {
          const elapsedInMs = `${COLORS.magenta}+${Date.now() - created}ms${COLORS.default}`;
          logger13.info(infoPrefix, ...args, elapsedInMs);
        }
      }
      // biome-ignore lint/suspicious/noExplicitAny: need any
      warn(...args) {
        if (isWarning) {
          const elapsedInMs = `${COLORS.magenta}+${Date.now() - created}ms${COLORS.default}`;
          logger13.warn(warnPrefix, ...args, elapsedInMs);
        }
      }
      // biome-ignore lint/suspicious/noExplicitAny: need any
      error(...args) {
        if (isError) {
          const elapsedInMs = `${COLORS.magenta}+${Date.now() - created}ms${COLORS.default}`;
          logger13.error(errorPrefix, ...args, elapsedInMs);
        }
      }
    }();
    return result;
  };
  var actualLoggerFactory = createDefaultLoggerFactory();
  var loggers = /* @__PURE__ */ new Map();
  var createLogger = (moduleName, logLevel) => {
    let wrappedLogger = loggers.get(moduleName);
    if (!wrappedLogger) {
      const logger13 = actualLoggerFactory();
      wrappedLogger = wrapLogger(logger13, moduleName, logLevel ?? defaultLevel);
      loggers.set(moduleName, wrappedLogger);
    } else {
      wrappedLogger.level = logLevel ?? defaultLevel;
    }
    wrappedLogger.init();
    return wrappedLogger;
  };
  var setLogLevel = (level) => {
    defaultLevel = level;
    for (const [moduleName] of Array.from(loggers.entries())) {
      loggers.set(moduleName, createLogger(moduleName, level));
    }
  };
  var mainLogger = {
    createSubLogger: (moduleName) => createLogger(`HuddleWebCore:${moduleName}`)
  };

  // src/DeviceHandler.ts
  var logger = mainLogger.createSubLogger("DeviceHandler");
  var CustomMediaKindToSystemKind = {
    cam: "videoinput",
    mic: "audioinput",
    speaker: "audiooutput"
  };
  var DeviceHandler = class extends EnhancedEventEmitter {
    SCREEN_DEFAULT_DEVICE = "monitor";
    /**
     * User Selected Devices, If no device is selected, it will use the default device of the system
     *
     * is preffered device is null, it will use the default device of the system
     *
     * `NOTE: User has the ability to select a preferred device for each media kind`
     */
    __preferredDevices = /* @__PURE__ */ new Map([
      ["cam", null],
      ["mic", null],
      ["speaker", null]
    ]);
    /**
     * Map the media devices currently present in the system
     */
    __mediaDevicesInfo = /* @__PURE__ */ new Map([
      ["cam", []],
      ["mic", []],
      ["speaker", []]
    ]);
    /**
     * Get all the devices which are currently available in the system
     */
    get devices() {
      return this.__mediaDevicesInfo;
    }
    get preferredDevices() {
      return this.__preferredDevices;
    }
    /**
     * Get all the devices which are currently available in the system, also updates the `__mediaDevicesInfo` record
     *
     * Can also query for a specific device kind `audioinput` | `videoinput` | `audiooutput`
     *
     * @param deviceKind `cam` | `mic` | `speaker` | `undefined`
     * @returns - MediaDeviceInfo[] | null
     *
     * `NOTE`: Ask for MediaDevice Permission to get the right result for that device else it will return `null`
     */
    getMediaDevices = async (filterByDeviceKind) => {
      logger.debug("\u{1F4F9} Fetching Media Devices");
      const devices = await navigator.mediaDevices.enumerateDevices();
      if (!filterByDeviceKind || filterByDeviceKind === "device-change") {
        this.__setMediaDeviceInfo({ devices, update: "all" });
      }
      if (filterByDeviceKind === "cam" || filterByDeviceKind === "mic") {
        this.__setMediaDeviceInfo({ devices, update: filterByDeviceKind });
      }
      const mediaDevices = devices.filter((device) => {
        if (device.deviceId === "" || device.label === "") {
          return false;
        }
        if (filterByDeviceKind && filterByDeviceKind !== "device-change") {
          const systemDeviceKind = CustomMediaKindToSystemKind[filterByDeviceKind];
          return device.kind === systemDeviceKind;
        }
        return true;
      });
      return mediaDevices;
    };
    /**
     * Get the device from the given facing type of device
     *
     * This function is used for only RN
     *
     * @param facing - facing of the device { 'environment' | 'front' | 'undefined' }
     * @param mediaDeviceKind - mediaDeviceKind for the device { 'audioinput' | 'videoinput' }
     * @returns - deviceId: string | null
     *
     * `NOTE`: Ask for MediaDevice Permission to get the right result for that device else it will return `null`
     */
    getDeviceFromFacingMode = (facing, mediaDeviceKind) => {
      const allDevices = this.__mediaDevicesInfo.get(mediaDeviceKind);
      if (allDevices) {
        const d = allDevices.find((device) => device.facing === facing);
        if (d) {
          if (mediaDeviceKind === "cam") {
            return facing || d.deviceId;
          }
          return d.deviceId;
        }
      }
      return null;
    };
    setPreferredDevice = (data) => {
      const { deviceId, deviceKind } = data;
      this.__preferredDevices.set(deviceKind, deviceId);
      this.emit("preferred-device-change", {
        deviceId,
        deviceKind
      });
    };
    /**
     * Fetches a stream of the screen of the device i.e the screen sharing stream
     * based on the selected choice from the pop up returns the audio and video stream
     * in one stream.
     *
     * `NOTE: This stream is not managed by the Huddle01 SDK, i.e. it will not be closed by the SDK`
     * @returns
     */
    fetchScreen = async () => {
      const constraints = deviceConstraints_default.screen;
      try {
        const stream = await navigator.mediaDevices.getDisplayMedia(constraints);
        return { stream };
      } catch (err) {
        logger.error(err);
        let error = {
          message: "Unknown Error",
          errorStack: err
        };
        if (!isReactNative() && err instanceof DOMException) {
          error = {
            blocked: {
              byDeviceMissing: err.name === "NotFoundError",
              byDeviceInUse: err.name === "OverconstrainedError",
              byPermissions: err.name === "NotAllowedError"
            },
            message: err.message
          };
        } else {
          error = {
            message: "Screen Sharing Permission Denied",
            blocked: {
              byPermissions: true,
              byDeviceInUse: false,
              byDeviceMissing: false
            }
          };
        }
        return {
          stream: null,
          error
        };
      }
    };
    /**
     * Fetch the stream from the device for the given media kind, if no preferred device is found it will throw an error.
     * by default the preferred device is the system default device
     *
     * `NOTE: If Preffered device is not found, it will use the system default device, if no default device is found it will throw an error`
     * `Set the preferred device using setPreferredDevice()`
     *
     */
    fetchStream = async (data) => {
      const preferredDeviceId = this.__preferredDevices.get(data.mediaDeviceKind);
      logger.info("\u{1F4F9} Fetching Stream", {
        mediaDeviceKind: data.mediaDeviceKind,
        preferredDeviceId
      });
      navigator.mediaDevices.ondevicechange = async () => {
        const newMediaDevices = await this.getMediaDevices("device-change");
        for (const [deviceKind, deviceId] of this.__preferredDevices) {
          const device = newMediaDevices.find((d) => d.deviceId === deviceId);
          if (!device) {
            this.setPreferredDevice({ deviceId: null, deviceKind });
          }
        }
        this.emit("device-change");
      };
      try {
        let fetchStreamFunc;
        if (typeof navigator === "object" && navigator.product === "ReactNative") {
          fetchStreamFunc = this.__fetchStreamFromDeviceForRN;
        } else {
          fetchStreamFunc = this.__fetchStreamFromDeviceForWeb;
        }
        const { stream, deviceId } = await fetchStreamFunc({
          deviceId: preferredDeviceId ?? void 0,
          mediaKind: data.mediaDeviceKind === "mic" ? "mic" : "cam"
        });
        const track = data.mediaDeviceKind === "mic" ? stream.getAudioTracks()[0] : stream.getVideoTracks()[0];
        if (!this.__preferredDevices.get(data.mediaDeviceKind)) {
          this.setPreferredDevice({ deviceId, deviceKind: data.mediaDeviceKind });
        }
        return {
          stream,
          track,
          deviceId
        };
      } catch (err) {
        logger.error(err);
        let error = {
          message: "Unknown Error",
          errorStack: err
        };
        if (!isReactNative() && err instanceof DOMException) {
          error = {
            blocked: {
              byDeviceMissing: err.name === "NotFoundError",
              byDeviceInUse: err.name === "OverconstrainedError",
              byPermissions: err.name === "NotAllowedError"
            },
            message: err.message
          };
        } else {
          error = {
            message: "Media Permission Denied",
            blocked: {
              byPermissions: true,
              byDeviceInUse: false,
              byDeviceMissing: false
            }
          };
        }
        return {
          stream: null,
          track: null,
          deviceId: null,
          error
        };
      }
    };
    fetchStreamByGroupId = async (data) => {
      let constraints;
      if (data.mediaDeviceKind === "mic") {
        constraints = { audio: { groupId: data.groupId } };
      } else {
        constraints = { video: { groupId: data.groupId } };
      }
      const stream = await navigator.mediaDevices.getUserMedia(constraints);
      return stream;
    };
    /**
     * Fetch the stream from the device for the React Native Based Application
     *
     * `This stream is not managed by the Huddle01 SDK, i.e. it will not be closed by the SDK
     * the user has to close it manually by calling {stream.getTracks().forEach(track => track.stop())}`
     *
     * NOTE: `using stopTrackOnClose = true` while producing will stop the track when producing is stopped
     *
     * @param data - { deviceId: "front" | "back" | "audio" | string; kind: "audioinput" | "videoinput" }
     * @returns - { stream: MediaStream, deviceId: string }
     */
    __fetchStreamFromDeviceForRN = async (data) => {
      const constraints = deviceConstraints_default[data.mediaKind];
      let facingMode;
      if (data.mediaKind === "cam") {
        facingMode = data.deviceId === "environment" ? "environment" : "front";
        constraints.video = Object.assign({}, constraints.video, {
          facingMode
        });
      }
      if (data.mediaKind === "mic") {
        constraints.audio = Object.assign({}, constraints.audio, {
          deviceId: data.deviceId
        });
      }
      const stream = await navigator.mediaDevices.getUserMedia(constraints);
      const streamDeviceId = this.getDeviceFromFacingMode(
        facingMode,
        data.mediaKind === "mic" ? "mic" : "cam"
      );
      const devices = await navigator.mediaDevices.enumerateDevices();
      if (data.mediaKind === "cam" || data.mediaKind === "mic") {
        this.emit("permission-granted", { deviceKind: data.mediaKind });
        this.__setMediaDeviceInfo({ devices, update: data.mediaKind });
      }
      if (!streamDeviceId) {
        const tracks = stream.getTracks();
        for (const track of tracks) {
          track.stop();
        }
        throw new Error(
          "\u274C No DeviceId found for this stream, this is a bug in the SDK, please report it to the developers"
        );
      }
      return {
        stream,
        deviceId: streamDeviceId
      };
    };
    /**
     * Fetch the stream from the device for the web
     *
     * `This stream is not managed by the Huddle01 SDK, i.e. it will not be closed by the SDK
     * the user has to close it manually by calling {stream.getTracks().forEach(track => track.stop())}`
     *
     * NOTE: `using stopTrackOnClose = true` while producing will stop the track when producing is stopped
     *
     * @param data - { deviceId: string; kind: 'audio' | 'video' }
     * @returns - { stream: MediaStream, deviceId: string }
     */
    __fetchStreamFromDeviceForWeb = async (data) => {
      const constraints = Object.assign(
        {},
        deviceConstraints_default[data.mediaKind]
      );
      if (data.mediaKind === "cam" && data.deviceId) {
        constraints.video = Object.assign({}, constraints.video, {
          deviceId: data.deviceId
        });
      }
      if (data.mediaKind === "mic" && data.deviceId) {
        const micConstraint = {};
        const devices2 = this.__mediaDevicesInfo.get("mic");
        if (data.deviceId === "default" && devices2 && devices2.length > 0) {
          const device = devices2.find((d) => d.deviceId === data.deviceId);
          if (device) {
            micConstraint.groupId = device.groupId;
          }
        } else if (data?.deviceId?.length > 0) {
          micConstraint.deviceId = {
            exact: data.deviceId
          };
        }
        constraints.audio = Object.assign({}, constraints.audio, micConstraint);
      }
      const stream = await navigator.mediaDevices.getUserMedia(constraints);
      const streamDeviceId = stream.getTracks()[0].getSettings().deviceId;
      const devices = await navigator.mediaDevices.enumerateDevices();
      if (data.mediaKind === "cam" || data.mediaKind === "mic") {
        this.emit("permission-granted", { deviceKind: data.mediaKind });
        this.__setMediaDeviceInfo({ devices, update: data.mediaKind });
      }
      if (!streamDeviceId) {
        const tracks = stream.getTracks();
        for (const track of tracks) {
          track.stop();
        }
        throw new Error(
          "\u274C No DeviceId found for this stream, this is a bug in the browser, please report it to the developers"
        );
      }
      return {
        stream,
        deviceId: data?.deviceId ?? streamDeviceId
      };
    };
    /**
     * @description Get the media permission for the given type
     * @param data  { type: 'video' | 'audio' }
     * @throws error { StreamPermissionsError }
     * @example await getMediaPermission({ type: 'video' })
     */
    getMediaPermission = async (data) => {
      const { mediaDeviceKind } = data;
      try {
        await this.getMediaDevices(mediaDeviceKind);
        this.emit("permission-granted", { deviceKind: mediaDeviceKind });
        return {
          permission: "granted"
        };
      } catch (err) {
        let error = {
          message: "Unknown Error",
          errorStack: err
        };
        if (!isReactNative() && err instanceof DOMException) {
          error = {
            blocked: {
              byDeviceMissing: err.name === "NotFoundError",
              byDeviceInUse: err.name === "OverconstrainedError",
              byPermissions: err.name === "NotAllowedError"
            },
            message: err.message
          };
        } else {
          error = {
            message: "Media Permission Denied",
            blocked: {
              byPermissions: true,
              byDeviceInUse: false,
              byDeviceMissing: false
            }
          };
        }
        this.emit("permission-denied", { deviceKind: mediaDeviceKind, error });
        return {
          permission: "denied",
          error
        };
      }
    };
    stopStream = (stream) => {
      if (!stream) return;
      for (const track of stream.getTracks()) {
        track.stop();
      }
    };
    destroy = () => {
      this.__preferredDevices.clear();
      this.__mediaDevicesInfo.clear();
      logger.info("\u2705 Destroyed StreamHandler");
    };
    /**
     * Set the Media devices info based on the latest devices available in the system
     */
    __setMediaDeviceInfo = (data) => {
      const { devices, update } = data;
      const camDevices = [];
      const micDevices = [];
      const speakerDevices = [];
      for (const device of devices) {
        if (device.label === "" || device.deviceId === "") continue;
        if (device.kind === "videoinput") camDevices.push(device);
        if (device.kind === "audioinput") micDevices.push(device);
        if (device.kind === "audiooutput") speakerDevices.push(device);
      }
      if (update === "all") {
        this.__mediaDevicesInfo.set("cam", camDevices);
        this.__mediaDevicesInfo.set("mic", micDevices);
        this.__mediaDevicesInfo.set("speaker", speakerDevices);
      }
      if (update === "cam") this.__mediaDevicesInfo.set("cam", camDevices);
      if (update === "mic") {
        this.__mediaDevicesInfo.set("mic", micDevices);
        this.__mediaDevicesInfo.set("speaker", speakerDevices);
      }
    };
  };
  var DeviceHandler_default = DeviceHandler;

  // ../types/dist/socket.types.js
  var ESocketCloseCode;
  (function(ESocketCloseCode2) {
    ESocketCloseCode2[ESocketCloseCode2["ABNORMAL_CLOSURE"] = 1006] = "ABNORMAL_CLOSURE";
    ESocketCloseCode2[ESocketCloseCode2["NORMAL_CLOSURE"] = 1e3] = "NORMAL_CLOSURE";
    ESocketCloseCode2[ESocketCloseCode2["BROWSER_TAB_CLOSE"] = 1001] = "BROWSER_TAB_CLOSE";
    ESocketCloseCode2[ESocketCloseCode2["GOING_AWAY"] = 4001] = "GOING_AWAY";
    ESocketCloseCode2[ESocketCloseCode2["CONNECTION_EXPIRED"] = 4002] = "CONNECTION_EXPIRED";
    ESocketCloseCode2[ESocketCloseCode2["CONNECTION_ERROR"] = 4006] = "CONNECTION_ERROR";
    ESocketCloseCode2[ESocketCloseCode2["ROOM_CLOSED"] = 4007] = "ROOM_CLOSED";
    ESocketCloseCode2[ESocketCloseCode2["ROOM_ENTRY_DENIED"] = 4008] = "ROOM_ENTRY_DENIED";
    ESocketCloseCode2[ESocketCloseCode2["KICKED"] = 4009] = "KICKED";
    ESocketCloseCode2[ESocketCloseCode2["MAX_PEERS_REACHED"] = 4010] = "MAX_PEERS_REACHED";
    ESocketCloseCode2[ESocketCloseCode2["ROOM_EXPIRED"] = 4011] = "ROOM_EXPIRED";
  })(ESocketCloseCode || (ESocketCloseCode = {}));
  var SocketCloseReason = {
    [ESocketCloseCode.ROOM_CLOSED]: "ROOM_CLOSED",
    [ESocketCloseCode.ABNORMAL_CLOSURE]: "ABNORMAL_CLOSURE",
    [ESocketCloseCode.NORMAL_CLOSURE]: "NORMAL_CLOSURE",
    [ESocketCloseCode.BROWSER_TAB_CLOSE]: "BROWSER_TAB_CLOSE",
    [ESocketCloseCode.GOING_AWAY]: "GOING_AWAY",
    [ESocketCloseCode.CONNECTION_ERROR]: "CONNECTION_ERROR",
    [ESocketCloseCode.CONNECTION_EXPIRED]: "CONNECTION_EXPIRED",
    [ESocketCloseCode.ROOM_ENTRY_DENIED]: "ROOM_ENTRY_DENIED",
    [ESocketCloseCode.KICKED]: "KICKED",
    [ESocketCloseCode.MAX_PEERS_REACHED]: "MAX_PEERS_REACHED",
    [ESocketCloseCode.ROOM_EXPIRED]: "ROOM_EXPIRED"
  };

  // ../../node_modules/zod/lib/index.mjs
  var util;
  (function(util2) {
    util2.assertEqual = (val) => val;
    function assertIs(_arg) {
    }
    util2.assertIs = assertIs;
    function assertNever(_x) {
      throw new Error();
    }
    util2.assertNever = assertNever;
    util2.arrayToEnum = (items) => {
      const obj = {};
      for (const item of items) {
        obj[item] = item;
      }
      return obj;
    };
    util2.getValidEnumValues = (obj) => {
      const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
      const filtered = {};
      for (const k of validKeys) {
        filtered[k] = obj[k];
      }
      return util2.objectValues(filtered);
    };
    util2.objectValues = (obj) => {
      return util2.objectKeys(obj).map(function(e) {
        return obj[e];
      });
    };
    util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
      const keys = [];
      for (const key in object) {
        if (Object.prototype.hasOwnProperty.call(object, key)) {
          keys.push(key);
        }
      }
      return keys;
    };
    util2.find = (arr, checker) => {
      for (const item of arr) {
        if (checker(item))
          return item;
      }
      return void 0;
    };
    util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
    function joinValues(array, separator = " | ") {
      return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
    }
    util2.joinValues = joinValues;
    util2.jsonStringifyReplacer = (_, value) => {
      if (typeof value === "bigint") {
        return value.toString();
      }
      return value;
    };
  })(util || (util = {}));
  var objectUtil;
  (function(objectUtil2) {
    objectUtil2.mergeShapes = (first, second) => {
      return {
        ...first,
        ...second
        // second overwrites first
      };
    };
  })(objectUtil || (objectUtil = {}));
  var ZodParsedType = util.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set"
  ]);
  var getParsedType = (data) => {
    const t = typeof data;
    switch (t) {
      case "undefined":
        return ZodParsedType.undefined;
      case "string":
        return ZodParsedType.string;
      case "number":
        return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
      case "boolean":
        return ZodParsedType.boolean;
      case "function":
        return ZodParsedType.function;
      case "bigint":
        return ZodParsedType.bigint;
      case "symbol":
        return ZodParsedType.symbol;
      case "object":
        if (Array.isArray(data)) {
          return ZodParsedType.array;
        }
        if (data === null) {
          return ZodParsedType.null;
        }
        if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
          return ZodParsedType.promise;
        }
        if (typeof Map !== "undefined" && data instanceof Map) {
          return ZodParsedType.map;
        }
        if (typeof Set !== "undefined" && data instanceof Set) {
          return ZodParsedType.set;
        }
        if (typeof Date !== "undefined" && data instanceof Date) {
          return ZodParsedType.date;
        }
        return ZodParsedType.object;
      default:
        return ZodParsedType.unknown;
    }
  };
  var ZodIssueCode = util.arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
    "not_finite"
  ]);
  var quotelessJson = (obj) => {
    const json = JSON.stringify(obj, null, 2);
    return json.replace(/"([^"]+)":/g, "$1:");
  };
  var ZodError = class _ZodError extends Error {
    constructor(issues) {
      super();
      this.issues = [];
      this.addIssue = (sub) => {
        this.issues = [...this.issues, sub];
      };
      this.addIssues = (subs = []) => {
        this.issues = [...this.issues, ...subs];
      };
      const actualProto = new.target.prototype;
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(this, actualProto);
      } else {
        this.__proto__ = actualProto;
      }
      this.name = "ZodError";
      this.issues = issues;
    }
    get errors() {
      return this.issues;
    }
    format(_mapper) {
      const mapper = _mapper || function(issue) {
        return issue.message;
      };
      const fieldErrors = { _errors: [] };
      const processError = (error) => {
        for (const issue of error.issues) {
          if (issue.code === "invalid_union") {
            issue.unionErrors.map(processError);
          } else if (issue.code === "invalid_return_type") {
            processError(issue.returnTypeError);
          } else if (issue.code === "invalid_arguments") {
            processError(issue.argumentsError);
          } else if (issue.path.length === 0) {
            fieldErrors._errors.push(mapper(issue));
          } else {
            let curr = fieldErrors;
            let i = 0;
            while (i < issue.path.length) {
              const el = issue.path[i];
              const terminal = i === issue.path.length - 1;
              if (!terminal) {
                curr[el] = curr[el] || { _errors: [] };
              } else {
                curr[el] = curr[el] || { _errors: [] };
                curr[el]._errors.push(mapper(issue));
              }
              curr = curr[el];
              i++;
            }
          }
        }
      };
      processError(this);
      return fieldErrors;
    }
    static assert(value) {
      if (!(value instanceof _ZodError)) {
        throw new Error(`Not a ZodError: ${value}`);
      }
    }
    toString() {
      return this.message;
    }
    get message() {
      return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
    }
    get isEmpty() {
      return this.issues.length === 0;
    }
    flatten(mapper = (issue) => issue.message) {
      const fieldErrors = {};
      const formErrors = [];
      for (const sub of this.issues) {
        if (sub.path.length > 0) {
          fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
          fieldErrors[sub.path[0]].push(mapper(sub));
        } else {
          formErrors.push(mapper(sub));
        }
      }
      return { formErrors, fieldErrors };
    }
    get formErrors() {
      return this.flatten();
    }
  };
  ZodError.create = (issues) => {
    const error = new ZodError(issues);
    return error;
  };
  var errorMap = (issue, _ctx) => {
    let message;
    switch (issue.code) {
      case ZodIssueCode.invalid_type:
        if (issue.received === ZodParsedType.undefined) {
          message = "Required";
        } else {
          message = `Expected ${issue.expected}, received ${issue.received}`;
        }
        break;
      case ZodIssueCode.invalid_literal:
        message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
        break;
      case ZodIssueCode.unrecognized_keys:
        message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
        break;
      case ZodIssueCode.invalid_union:
        message = `Invalid input`;
        break;
      case ZodIssueCode.invalid_union_discriminator:
        message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
        break;
      case ZodIssueCode.invalid_enum_value:
        message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
        break;
      case ZodIssueCode.invalid_arguments:
        message = `Invalid function arguments`;
        break;
      case ZodIssueCode.invalid_return_type:
        message = `Invalid function return type`;
        break;
      case ZodIssueCode.invalid_date:
        message = `Invalid date`;
        break;
      case ZodIssueCode.invalid_string:
        if (typeof issue.validation === "object") {
          if ("includes" in issue.validation) {
            message = `Invalid input: must include "${issue.validation.includes}"`;
            if (typeof issue.validation.position === "number") {
              message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
            }
          } else if ("startsWith" in issue.validation) {
            message = `Invalid input: must start with "${issue.validation.startsWith}"`;
          } else if ("endsWith" in issue.validation) {
            message = `Invalid input: must end with "${issue.validation.endsWith}"`;
          } else {
            util.assertNever(issue.validation);
          }
        } else if (issue.validation !== "regex") {
          message = `Invalid ${issue.validation}`;
        } else {
          message = "Invalid";
        }
        break;
      case ZodIssueCode.too_small:
        if (issue.type === "array")
          message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
        else if (issue.type === "string")
          message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
        else if (issue.type === "number")
          message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
        else if (issue.type === "date")
          message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
        else
          message = "Invalid input";
        break;
      case ZodIssueCode.too_big:
        if (issue.type === "array")
          message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
        else if (issue.type === "string")
          message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
        else if (issue.type === "number")
          message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
        else if (issue.type === "bigint")
          message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
        else if (issue.type === "date")
          message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
        else
          message = "Invalid input";
        break;
      case ZodIssueCode.custom:
        message = `Invalid input`;
        break;
      case ZodIssueCode.invalid_intersection_types:
        message = `Intersection results could not be merged`;
        break;
      case ZodIssueCode.not_multiple_of:
        message = `Number must be a multiple of ${issue.multipleOf}`;
        break;
      case ZodIssueCode.not_finite:
        message = "Number must be finite";
        break;
      default:
        message = _ctx.defaultError;
        util.assertNever(issue);
    }
    return { message };
  };
  var overrideErrorMap = errorMap;
  function setErrorMap(map) {
    overrideErrorMap = map;
  }
  function getErrorMap() {
    return overrideErrorMap;
  }
  var makeIssue = (params) => {
    const { data, path, errorMaps, issueData } = params;
    const fullPath = [...path, ...issueData.path || []];
    const fullIssue = {
      ...issueData,
      path: fullPath
    };
    if (issueData.message !== void 0) {
      return {
        ...issueData,
        path: fullPath,
        message: issueData.message
      };
    }
    let errorMessage = "";
    const maps = errorMaps.filter((m) => !!m).slice().reverse();
    for (const map of maps) {
      errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
    }
    return {
      ...issueData,
      path: fullPath,
      message: errorMessage
    };
  };
  var EMPTY_PATH = [];
  function addIssueToContext(ctx, issueData) {
    const overrideMap = getErrorMap();
    const issue = makeIssue({
      issueData,
      data: ctx.data,
      path: ctx.path,
      errorMaps: [
        ctx.common.contextualErrorMap,
        ctx.schemaErrorMap,
        overrideMap,
        overrideMap === errorMap ? void 0 : errorMap
        // then global default map
      ].filter((x) => !!x)
    });
    ctx.common.issues.push(issue);
  }
  var ParseStatus = class _ParseStatus {
    constructor() {
      this.value = "valid";
    }
    dirty() {
      if (this.value === "valid")
        this.value = "dirty";
    }
    abort() {
      if (this.value !== "aborted")
        this.value = "aborted";
    }
    static mergeArray(status, results) {
      const arrayValue = [];
      for (const s of results) {
        if (s.status === "aborted")
          return INVALID;
        if (s.status === "dirty")
          status.dirty();
        arrayValue.push(s.value);
      }
      return { status: status.value, value: arrayValue };
    }
    static async mergeObjectAsync(status, pairs) {
      const syncPairs = [];
      for (const pair of pairs) {
        const key = await pair.key;
        const value = await pair.value;
        syncPairs.push({
          key,
          value
        });
      }
      return _ParseStatus.mergeObjectSync(status, syncPairs);
    }
    static mergeObjectSync(status, pairs) {
      const finalObject = {};
      for (const pair of pairs) {
        const { key, value } = pair;
        if (key.status === "aborted")
          return INVALID;
        if (value.status === "aborted")
          return INVALID;
        if (key.status === "dirty")
          status.dirty();
        if (value.status === "dirty")
          status.dirty();
        if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
          finalObject[key.value] = value.value;
        }
      }
      return { status: status.value, value: finalObject };
    }
  };
  var INVALID = Object.freeze({
    status: "aborted"
  });
  var DIRTY = (value) => ({ status: "dirty", value });
  var OK = (value) => ({ status: "valid", value });
  var isAborted = (x) => x.status === "aborted";
  var isDirty = (x) => x.status === "dirty";
  var isValid = (x) => x.status === "valid";
  var isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
  function __classPrivateFieldGet(receiver, state, kind, f) {
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return state.get(receiver);
  }
  function __classPrivateFieldSet(receiver, state, value, kind, f) {
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return state.set(receiver, value), value;
  }
  var errorUtil;
  (function(errorUtil2) {
    errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
    errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
  })(errorUtil || (errorUtil = {}));
  var _ZodEnum_cache;
  var _ZodNativeEnum_cache;
  var ParseInputLazyPath = class {
    constructor(parent, value, path, key) {
      this._cachedPath = [];
      this.parent = parent;
      this.data = value;
      this._path = path;
      this._key = key;
    }
    get path() {
      if (!this._cachedPath.length) {
        if (this._key instanceof Array) {
          this._cachedPath.push(...this._path, ...this._key);
        } else {
          this._cachedPath.push(...this._path, this._key);
        }
      }
      return this._cachedPath;
    }
  };
  var handleResult = (ctx, result) => {
    if (isValid(result)) {
      return { success: true, data: result.value };
    } else {
      if (!ctx.common.issues.length) {
        throw new Error("Validation failed but no issues detected.");
      }
      return {
        success: false,
        get error() {
          if (this._error)
            return this._error;
          const error = new ZodError(ctx.common.issues);
          this._error = error;
          return this._error;
        }
      };
    }
  };
  function processCreateParams(params) {
    if (!params)
      return {};
    const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
    if (errorMap2 && (invalid_type_error || required_error)) {
      throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    }
    if (errorMap2)
      return { errorMap: errorMap2, description };
    const customMap = (iss, ctx) => {
      var _a, _b;
      const { message } = params;
      if (iss.code === "invalid_enum_value") {
        return { message: message !== null && message !== void 0 ? message : ctx.defaultError };
      }
      if (typeof ctx.data === "undefined") {
        return { message: (_a = message !== null && message !== void 0 ? message : required_error) !== null && _a !== void 0 ? _a : ctx.defaultError };
      }
      if (iss.code !== "invalid_type")
        return { message: ctx.defaultError };
      return { message: (_b = message !== null && message !== void 0 ? message : invalid_type_error) !== null && _b !== void 0 ? _b : ctx.defaultError };
    };
    return { errorMap: customMap, description };
  }
  var ZodType = class {
    constructor(def) {
      this.spa = this.safeParseAsync;
      this._def = def;
      this.parse = this.parse.bind(this);
      this.safeParse = this.safeParse.bind(this);
      this.parseAsync = this.parseAsync.bind(this);
      this.safeParseAsync = this.safeParseAsync.bind(this);
      this.spa = this.spa.bind(this);
      this.refine = this.refine.bind(this);
      this.refinement = this.refinement.bind(this);
      this.superRefine = this.superRefine.bind(this);
      this.optional = this.optional.bind(this);
      this.nullable = this.nullable.bind(this);
      this.nullish = this.nullish.bind(this);
      this.array = this.array.bind(this);
      this.promise = this.promise.bind(this);
      this.or = this.or.bind(this);
      this.and = this.and.bind(this);
      this.transform = this.transform.bind(this);
      this.brand = this.brand.bind(this);
      this.default = this.default.bind(this);
      this.catch = this.catch.bind(this);
      this.describe = this.describe.bind(this);
      this.pipe = this.pipe.bind(this);
      this.readonly = this.readonly.bind(this);
      this.isNullable = this.isNullable.bind(this);
      this.isOptional = this.isOptional.bind(this);
    }
    get description() {
      return this._def.description;
    }
    _getType(input) {
      return getParsedType(input.data);
    }
    _getOrReturnCtx(input, ctx) {
      return ctx || {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      };
    }
    _processInputParams(input) {
      return {
        status: new ParseStatus(),
        ctx: {
          common: input.parent.common,
          data: input.data,
          parsedType: getParsedType(input.data),
          schemaErrorMap: this._def.errorMap,
          path: input.path,
          parent: input.parent
        }
      };
    }
    _parseSync(input) {
      const result = this._parse(input);
      if (isAsync(result)) {
        throw new Error("Synchronous parse encountered promise.");
      }
      return result;
    }
    _parseAsync(input) {
      const result = this._parse(input);
      return Promise.resolve(result);
    }
    parse(data, params) {
      const result = this.safeParse(data, params);
      if (result.success)
        return result.data;
      throw result.error;
    }
    safeParse(data, params) {
      var _a;
      const ctx = {
        common: {
          issues: [],
          async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
          contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
        },
        path: (params === null || params === void 0 ? void 0 : params.path) || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data,
        parsedType: getParsedType(data)
      };
      const result = this._parseSync({ data, path: ctx.path, parent: ctx });
      return handleResult(ctx, result);
    }
    async parseAsync(data, params) {
      const result = await this.safeParseAsync(data, params);
      if (result.success)
        return result.data;
      throw result.error;
    }
    async safeParseAsync(data, params) {
      const ctx = {
        common: {
          issues: [],
          contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
          async: true
        },
        path: (params === null || params === void 0 ? void 0 : params.path) || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data,
        parsedType: getParsedType(data)
      };
      const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
      const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
      return handleResult(ctx, result);
    }
    refine(check, message) {
      const getIssueProperties = (val) => {
        if (typeof message === "string" || typeof message === "undefined") {
          return { message };
        } else if (typeof message === "function") {
          return message(val);
        } else {
          return message;
        }
      };
      return this._refinement((val, ctx) => {
        const result = check(val);
        const setError = () => ctx.addIssue({
          code: ZodIssueCode.custom,
          ...getIssueProperties(val)
        });
        if (typeof Promise !== "undefined" && result instanceof Promise) {
          return result.then((data) => {
            if (!data) {
              setError();
              return false;
            } else {
              return true;
            }
          });
        }
        if (!result) {
          setError();
          return false;
        } else {
          return true;
        }
      });
    }
    refinement(check, refinementData) {
      return this._refinement((val, ctx) => {
        if (!check(val)) {
          ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
          return false;
        } else {
          return true;
        }
      });
    }
    _refinement(refinement) {
      return new ZodEffects({
        schema: this,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect: { type: "refinement", refinement }
      });
    }
    superRefine(refinement) {
      return this._refinement(refinement);
    }
    optional() {
      return ZodOptional.create(this, this._def);
    }
    nullable() {
      return ZodNullable.create(this, this._def);
    }
    nullish() {
      return this.nullable().optional();
    }
    array() {
      return ZodArray.create(this, this._def);
    }
    promise() {
      return ZodPromise.create(this, this._def);
    }
    or(option) {
      return ZodUnion.create([this, option], this._def);
    }
    and(incoming) {
      return ZodIntersection.create(this, incoming, this._def);
    }
    transform(transform) {
      return new ZodEffects({
        ...processCreateParams(this._def),
        schema: this,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect: { type: "transform", transform }
      });
    }
    default(def) {
      const defaultValueFunc = typeof def === "function" ? def : () => def;
      return new ZodDefault({
        ...processCreateParams(this._def),
        innerType: this,
        defaultValue: defaultValueFunc,
        typeName: ZodFirstPartyTypeKind.ZodDefault
      });
    }
    brand() {
      return new ZodBranded({
        typeName: ZodFirstPartyTypeKind.ZodBranded,
        type: this,
        ...processCreateParams(this._def)
      });
    }
    catch(def) {
      const catchValueFunc = typeof def === "function" ? def : () => def;
      return new ZodCatch({
        ...processCreateParams(this._def),
        innerType: this,
        catchValue: catchValueFunc,
        typeName: ZodFirstPartyTypeKind.ZodCatch
      });
    }
    describe(description) {
      const This = this.constructor;
      return new This({
        ...this._def,
        description
      });
    }
    pipe(target) {
      return ZodPipeline.create(this, target);
    }
    readonly() {
      return ZodReadonly.create(this);
    }
    isOptional() {
      return this.safeParse(void 0).success;
    }
    isNullable() {
      return this.safeParse(null).success;
    }
  };
  var cuidRegex = /^c[^\s-]{8,}$/i;
  var cuid2Regex = /^[0-9a-z]+$/;
  var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;
  var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
  var nanoidRegex = /^[a-z0-9_-]{21}$/i;
  var durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
  var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
  var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
  var emojiRegex;
  var ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
  var ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
  var base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
  var dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
  var dateRegex = new RegExp(`^${dateRegexSource}$`);
  function timeRegexSource(args) {
    let regex = `([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d`;
    if (args.precision) {
      regex = `${regex}\\.\\d{${args.precision}}`;
    } else if (args.precision == null) {
      regex = `${regex}(\\.\\d+)?`;
    }
    return regex;
  }
  function timeRegex(args) {
    return new RegExp(`^${timeRegexSource(args)}$`);
  }
  function datetimeRegex(args) {
    let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
    const opts = [];
    opts.push(args.local ? `Z?` : `Z`);
    if (args.offset)
      opts.push(`([+-]\\d{2}:?\\d{2})`);
    regex = `${regex}(${opts.join("|")})`;
    return new RegExp(`^${regex}$`);
  }
  function isValidIP(ip, version) {
    if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
      return true;
    }
    if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
      return true;
    }
    return false;
  }
  var ZodString = class _ZodString extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = String(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.string) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.string,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      const status = new ParseStatus();
      let ctx = void 0;
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          if (input.data.length < check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          if (input.data.length > check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "length") {
          const tooBig = input.data.length > check.value;
          const tooSmall = input.data.length < check.value;
          if (tooBig || tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            if (tooBig) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: check.value,
                type: "string",
                inclusive: true,
                exact: true,
                message: check.message
              });
            } else if (tooSmall) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: check.value,
                type: "string",
                inclusive: true,
                exact: true,
                message: check.message
              });
            }
            status.dirty();
          }
        } else if (check.kind === "email") {
          if (!emailRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "email",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "emoji") {
          if (!emojiRegex) {
            emojiRegex = new RegExp(_emojiRegex, "u");
          }
          if (!emojiRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "emoji",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "uuid") {
          if (!uuidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "uuid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "nanoid") {
          if (!nanoidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "nanoid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "cuid") {
          if (!cuidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "cuid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "cuid2") {
          if (!cuid2Regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "cuid2",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "ulid") {
          if (!ulidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "ulid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "url") {
          try {
            new URL(input.data);
          } catch (_a) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "url",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "regex") {
          check.regex.lastIndex = 0;
          const testResult = check.regex.test(input.data);
          if (!testResult) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "regex",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "trim") {
          input.data = input.data.trim();
        } else if (check.kind === "includes") {
          if (!input.data.includes(check.value, check.position)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: { includes: check.value, position: check.position },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "toLowerCase") {
          input.data = input.data.toLowerCase();
        } else if (check.kind === "toUpperCase") {
          input.data = input.data.toUpperCase();
        } else if (check.kind === "startsWith") {
          if (!input.data.startsWith(check.value)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: { startsWith: check.value },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "endsWith") {
          if (!input.data.endsWith(check.value)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: { endsWith: check.value },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "datetime") {
          const regex = datetimeRegex(check);
          if (!regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: "datetime",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "date") {
          const regex = dateRegex;
          if (!regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: "date",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "time") {
          const regex = timeRegex(check);
          if (!regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: "time",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "duration") {
          if (!durationRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "duration",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "ip") {
          if (!isValidIP(input.data, check.version)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "ip",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "base64") {
          if (!base64Regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "base64",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    _regex(regex, validation, message) {
      return this.refinement((data) => regex.test(data), {
        validation,
        code: ZodIssueCode.invalid_string,
        ...errorUtil.errToObj(message)
      });
    }
    _addCheck(check) {
      return new _ZodString({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    email(message) {
      return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
    }
    url(message) {
      return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
    }
    emoji(message) {
      return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
    }
    uuid(message) {
      return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
    }
    nanoid(message) {
      return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
    }
    cuid(message) {
      return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
    }
    cuid2(message) {
      return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
    }
    ulid(message) {
      return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
    }
    base64(message) {
      return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
    }
    ip(options) {
      return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
    }
    datetime(options) {
      var _a, _b;
      if (typeof options === "string") {
        return this._addCheck({
          kind: "datetime",
          precision: null,
          offset: false,
          local: false,
          message: options
        });
      }
      return this._addCheck({
        kind: "datetime",
        precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
        offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,
        local: (_b = options === null || options === void 0 ? void 0 : options.local) !== null && _b !== void 0 ? _b : false,
        ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
      });
    }
    date(message) {
      return this._addCheck({ kind: "date", message });
    }
    time(options) {
      if (typeof options === "string") {
        return this._addCheck({
          kind: "time",
          precision: null,
          message: options
        });
      }
      return this._addCheck({
        kind: "time",
        precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
        ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
      });
    }
    duration(message) {
      return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
    }
    regex(regex, message) {
      return this._addCheck({
        kind: "regex",
        regex,
        ...errorUtil.errToObj(message)
      });
    }
    includes(value, options) {
      return this._addCheck({
        kind: "includes",
        value,
        position: options === null || options === void 0 ? void 0 : options.position,
        ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
      });
    }
    startsWith(value, message) {
      return this._addCheck({
        kind: "startsWith",
        value,
        ...errorUtil.errToObj(message)
      });
    }
    endsWith(value, message) {
      return this._addCheck({
        kind: "endsWith",
        value,
        ...errorUtil.errToObj(message)
      });
    }
    min(minLength, message) {
      return this._addCheck({
        kind: "min",
        value: minLength,
        ...errorUtil.errToObj(message)
      });
    }
    max(maxLength, message) {
      return this._addCheck({
        kind: "max",
        value: maxLength,
        ...errorUtil.errToObj(message)
      });
    }
    length(len, message) {
      return this._addCheck({
        kind: "length",
        value: len,
        ...errorUtil.errToObj(message)
      });
    }
    /**
     * @deprecated Use z.string().min(1) instead.
     * @see {@link ZodString.min}
     */
    nonempty(message) {
      return this.min(1, errorUtil.errToObj(message));
    }
    trim() {
      return new _ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "trim" }]
      });
    }
    toLowerCase() {
      return new _ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "toLowerCase" }]
      });
    }
    toUpperCase() {
      return new _ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "toUpperCase" }]
      });
    }
    get isDatetime() {
      return !!this._def.checks.find((ch) => ch.kind === "datetime");
    }
    get isDate() {
      return !!this._def.checks.find((ch) => ch.kind === "date");
    }
    get isTime() {
      return !!this._def.checks.find((ch) => ch.kind === "time");
    }
    get isDuration() {
      return !!this._def.checks.find((ch) => ch.kind === "duration");
    }
    get isEmail() {
      return !!this._def.checks.find((ch) => ch.kind === "email");
    }
    get isURL() {
      return !!this._def.checks.find((ch) => ch.kind === "url");
    }
    get isEmoji() {
      return !!this._def.checks.find((ch) => ch.kind === "emoji");
    }
    get isUUID() {
      return !!this._def.checks.find((ch) => ch.kind === "uuid");
    }
    get isNANOID() {
      return !!this._def.checks.find((ch) => ch.kind === "nanoid");
    }
    get isCUID() {
      return !!this._def.checks.find((ch) => ch.kind === "cuid");
    }
    get isCUID2() {
      return !!this._def.checks.find((ch) => ch.kind === "cuid2");
    }
    get isULID() {
      return !!this._def.checks.find((ch) => ch.kind === "ulid");
    }
    get isIP() {
      return !!this._def.checks.find((ch) => ch.kind === "ip");
    }
    get isBase64() {
      return !!this._def.checks.find((ch) => ch.kind === "base64");
    }
    get minLength() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min;
    }
    get maxLength() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max;
    }
  };
  ZodString.create = (params) => {
    var _a;
    return new ZodString({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodString,
      coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
      ...processCreateParams(params)
    });
  };
  function floatSafeRemainder(val, step) {
    const valDecCount = (val.toString().split(".")[1] || "").length;
    const stepDecCount = (step.toString().split(".")[1] || "").length;
    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
    const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
    const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
    return valInt % stepInt / Math.pow(10, decCount);
  }
  var ZodNumber = class _ZodNumber extends ZodType {
    constructor() {
      super(...arguments);
      this.min = this.gte;
      this.max = this.lte;
      this.step = this.multipleOf;
    }
    _parse(input) {
      if (this._def.coerce) {
        input.data = Number(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.number) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.number,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      let ctx = void 0;
      const status = new ParseStatus();
      for (const check of this._def.checks) {
        if (check.kind === "int") {
          if (!util.isInteger(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: "integer",
              received: "float",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "min") {
          const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
          if (tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "number",
              inclusive: check.inclusive,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
          if (tooBig) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "number",
              inclusive: check.inclusive,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "multipleOf") {
          if (floatSafeRemainder(input.data, check.value) !== 0) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.not_multiple_of,
              multipleOf: check.value,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "finite") {
          if (!Number.isFinite(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.not_finite,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    gte(value, message) {
      return this.setLimit("min", value, true, errorUtil.toString(message));
    }
    gt(value, message) {
      return this.setLimit("min", value, false, errorUtil.toString(message));
    }
    lte(value, message) {
      return this.setLimit("max", value, true, errorUtil.toString(message));
    }
    lt(value, message) {
      return this.setLimit("max", value, false, errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
      return new _ZodNumber({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind,
            value,
            inclusive,
            message: errorUtil.toString(message)
          }
        ]
      });
    }
    _addCheck(check) {
      return new _ZodNumber({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    int(message) {
      return this._addCheck({
        kind: "int",
        message: errorUtil.toString(message)
      });
    }
    positive(message) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    negative(message) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    nonpositive(message) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    nonnegative(message) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    multipleOf(value, message) {
      return this._addCheck({
        kind: "multipleOf",
        value,
        message: errorUtil.toString(message)
      });
    }
    finite(message) {
      return this._addCheck({
        kind: "finite",
        message: errorUtil.toString(message)
      });
    }
    safe(message) {
      return this._addCheck({
        kind: "min",
        inclusive: true,
        value: Number.MIN_SAFE_INTEGER,
        message: errorUtil.toString(message)
      })._addCheck({
        kind: "max",
        inclusive: true,
        value: Number.MAX_SAFE_INTEGER,
        message: errorUtil.toString(message)
      });
    }
    get minValue() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min;
    }
    get maxValue() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max;
    }
    get isInt() {
      return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
    }
    get isFinite() {
      let max = null, min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
          return true;
        } else if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        } else if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return Number.isFinite(min) && Number.isFinite(max);
    }
  };
  ZodNumber.create = (params) => {
    return new ZodNumber({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodNumber,
      coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
      ...processCreateParams(params)
    });
  };
  var ZodBigInt = class _ZodBigInt extends ZodType {
    constructor() {
      super(...arguments);
      this.min = this.gte;
      this.max = this.lte;
    }
    _parse(input) {
      if (this._def.coerce) {
        input.data = BigInt(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.bigint) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.bigint,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      let ctx = void 0;
      const status = new ParseStatus();
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
          if (tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              type: "bigint",
              minimum: check.value,
              inclusive: check.inclusive,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
          if (tooBig) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              type: "bigint",
              maximum: check.value,
              inclusive: check.inclusive,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "multipleOf") {
          if (input.data % check.value !== BigInt(0)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.not_multiple_of,
              multipleOf: check.value,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    gte(value, message) {
      return this.setLimit("min", value, true, errorUtil.toString(message));
    }
    gt(value, message) {
      return this.setLimit("min", value, false, errorUtil.toString(message));
    }
    lte(value, message) {
      return this.setLimit("max", value, true, errorUtil.toString(message));
    }
    lt(value, message) {
      return this.setLimit("max", value, false, errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
      return new _ZodBigInt({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind,
            value,
            inclusive,
            message: errorUtil.toString(message)
          }
        ]
      });
    }
    _addCheck(check) {
      return new _ZodBigInt({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    positive(message) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    negative(message) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    nonpositive(message) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    nonnegative(message) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    multipleOf(value, message) {
      return this._addCheck({
        kind: "multipleOf",
        value,
        message: errorUtil.toString(message)
      });
    }
    get minValue() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min;
    }
    get maxValue() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max;
    }
  };
  ZodBigInt.create = (params) => {
    var _a;
    return new ZodBigInt({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodBigInt,
      coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
      ...processCreateParams(params)
    });
  };
  var ZodBoolean = class extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = Boolean(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.boolean) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.boolean,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  };
  ZodBoolean.create = (params) => {
    return new ZodBoolean({
      typeName: ZodFirstPartyTypeKind.ZodBoolean,
      coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
      ...processCreateParams(params)
    });
  };
  var ZodDate = class _ZodDate extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = new Date(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.date) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.date,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      if (isNaN(input.data.getTime())) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_date
        });
        return INVALID;
      }
      const status = new ParseStatus();
      let ctx = void 0;
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          if (input.data.getTime() < check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              message: check.message,
              inclusive: true,
              exact: false,
              minimum: check.value,
              type: "date"
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          if (input.data.getTime() > check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              message: check.message,
              inclusive: true,
              exact: false,
              maximum: check.value,
              type: "date"
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return {
        status: status.value,
        value: new Date(input.data.getTime())
      };
    }
    _addCheck(check) {
      return new _ZodDate({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    min(minDate, message) {
      return this._addCheck({
        kind: "min",
        value: minDate.getTime(),
        message: errorUtil.toString(message)
      });
    }
    max(maxDate, message) {
      return this._addCheck({
        kind: "max",
        value: maxDate.getTime(),
        message: errorUtil.toString(message)
      });
    }
    get minDate() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min != null ? new Date(min) : null;
    }
    get maxDate() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max != null ? new Date(max) : null;
    }
  };
  ZodDate.create = (params) => {
    return new ZodDate({
      checks: [],
      coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
      typeName: ZodFirstPartyTypeKind.ZodDate,
      ...processCreateParams(params)
    });
  };
  var ZodSymbol = class extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.symbol) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.symbol,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  };
  ZodSymbol.create = (params) => {
    return new ZodSymbol({
      typeName: ZodFirstPartyTypeKind.ZodSymbol,
      ...processCreateParams(params)
    });
  };
  var ZodUndefined = class extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.undefined) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.undefined,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  };
  ZodUndefined.create = (params) => {
    return new ZodUndefined({
      typeName: ZodFirstPartyTypeKind.ZodUndefined,
      ...processCreateParams(params)
    });
  };
  var ZodNull = class extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.null) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.null,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  };
  ZodNull.create = (params) => {
    return new ZodNull({
      typeName: ZodFirstPartyTypeKind.ZodNull,
      ...processCreateParams(params)
    });
  };
  var ZodAny = class extends ZodType {
    constructor() {
      super(...arguments);
      this._any = true;
    }
    _parse(input) {
      return OK(input.data);
    }
  };
  ZodAny.create = (params) => {
    return new ZodAny({
      typeName: ZodFirstPartyTypeKind.ZodAny,
      ...processCreateParams(params)
    });
  };
  var ZodUnknown = class extends ZodType {
    constructor() {
      super(...arguments);
      this._unknown = true;
    }
    _parse(input) {
      return OK(input.data);
    }
  };
  ZodUnknown.create = (params) => {
    return new ZodUnknown({
      typeName: ZodFirstPartyTypeKind.ZodUnknown,
      ...processCreateParams(params)
    });
  };
  var ZodNever = class extends ZodType {
    _parse(input) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.never,
        received: ctx.parsedType
      });
      return INVALID;
    }
  };
  ZodNever.create = (params) => {
    return new ZodNever({
      typeName: ZodFirstPartyTypeKind.ZodNever,
      ...processCreateParams(params)
    });
  };
  var ZodVoid = class extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.undefined) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.void,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  };
  ZodVoid.create = (params) => {
    return new ZodVoid({
      typeName: ZodFirstPartyTypeKind.ZodVoid,
      ...processCreateParams(params)
    });
  };
  var ZodArray = class _ZodArray extends ZodType {
    _parse(input) {
      const { ctx, status } = this._processInputParams(input);
      const def = this._def;
      if (ctx.parsedType !== ZodParsedType.array) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.array,
          received: ctx.parsedType
        });
        return INVALID;
      }
      if (def.exactLength !== null) {
        const tooBig = ctx.data.length > def.exactLength.value;
        const tooSmall = ctx.data.length < def.exactLength.value;
        if (tooBig || tooSmall) {
          addIssueToContext(ctx, {
            code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
            minimum: tooSmall ? def.exactLength.value : void 0,
            maximum: tooBig ? def.exactLength.value : void 0,
            type: "array",
            inclusive: true,
            exact: true,
            message: def.exactLength.message
          });
          status.dirty();
        }
      }
      if (def.minLength !== null) {
        if (ctx.data.length < def.minLength.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: def.minLength.value,
            type: "array",
            inclusive: true,
            exact: false,
            message: def.minLength.message
          });
          status.dirty();
        }
      }
      if (def.maxLength !== null) {
        if (ctx.data.length > def.maxLength.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: def.maxLength.value,
            type: "array",
            inclusive: true,
            exact: false,
            message: def.maxLength.message
          });
          status.dirty();
        }
      }
      if (ctx.common.async) {
        return Promise.all([...ctx.data].map((item, i) => {
          return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
        })).then((result2) => {
          return ParseStatus.mergeArray(status, result2);
        });
      }
      const result = [...ctx.data].map((item, i) => {
        return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      });
      return ParseStatus.mergeArray(status, result);
    }
    get element() {
      return this._def.type;
    }
    min(minLength, message) {
      return new _ZodArray({
        ...this._def,
        minLength: { value: minLength, message: errorUtil.toString(message) }
      });
    }
    max(maxLength, message) {
      return new _ZodArray({
        ...this._def,
        maxLength: { value: maxLength, message: errorUtil.toString(message) }
      });
    }
    length(len, message) {
      return new _ZodArray({
        ...this._def,
        exactLength: { value: len, message: errorUtil.toString(message) }
      });
    }
    nonempty(message) {
      return this.min(1, message);
    }
  };
  ZodArray.create = (schema, params) => {
    return new ZodArray({
      type: schema,
      minLength: null,
      maxLength: null,
      exactLength: null,
      typeName: ZodFirstPartyTypeKind.ZodArray,
      ...processCreateParams(params)
    });
  };
  function deepPartialify(schema) {
    if (schema instanceof ZodObject) {
      const newShape = {};
      for (const key in schema.shape) {
        const fieldSchema = schema.shape[key];
        newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
      }
      return new ZodObject({
        ...schema._def,
        shape: () => newShape
      });
    } else if (schema instanceof ZodArray) {
      return new ZodArray({
        ...schema._def,
        type: deepPartialify(schema.element)
      });
    } else if (schema instanceof ZodOptional) {
      return ZodOptional.create(deepPartialify(schema.unwrap()));
    } else if (schema instanceof ZodNullable) {
      return ZodNullable.create(deepPartialify(schema.unwrap()));
    } else if (schema instanceof ZodTuple) {
      return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
    } else {
      return schema;
    }
  }
  var ZodObject = class _ZodObject extends ZodType {
    constructor() {
      super(...arguments);
      this._cached = null;
      this.nonstrict = this.passthrough;
      this.augment = this.extend;
    }
    _getCached() {
      if (this._cached !== null)
        return this._cached;
      const shape = this._def.shape();
      const keys = util.objectKeys(shape);
      return this._cached = { shape, keys };
    }
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.object) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.object,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      const { status, ctx } = this._processInputParams(input);
      const { shape, keys: shapeKeys } = this._getCached();
      const extraKeys = [];
      if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
        for (const key in ctx.data) {
          if (!shapeKeys.includes(key)) {
            extraKeys.push(key);
          }
        }
      }
      const pairs = [];
      for (const key of shapeKeys) {
        const keyValidator = shape[key];
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
          alwaysSet: key in ctx.data
        });
      }
      if (this._def.catchall instanceof ZodNever) {
        const unknownKeys = this._def.unknownKeys;
        if (unknownKeys === "passthrough") {
          for (const key of extraKeys) {
            pairs.push({
              key: { status: "valid", value: key },
              value: { status: "valid", value: ctx.data[key] }
            });
          }
        } else if (unknownKeys === "strict") {
          if (extraKeys.length > 0) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.unrecognized_keys,
              keys: extraKeys
            });
            status.dirty();
          }
        } else if (unknownKeys === "strip") ;
        else {
          throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
        }
      } else {
        const catchall = this._def.catchall;
        for (const key of extraKeys) {
          const value = ctx.data[key];
          pairs.push({
            key: { status: "valid", value: key },
            value: catchall._parse(
              new ParseInputLazyPath(ctx, value, ctx.path, key)
              //, ctx.child(key), value, getParsedType(value)
            ),
            alwaysSet: key in ctx.data
          });
        }
      }
      if (ctx.common.async) {
        return Promise.resolve().then(async () => {
          const syncPairs = [];
          for (const pair of pairs) {
            const key = await pair.key;
            const value = await pair.value;
            syncPairs.push({
              key,
              value,
              alwaysSet: pair.alwaysSet
            });
          }
          return syncPairs;
        }).then((syncPairs) => {
          return ParseStatus.mergeObjectSync(status, syncPairs);
        });
      } else {
        return ParseStatus.mergeObjectSync(status, pairs);
      }
    }
    get shape() {
      return this._def.shape();
    }
    strict(message) {
      errorUtil.errToObj;
      return new _ZodObject({
        ...this._def,
        unknownKeys: "strict",
        ...message !== void 0 ? {
          errorMap: (issue, ctx) => {
            var _a, _b, _c, _d;
            const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
            if (issue.code === "unrecognized_keys")
              return {
                message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
              };
            return {
              message: defaultError
            };
          }
        } : {}
      });
    }
    strip() {
      return new _ZodObject({
        ...this._def,
        unknownKeys: "strip"
      });
    }
    passthrough() {
      return new _ZodObject({
        ...this._def,
        unknownKeys: "passthrough"
      });
    }
    // const AugmentFactory =
    //   <Def extends ZodObjectDef>(def: Def) =>
    //   <Augmentation extends ZodRawShape>(
    //     augmentation: Augmentation
    //   ): ZodObject<
    //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
    //     Def["unknownKeys"],
    //     Def["catchall"]
    //   > => {
    //     return new ZodObject({
    //       ...def,
    //       shape: () => ({
    //         ...def.shape(),
    //         ...augmentation,
    //       }),
    //     }) as any;
    //   };
    extend(augmentation) {
      return new _ZodObject({
        ...this._def,
        shape: () => ({
          ...this._def.shape(),
          ...augmentation
        })
      });
    }
    /**
     * Prior to zod@1.0.12 there was a bug in the
     * inferred type of merged objects. Please
     * upgrade if you are experiencing issues.
     */
    merge(merging) {
      const merged = new _ZodObject({
        unknownKeys: merging._def.unknownKeys,
        catchall: merging._def.catchall,
        shape: () => ({
          ...this._def.shape(),
          ...merging._def.shape()
        }),
        typeName: ZodFirstPartyTypeKind.ZodObject
      });
      return merged;
    }
    // merge<
    //   Incoming extends AnyZodObject,
    //   Augmentation extends Incoming["shape"],
    //   NewOutput extends {
    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
    //       ? Augmentation[k]["_output"]
    //       : k extends keyof Output
    //       ? Output[k]
    //       : never;
    //   },
    //   NewInput extends {
    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
    //       ? Augmentation[k]["_input"]
    //       : k extends keyof Input
    //       ? Input[k]
    //       : never;
    //   }
    // >(
    //   merging: Incoming
    // ): ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"],
    //   NewOutput,
    //   NewInput
    // > {
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    setKey(key, schema) {
      return this.augment({ [key]: schema });
    }
    // merge<Incoming extends AnyZodObject>(
    //   merging: Incoming
    // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
    // ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"]
    // > {
    //   // const mergedShape = objectUtil.mergeShapes(
    //   //   this._def.shape(),
    //   //   merging._def.shape()
    //   // );
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    catchall(index) {
      return new _ZodObject({
        ...this._def,
        catchall: index
      });
    }
    pick(mask) {
      const shape = {};
      util.objectKeys(mask).forEach((key) => {
        if (mask[key] && this.shape[key]) {
          shape[key] = this.shape[key];
        }
      });
      return new _ZodObject({
        ...this._def,
        shape: () => shape
      });
    }
    omit(mask) {
      const shape = {};
      util.objectKeys(this.shape).forEach((key) => {
        if (!mask[key]) {
          shape[key] = this.shape[key];
        }
      });
      return new _ZodObject({
        ...this._def,
        shape: () => shape
      });
    }
    /**
     * @deprecated
     */
    deepPartial() {
      return deepPartialify(this);
    }
    partial(mask) {
      const newShape = {};
      util.objectKeys(this.shape).forEach((key) => {
        const fieldSchema = this.shape[key];
        if (mask && !mask[key]) {
          newShape[key] = fieldSchema;
        } else {
          newShape[key] = fieldSchema.optional();
        }
      });
      return new _ZodObject({
        ...this._def,
        shape: () => newShape
      });
    }
    required(mask) {
      const newShape = {};
      util.objectKeys(this.shape).forEach((key) => {
        if (mask && !mask[key]) {
          newShape[key] = this.shape[key];
        } else {
          const fieldSchema = this.shape[key];
          let newField = fieldSchema;
          while (newField instanceof ZodOptional) {
            newField = newField._def.innerType;
          }
          newShape[key] = newField;
        }
      });
      return new _ZodObject({
        ...this._def,
        shape: () => newShape
      });
    }
    keyof() {
      return createZodEnum(util.objectKeys(this.shape));
    }
  };
  ZodObject.create = (shape, params) => {
    return new ZodObject({
      shape: () => shape,
      unknownKeys: "strip",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  ZodObject.strictCreate = (shape, params) => {
    return new ZodObject({
      shape: () => shape,
      unknownKeys: "strict",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  ZodObject.lazycreate = (shape, params) => {
    return new ZodObject({
      shape,
      unknownKeys: "strip",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  var ZodUnion = class extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const options = this._def.options;
      function handleResults(results) {
        for (const result of results) {
          if (result.result.status === "valid") {
            return result.result;
          }
        }
        for (const result of results) {
          if (result.result.status === "dirty") {
            ctx.common.issues.push(...result.ctx.common.issues);
            return result.result;
          }
        }
        const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_union,
          unionErrors
        });
        return INVALID;
      }
      if (ctx.common.async) {
        return Promise.all(options.map(async (option) => {
          const childCtx = {
            ...ctx,
            common: {
              ...ctx.common,
              issues: []
            },
            parent: null
          };
          return {
            result: await option._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: childCtx
            }),
            ctx: childCtx
          };
        })).then(handleResults);
      } else {
        let dirty = void 0;
        const issues = [];
        for (const option of options) {
          const childCtx = {
            ...ctx,
            common: {
              ...ctx.common,
              issues: []
            },
            parent: null
          };
          const result = option._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          });
          if (result.status === "valid") {
            return result;
          } else if (result.status === "dirty" && !dirty) {
            dirty = { result, ctx: childCtx };
          }
          if (childCtx.common.issues.length) {
            issues.push(childCtx.common.issues);
          }
        }
        if (dirty) {
          ctx.common.issues.push(...dirty.ctx.common.issues);
          return dirty.result;
        }
        const unionErrors = issues.map((issues2) => new ZodError(issues2));
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_union,
          unionErrors
        });
        return INVALID;
      }
    }
    get options() {
      return this._def.options;
    }
  };
  ZodUnion.create = (types, params) => {
    return new ZodUnion({
      options: types,
      typeName: ZodFirstPartyTypeKind.ZodUnion,
      ...processCreateParams(params)
    });
  };
  var getDiscriminator = (type) => {
    if (type instanceof ZodLazy) {
      return getDiscriminator(type.schema);
    } else if (type instanceof ZodEffects) {
      return getDiscriminator(type.innerType());
    } else if (type instanceof ZodLiteral) {
      return [type.value];
    } else if (type instanceof ZodEnum) {
      return type.options;
    } else if (type instanceof ZodNativeEnum) {
      return util.objectValues(type.enum);
    } else if (type instanceof ZodDefault) {
      return getDiscriminator(type._def.innerType);
    } else if (type instanceof ZodUndefined) {
      return [void 0];
    } else if (type instanceof ZodNull) {
      return [null];
    } else if (type instanceof ZodOptional) {
      return [void 0, ...getDiscriminator(type.unwrap())];
    } else if (type instanceof ZodNullable) {
      return [null, ...getDiscriminator(type.unwrap())];
    } else if (type instanceof ZodBranded) {
      return getDiscriminator(type.unwrap());
    } else if (type instanceof ZodReadonly) {
      return getDiscriminator(type.unwrap());
    } else if (type instanceof ZodCatch) {
      return getDiscriminator(type._def.innerType);
    } else {
      return [];
    }
  };
  var ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.object) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.object,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const discriminator = this.discriminator;
      const discriminatorValue = ctx.data[discriminator];
      const option = this.optionsMap.get(discriminatorValue);
      if (!option) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_union_discriminator,
          options: Array.from(this.optionsMap.keys()),
          path: [discriminator]
        });
        return INVALID;
      }
      if (ctx.common.async) {
        return option._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
      } else {
        return option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
      }
    }
    get discriminator() {
      return this._def.discriminator;
    }
    get options() {
      return this._def.options;
    }
    get optionsMap() {
      return this._def.optionsMap;
    }
    /**
     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
     * have a different value for each object in the union.
     * @param discriminator the name of the discriminator property
     * @param types an array of object schemas
     * @param params
     */
    static create(discriminator, options, params) {
      const optionsMap = /* @__PURE__ */ new Map();
      for (const type of options) {
        const discriminatorValues = getDiscriminator(type.shape[discriminator]);
        if (!discriminatorValues.length) {
          throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
        }
        for (const value of discriminatorValues) {
          if (optionsMap.has(value)) {
            throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
          }
          optionsMap.set(value, type);
        }
      }
      return new _ZodDiscriminatedUnion({
        typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
        discriminator,
        options,
        optionsMap,
        ...processCreateParams(params)
      });
    }
  };
  function mergeValues(a, b) {
    const aType = getParsedType(a);
    const bType = getParsedType(b);
    if (a === b) {
      return { valid: true, data: a };
    } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
      const bKeys = util.objectKeys(b);
      const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
      const newObj = { ...a, ...b };
      for (const key of sharedKeys) {
        const sharedValue = mergeValues(a[key], b[key]);
        if (!sharedValue.valid) {
          return { valid: false };
        }
        newObj[key] = sharedValue.data;
      }
      return { valid: true, data: newObj };
    } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
      if (a.length !== b.length) {
        return { valid: false };
      }
      const newArray = [];
      for (let index = 0; index < a.length; index++) {
        const itemA = a[index];
        const itemB = b[index];
        const sharedValue = mergeValues(itemA, itemB);
        if (!sharedValue.valid) {
          return { valid: false };
        }
        newArray.push(sharedValue.data);
      }
      return { valid: true, data: newArray };
    } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
      return { valid: true, data: a };
    } else {
      return { valid: false };
    }
  }
  var ZodIntersection = class extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      const handleParsed = (parsedLeft, parsedRight) => {
        if (isAborted(parsedLeft) || isAborted(parsedRight)) {
          return INVALID;
        }
        const merged = mergeValues(parsedLeft.value, parsedRight.value);
        if (!merged.valid) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_intersection_types
          });
          return INVALID;
        }
        if (isDirty(parsedLeft) || isDirty(parsedRight)) {
          status.dirty();
        }
        return { status: status.value, value: merged.data };
      };
      if (ctx.common.async) {
        return Promise.all([
          this._def.left._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }),
          this._def.right._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          })
        ]).then(([left, right]) => handleParsed(left, right));
      } else {
        return handleParsed(this._def.left._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }), this._def.right._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }));
      }
    }
  };
  ZodIntersection.create = (left, right, params) => {
    return new ZodIntersection({
      left,
      right,
      typeName: ZodFirstPartyTypeKind.ZodIntersection,
      ...processCreateParams(params)
    });
  };
  var ZodTuple = class _ZodTuple extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.array) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.array,
          received: ctx.parsedType
        });
        return INVALID;
      }
      if (ctx.data.length < this._def.items.length) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: this._def.items.length,
          inclusive: true,
          exact: false,
          type: "array"
        });
        return INVALID;
      }
      const rest = this._def.rest;
      if (!rest && ctx.data.length > this._def.items.length) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: this._def.items.length,
          inclusive: true,
          exact: false,
          type: "array"
        });
        status.dirty();
      }
      const items = [...ctx.data].map((item, itemIndex) => {
        const schema = this._def.items[itemIndex] || this._def.rest;
        if (!schema)
          return null;
        return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
      }).filter((x) => !!x);
      if (ctx.common.async) {
        return Promise.all(items).then((results) => {
          return ParseStatus.mergeArray(status, results);
        });
      } else {
        return ParseStatus.mergeArray(status, items);
      }
    }
    get items() {
      return this._def.items;
    }
    rest(rest) {
      return new _ZodTuple({
        ...this._def,
        rest
      });
    }
  };
  ZodTuple.create = (schemas, params) => {
    if (!Array.isArray(schemas)) {
      throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    }
    return new ZodTuple({
      items: schemas,
      typeName: ZodFirstPartyTypeKind.ZodTuple,
      rest: null,
      ...processCreateParams(params)
    });
  };
  var ZodRecord = class _ZodRecord extends ZodType {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.object) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.object,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const pairs = [];
      const keyType = this._def.keyType;
      const valueType = this._def.valueType;
      for (const key in ctx.data) {
        pairs.push({
          key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
          value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
          alwaysSet: key in ctx.data
        });
      }
      if (ctx.common.async) {
        return ParseStatus.mergeObjectAsync(status, pairs);
      } else {
        return ParseStatus.mergeObjectSync(status, pairs);
      }
    }
    get element() {
      return this._def.valueType;
    }
    static create(first, second, third) {
      if (second instanceof ZodType) {
        return new _ZodRecord({
          keyType: first,
          valueType: second,
          typeName: ZodFirstPartyTypeKind.ZodRecord,
          ...processCreateParams(third)
        });
      }
      return new _ZodRecord({
        keyType: ZodString.create(),
        valueType: first,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(second)
      });
    }
  };
  var ZodMap = class extends ZodType {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.map) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.map,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const keyType = this._def.keyType;
      const valueType = this._def.valueType;
      const pairs = [...ctx.data.entries()].map(([key, value], index) => {
        return {
          key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
          value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
        };
      });
      if (ctx.common.async) {
        const finalMap = /* @__PURE__ */ new Map();
        return Promise.resolve().then(async () => {
          for (const pair of pairs) {
            const key = await pair.key;
            const value = await pair.value;
            if (key.status === "aborted" || value.status === "aborted") {
              return INVALID;
            }
            if (key.status === "dirty" || value.status === "dirty") {
              status.dirty();
            }
            finalMap.set(key.value, value.value);
          }
          return { status: status.value, value: finalMap };
        });
      } else {
        const finalMap = /* @__PURE__ */ new Map();
        for (const pair of pairs) {
          const key = pair.key;
          const value = pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      }
    }
  };
  ZodMap.create = (keyType, valueType, params) => {
    return new ZodMap({
      valueType,
      keyType,
      typeName: ZodFirstPartyTypeKind.ZodMap,
      ...processCreateParams(params)
    });
  };
  var ZodSet = class _ZodSet extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.set) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.set,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const def = this._def;
      if (def.minSize !== null) {
        if (ctx.data.size < def.minSize.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: def.minSize.value,
            type: "set",
            inclusive: true,
            exact: false,
            message: def.minSize.message
          });
          status.dirty();
        }
      }
      if (def.maxSize !== null) {
        if (ctx.data.size > def.maxSize.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: def.maxSize.value,
            type: "set",
            inclusive: true,
            exact: false,
            message: def.maxSize.message
          });
          status.dirty();
        }
      }
      const valueType = this._def.valueType;
      function finalizeSet(elements2) {
        const parsedSet = /* @__PURE__ */ new Set();
        for (const element of elements2) {
          if (element.status === "aborted")
            return INVALID;
          if (element.status === "dirty")
            status.dirty();
          parsedSet.add(element.value);
        }
        return { status: status.value, value: parsedSet };
      }
      const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
      if (ctx.common.async) {
        return Promise.all(elements).then((elements2) => finalizeSet(elements2));
      } else {
        return finalizeSet(elements);
      }
    }
    min(minSize, message) {
      return new _ZodSet({
        ...this._def,
        minSize: { value: minSize, message: errorUtil.toString(message) }
      });
    }
    max(maxSize, message) {
      return new _ZodSet({
        ...this._def,
        maxSize: { value: maxSize, message: errorUtil.toString(message) }
      });
    }
    size(size, message) {
      return this.min(size, message).max(size, message);
    }
    nonempty(message) {
      return this.min(1, message);
    }
  };
  ZodSet.create = (valueType, params) => {
    return new ZodSet({
      valueType,
      minSize: null,
      maxSize: null,
      typeName: ZodFirstPartyTypeKind.ZodSet,
      ...processCreateParams(params)
    });
  };
  var ZodFunction = class _ZodFunction extends ZodType {
    constructor() {
      super(...arguments);
      this.validate = this.implement;
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.function) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.function,
          received: ctx.parsedType
        });
        return INVALID;
      }
      function makeArgsIssue(args, error) {
        return makeIssue({
          data: args,
          path: ctx.path,
          errorMaps: [
            ctx.common.contextualErrorMap,
            ctx.schemaErrorMap,
            getErrorMap(),
            errorMap
          ].filter((x) => !!x),
          issueData: {
            code: ZodIssueCode.invalid_arguments,
            argumentsError: error
          }
        });
      }
      function makeReturnsIssue(returns, error) {
        return makeIssue({
          data: returns,
          path: ctx.path,
          errorMaps: [
            ctx.common.contextualErrorMap,
            ctx.schemaErrorMap,
            getErrorMap(),
            errorMap
          ].filter((x) => !!x),
          issueData: {
            code: ZodIssueCode.invalid_return_type,
            returnTypeError: error
          }
        });
      }
      const params = { errorMap: ctx.common.contextualErrorMap };
      const fn = ctx.data;
      if (this._def.returns instanceof ZodPromise) {
        const me = this;
        return OK(async function(...args) {
          const error = new ZodError([]);
          const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
            error.addIssue(makeArgsIssue(args, e));
            throw error;
          });
          const result = await Reflect.apply(fn, this, parsedArgs);
          const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
            error.addIssue(makeReturnsIssue(result, e));
            throw error;
          });
          return parsedReturns;
        });
      } else {
        const me = this;
        return OK(function(...args) {
          const parsedArgs = me._def.args.safeParse(args, params);
          if (!parsedArgs.success) {
            throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
          }
          const result = Reflect.apply(fn, this, parsedArgs.data);
          const parsedReturns = me._def.returns.safeParse(result, params);
          if (!parsedReturns.success) {
            throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
          }
          return parsedReturns.data;
        });
      }
    }
    parameters() {
      return this._def.args;
    }
    returnType() {
      return this._def.returns;
    }
    args(...items) {
      return new _ZodFunction({
        ...this._def,
        args: ZodTuple.create(items).rest(ZodUnknown.create())
      });
    }
    returns(returnType) {
      return new _ZodFunction({
        ...this._def,
        returns: returnType
      });
    }
    implement(func) {
      const validatedFunc = this.parse(func);
      return validatedFunc;
    }
    strictImplement(func) {
      const validatedFunc = this.parse(func);
      return validatedFunc;
    }
    static create(args, returns, params) {
      return new _ZodFunction({
        args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
        returns: returns || ZodUnknown.create(),
        typeName: ZodFirstPartyTypeKind.ZodFunction,
        ...processCreateParams(params)
      });
    }
  };
  var ZodLazy = class extends ZodType {
    get schema() {
      return this._def.getter();
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const lazySchema = this._def.getter();
      return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
    }
  };
  ZodLazy.create = (getter, params) => {
    return new ZodLazy({
      getter,
      typeName: ZodFirstPartyTypeKind.ZodLazy,
      ...processCreateParams(params)
    });
  };
  var ZodLiteral = class extends ZodType {
    _parse(input) {
      if (input.data !== this._def.value) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode.invalid_literal,
          expected: this._def.value
        });
        return INVALID;
      }
      return { status: "valid", value: input.data };
    }
    get value() {
      return this._def.value;
    }
  };
  ZodLiteral.create = (value, params) => {
    return new ZodLiteral({
      value,
      typeName: ZodFirstPartyTypeKind.ZodLiteral,
      ...processCreateParams(params)
    });
  };
  function createZodEnum(values, params) {
    return new ZodEnum({
      values,
      typeName: ZodFirstPartyTypeKind.ZodEnum,
      ...processCreateParams(params)
    });
  }
  var ZodEnum = class _ZodEnum extends ZodType {
    constructor() {
      super(...arguments);
      _ZodEnum_cache.set(this, void 0);
    }
    _parse(input) {
      if (typeof input.data !== "string") {
        const ctx = this._getOrReturnCtx(input);
        const expectedValues = this._def.values;
        addIssueToContext(ctx, {
          expected: util.joinValues(expectedValues),
          received: ctx.parsedType,
          code: ZodIssueCode.invalid_type
        });
        return INVALID;
      }
      if (!__classPrivateFieldGet(this, _ZodEnum_cache)) {
        __classPrivateFieldSet(this, _ZodEnum_cache, new Set(this._def.values));
      }
      if (!__classPrivateFieldGet(this, _ZodEnum_cache).has(input.data)) {
        const ctx = this._getOrReturnCtx(input);
        const expectedValues = this._def.values;
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode.invalid_enum_value,
          options: expectedValues
        });
        return INVALID;
      }
      return OK(input.data);
    }
    get options() {
      return this._def.values;
    }
    get enum() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    get Values() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    get Enum() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    extract(values, newDef = this._def) {
      return _ZodEnum.create(values, {
        ...this._def,
        ...newDef
      });
    }
    exclude(values, newDef = this._def) {
      return _ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
        ...this._def,
        ...newDef
      });
    }
  };
  _ZodEnum_cache = /* @__PURE__ */ new WeakMap();
  ZodEnum.create = createZodEnum;
  var ZodNativeEnum = class extends ZodType {
    constructor() {
      super(...arguments);
      _ZodNativeEnum_cache.set(this, void 0);
    }
    _parse(input) {
      const nativeEnumValues = util.getValidEnumValues(this._def.values);
      const ctx = this._getOrReturnCtx(input);
      if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
        const expectedValues = util.objectValues(nativeEnumValues);
        addIssueToContext(ctx, {
          expected: util.joinValues(expectedValues),
          received: ctx.parsedType,
          code: ZodIssueCode.invalid_type
        });
        return INVALID;
      }
      if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache)) {
        __classPrivateFieldSet(this, _ZodNativeEnum_cache, new Set(util.getValidEnumValues(this._def.values)));
      }
      if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache).has(input.data)) {
        const expectedValues = util.objectValues(nativeEnumValues);
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode.invalid_enum_value,
          options: expectedValues
        });
        return INVALID;
      }
      return OK(input.data);
    }
    get enum() {
      return this._def.values;
    }
  };
  _ZodNativeEnum_cache = /* @__PURE__ */ new WeakMap();
  ZodNativeEnum.create = (values, params) => {
    return new ZodNativeEnum({
      values,
      typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
      ...processCreateParams(params)
    });
  };
  var ZodPromise = class extends ZodType {
    unwrap() {
      return this._def.type;
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.promise,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
      return OK(promisified.then((data) => {
        return this._def.type.parseAsync(data, {
          path: ctx.path,
          errorMap: ctx.common.contextualErrorMap
        });
      }));
    }
  };
  ZodPromise.create = (schema, params) => {
    return new ZodPromise({
      type: schema,
      typeName: ZodFirstPartyTypeKind.ZodPromise,
      ...processCreateParams(params)
    });
  };
  var ZodEffects = class extends ZodType {
    innerType() {
      return this._def.schema;
    }
    sourceType() {
      return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      const effect = this._def.effect || null;
      const checkCtx = {
        addIssue: (arg) => {
          addIssueToContext(ctx, arg);
          if (arg.fatal) {
            status.abort();
          } else {
            status.dirty();
          }
        },
        get path() {
          return ctx.path;
        }
      };
      checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
      if (effect.type === "preprocess") {
        const processed = effect.transform(ctx.data, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(processed).then(async (processed2) => {
            if (status.value === "aborted")
              return INVALID;
            const result = await this._def.schema._parseAsync({
              data: processed2,
              path: ctx.path,
              parent: ctx
            });
            if (result.status === "aborted")
              return INVALID;
            if (result.status === "dirty")
              return DIRTY(result.value);
            if (status.value === "dirty")
              return DIRTY(result.value);
            return result;
          });
        } else {
          if (status.value === "aborted")
            return INVALID;
          const result = this._def.schema._parseSync({
            data: processed,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status.value === "dirty")
            return DIRTY(result.value);
          return result;
        }
      }
      if (effect.type === "refinement") {
        const executeRefinement = (acc) => {
          const result = effect.refinement(acc, checkCtx);
          if (ctx.common.async) {
            return Promise.resolve(result);
          }
          if (result instanceof Promise) {
            throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
          }
          return acc;
        };
        if (ctx.common.async === false) {
          const inner = this._def.schema._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          executeRefinement(inner.value);
          return { status: status.value, value: inner.value };
        } else {
          return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
            if (inner.status === "aborted")
              return INVALID;
            if (inner.status === "dirty")
              status.dirty();
            return executeRefinement(inner.value).then(() => {
              return { status: status.value, value: inner.value };
            });
          });
        }
      }
      if (effect.type === "transform") {
        if (ctx.common.async === false) {
          const base = this._def.schema._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (!isValid(base))
            return base;
          const result = effect.transform(base.value, checkCtx);
          if (result instanceof Promise) {
            throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
          }
          return { status: status.value, value: result };
        } else {
          return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
            if (!isValid(base))
              return base;
            return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
          });
        }
      }
      util.assertNever(effect);
    }
  };
  ZodEffects.create = (schema, effect, params) => {
    return new ZodEffects({
      schema,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect,
      ...processCreateParams(params)
    });
  };
  ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
    return new ZodEffects({
      schema,
      effect: { type: "preprocess", transform: preprocess },
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      ...processCreateParams(params)
    });
  };
  var ZodOptional = class extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType === ZodParsedType.undefined) {
        return OK(void 0);
      }
      return this._def.innerType._parse(input);
    }
    unwrap() {
      return this._def.innerType;
    }
  };
  ZodOptional.create = (type, params) => {
    return new ZodOptional({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodOptional,
      ...processCreateParams(params)
    });
  };
  var ZodNullable = class extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType === ZodParsedType.null) {
        return OK(null);
      }
      return this._def.innerType._parse(input);
    }
    unwrap() {
      return this._def.innerType;
    }
  };
  ZodNullable.create = (type, params) => {
    return new ZodNullable({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodNullable,
      ...processCreateParams(params)
    });
  };
  var ZodDefault = class extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      let data = ctx.data;
      if (ctx.parsedType === ZodParsedType.undefined) {
        data = this._def.defaultValue();
      }
      return this._def.innerType._parse({
        data,
        path: ctx.path,
        parent: ctx
      });
    }
    removeDefault() {
      return this._def.innerType;
    }
  };
  ZodDefault.create = (type, params) => {
    return new ZodDefault({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodDefault,
      defaultValue: typeof params.default === "function" ? params.default : () => params.default,
      ...processCreateParams(params)
    });
  };
  var ZodCatch = class extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const newCtx = {
        ...ctx,
        common: {
          ...ctx.common,
          issues: []
        }
      };
      const result = this._def.innerType._parse({
        data: newCtx.data,
        path: newCtx.path,
        parent: {
          ...newCtx
        }
      });
      if (isAsync(result)) {
        return result.then((result2) => {
          return {
            status: "valid",
            value: result2.status === "valid" ? result2.value : this._def.catchValue({
              get error() {
                return new ZodError(newCtx.common.issues);
              },
              input: newCtx.data
            })
          };
        });
      } else {
        return {
          status: "valid",
          value: result.status === "valid" ? result.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      }
    }
    removeCatch() {
      return this._def.innerType;
    }
  };
  ZodCatch.create = (type, params) => {
    return new ZodCatch({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodCatch,
      catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
      ...processCreateParams(params)
    });
  };
  var ZodNaN = class extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.nan) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.nan,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return { status: "valid", value: input.data };
    }
  };
  ZodNaN.create = (params) => {
    return new ZodNaN({
      typeName: ZodFirstPartyTypeKind.ZodNaN,
      ...processCreateParams(params)
    });
  };
  var BRAND = Symbol("zod_brand");
  var ZodBranded = class extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const data = ctx.data;
      return this._def.type._parse({
        data,
        path: ctx.path,
        parent: ctx
      });
    }
    unwrap() {
      return this._def.type;
    }
  };
  var ZodPipeline = class _ZodPipeline extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.common.async) {
        const handleAsync = async () => {
          const inResult = await this._def.in._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inResult.status === "aborted")
            return INVALID;
          if (inResult.status === "dirty") {
            status.dirty();
            return DIRTY(inResult.value);
          } else {
            return this._def.out._parseAsync({
              data: inResult.value,
              path: ctx.path,
              parent: ctx
            });
          }
        };
        return handleAsync();
      } else {
        const inResult = this._def.in._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return {
            status: "dirty",
            value: inResult.value
          };
        } else {
          return this._def.out._parseSync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      }
    }
    static create(a, b) {
      return new _ZodPipeline({
        in: a,
        out: b,
        typeName: ZodFirstPartyTypeKind.ZodPipeline
      });
    }
  };
  var ZodReadonly = class extends ZodType {
    _parse(input) {
      const result = this._def.innerType._parse(input);
      const freeze = (data) => {
        if (isValid(data)) {
          data.value = Object.freeze(data.value);
        }
        return data;
      };
      return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
    }
    unwrap() {
      return this._def.innerType;
    }
  };
  ZodReadonly.create = (type, params) => {
    return new ZodReadonly({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodReadonly,
      ...processCreateParams(params)
    });
  };
  function custom(check, params = {}, fatal) {
    if (check)
      return ZodAny.create().superRefine((data, ctx) => {
        var _a, _b;
        if (!check(data)) {
          const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
          const _fatal = (_b = (_a = p.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
          const p2 = typeof p === "string" ? { message: p } : p;
          ctx.addIssue({ code: "custom", ...p2, fatal: _fatal });
        }
      });
    return ZodAny.create();
  }
  var late = {
    object: ZodObject.lazycreate
  };
  var ZodFirstPartyTypeKind;
  (function(ZodFirstPartyTypeKind2) {
    ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
    ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
    ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
    ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
    ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
    ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
    ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
    ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
    ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
    ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
    ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
    ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
    ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
    ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
    ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
    ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
    ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
    ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
    ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
    ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
    ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
    ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
    ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
    ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
    ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
    ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
    ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
    ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
    ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
    ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
    ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
    ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
    ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
    ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
    ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
    ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
  })(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
  var instanceOfType = (cls, params = {
    message: `Input not instance of ${cls.name}`
  }) => custom((data) => data instanceof cls, params);
  var stringType = ZodString.create;
  var numberType = ZodNumber.create;
  var nanType = ZodNaN.create;
  var bigIntType = ZodBigInt.create;
  var booleanType = ZodBoolean.create;
  var dateType = ZodDate.create;
  var symbolType = ZodSymbol.create;
  var undefinedType = ZodUndefined.create;
  var nullType = ZodNull.create;
  var anyType = ZodAny.create;
  var unknownType = ZodUnknown.create;
  var neverType = ZodNever.create;
  var voidType = ZodVoid.create;
  var arrayType = ZodArray.create;
  var objectType = ZodObject.create;
  var strictObjectType = ZodObject.strictCreate;
  var unionType = ZodUnion.create;
  var discriminatedUnionType = ZodDiscriminatedUnion.create;
  var intersectionType = ZodIntersection.create;
  var tupleType = ZodTuple.create;
  var recordType = ZodRecord.create;
  var mapType = ZodMap.create;
  var setType = ZodSet.create;
  var functionType = ZodFunction.create;
  var lazyType = ZodLazy.create;
  var literalType = ZodLiteral.create;
  var enumType = ZodEnum.create;
  var nativeEnumType = ZodNativeEnum.create;
  var promiseType = ZodPromise.create;
  var effectsType = ZodEffects.create;
  var optionalType = ZodOptional.create;
  var nullableType = ZodNullable.create;
  var preprocessType = ZodEffects.createWithPreprocess;
  var pipelineType = ZodPipeline.create;
  var ostring = () => stringType().optional();
  var onumber = () => numberType().optional();
  var oboolean = () => booleanType().optional();
  var coerce = {
    string: (arg) => ZodString.create({ ...arg, coerce: true }),
    number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
    boolean: (arg) => ZodBoolean.create({
      ...arg,
      coerce: true
    }),
    bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
    date: (arg) => ZodDate.create({ ...arg, coerce: true })
  };
  var NEVER = INVALID;
  var z = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    defaultErrorMap: errorMap,
    setErrorMap,
    getErrorMap,
    makeIssue,
    EMPTY_PATH,
    addIssueToContext,
    ParseStatus,
    INVALID,
    DIRTY,
    OK,
    isAborted,
    isDirty,
    isValid,
    isAsync,
    get util() {
      return util;
    },
    get objectUtil() {
      return objectUtil;
    },
    ZodParsedType,
    getParsedType,
    ZodType,
    datetimeRegex,
    ZodString,
    ZodNumber,
    ZodBigInt,
    ZodBoolean,
    ZodDate,
    ZodSymbol,
    ZodUndefined,
    ZodNull,
    ZodAny,
    ZodUnknown,
    ZodNever,
    ZodVoid,
    ZodArray,
    ZodObject,
    ZodUnion,
    ZodDiscriminatedUnion,
    ZodIntersection,
    ZodTuple,
    ZodRecord,
    ZodMap,
    ZodSet,
    ZodFunction,
    ZodLazy,
    ZodLiteral,
    ZodEnum,
    ZodNativeEnum,
    ZodPromise,
    ZodEffects,
    ZodTransformer: ZodEffects,
    ZodOptional,
    ZodNullable,
    ZodDefault,
    ZodCatch,
    ZodNaN,
    BRAND,
    ZodBranded,
    ZodPipeline,
    ZodReadonly,
    custom,
    Schema: ZodType,
    ZodSchema: ZodType,
    late,
    get ZodFirstPartyTypeKind() {
      return ZodFirstPartyTypeKind;
    },
    coerce,
    any: anyType,
    array: arrayType,
    bigint: bigIntType,
    boolean: booleanType,
    date: dateType,
    discriminatedUnion: discriminatedUnionType,
    effect: effectsType,
    "enum": enumType,
    "function": functionType,
    "instanceof": instanceOfType,
    intersection: intersectionType,
    lazy: lazyType,
    literal: literalType,
    map: mapType,
    nan: nanType,
    nativeEnum: nativeEnumType,
    never: neverType,
    "null": nullType,
    nullable: nullableType,
    number: numberType,
    object: objectType,
    oboolean,
    onumber,
    optional: optionalType,
    ostring,
    pipeline: pipelineType,
    preprocess: preprocessType,
    promise: promiseType,
    record: recordType,
    set: setType,
    strictObject: strictObjectType,
    string: stringType,
    symbol: symbolType,
    transformer: effectsType,
    tuple: tupleType,
    "undefined": undefinedType,
    union: unionType,
    unknown: unknownType,
    "void": voidType,
    NEVER,
    ZodIssueCode,
    quotelessJson,
    ZodError
  });

  // src/validators/common.validators.ts
  z.object({
    roomId: z.string({
      required_error: "Room id must provided"
    }),
    token: z.string({
      required_error: "Token must provided"
    })
  });
  var GeolocationSchema = z.object({
    country: z.string({
      required_error: "Country must provided"
    }),
    latitude: z.string({
      required_error: "Latitude must provided"
    }),
    longitude: z.string({
      required_error: "Longitude must provided"
    }),
    region: z.string({
      required_error: "Region must provided"
    }),
    globalRegion: z.string({
      required_error: "Global region must provided"
    }),
    ip: z.string({
      required_error: "IP must provided"
    })
  });
  z.object({
    from: z.string(),
    payload: z.unknown(),
    label: z.string().optional(),
    to: z.union([z.literal("*"), z.array(z.string())]).optional()
  });
  z.object({
    from: z.string(),
    payload: z.string(),
    label: z.string().optional()
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/private/assert.js
  function assert(condition, msg) {
    if (!condition) {
      throw new Error(msg);
    }
  }
  var FLOAT32_MAX = 34028234663852886e22;
  var FLOAT32_MIN = -34028234663852886e22;
  var UINT32_MAX = 4294967295;
  var INT32_MAX = 2147483647;
  var INT32_MIN = -2147483648;
  function assertInt32(arg) {
    if (typeof arg !== "number")
      throw new Error("invalid int 32: " + typeof arg);
    if (!Number.isInteger(arg) || arg > INT32_MAX || arg < INT32_MIN)
      throw new Error("invalid int 32: " + arg);
  }
  function assertUInt32(arg) {
    if (typeof arg !== "number")
      throw new Error("invalid uint 32: " + typeof arg);
    if (!Number.isInteger(arg) || arg > UINT32_MAX || arg < 0)
      throw new Error("invalid uint 32: " + arg);
  }
  function assertFloat32(arg) {
    if (typeof arg !== "number")
      throw new Error("invalid float 32: " + typeof arg);
    if (!Number.isFinite(arg))
      return;
    if (arg > FLOAT32_MAX || arg < FLOAT32_MIN)
      throw new Error("invalid float 32: " + arg);
  }

  // ../../node_modules/@bufbuild/protobuf/dist/esm/private/enum.js
  var enumTypeSymbol = Symbol("@bufbuild/protobuf/enum-type");
  function getEnumType(enumObject) {
    const t = enumObject[enumTypeSymbol];
    assert(t, "missing enum type on enum object");
    return t;
  }
  function setEnumType(enumObject, typeName, values, opt) {
    enumObject[enumTypeSymbol] = makeEnumType(typeName, values.map((v) => ({
      no: v.no,
      name: v.name,
      localName: enumObject[v.no]
    })));
  }
  function makeEnumType(typeName, values, _opt) {
    const names = /* @__PURE__ */ Object.create(null);
    const numbers = /* @__PURE__ */ Object.create(null);
    const normalValues = [];
    for (const value of values) {
      const n = normalizeEnumValue(value);
      normalValues.push(n);
      names[value.name] = n;
      numbers[value.no] = n;
    }
    return {
      typeName,
      values: normalValues,
      // We do not surface options at this time
      // options: opt?.options ?? Object.create(null),
      findName(name) {
        return names[name];
      },
      findNumber(no) {
        return numbers[no];
      }
    };
  }
  function makeEnum(typeName, values, opt) {
    const enumObject = {};
    for (const value of values) {
      const n = normalizeEnumValue(value);
      enumObject[n.localName] = n.no;
      enumObject[n.no] = n.localName;
    }
    setEnumType(enumObject, typeName, values);
    return enumObject;
  }
  function normalizeEnumValue(value) {
    if ("localName" in value) {
      return value;
    }
    return Object.assign(Object.assign({}, value), { localName: value.name });
  }

  // ../../node_modules/@bufbuild/protobuf/dist/esm/message.js
  var Message = class {
    /**
     * Compare with a message of the same type.
     * Note that this function disregards extensions and unknown fields.
     */
    equals(other) {
      return this.getType().runtime.util.equals(this.getType(), this, other);
    }
    /**
     * Create a deep copy.
     */
    clone() {
      return this.getType().runtime.util.clone(this);
    }
    /**
     * Parse from binary data, merging fields.
     *
     * Repeated fields are appended. Map entries are added, overwriting
     * existing keys.
     *
     * If a message field is already present, it will be merged with the
     * new data.
     */
    fromBinary(bytes, options) {
      const type = this.getType(), format = type.runtime.bin, opt = format.makeReadOptions(options);
      format.readMessage(this, opt.readerFactory(bytes), bytes.byteLength, opt);
      return this;
    }
    /**
     * Parse a message from a JSON value.
     */
    fromJson(jsonValue, options) {
      const type = this.getType(), format = type.runtime.json, opt = format.makeReadOptions(options);
      format.readMessage(type, jsonValue, opt, this);
      return this;
    }
    /**
     * Parse a message from a JSON string.
     */
    fromJsonString(jsonString, options) {
      let json;
      try {
        json = JSON.parse(jsonString);
      } catch (e) {
        throw new Error(`cannot decode ${this.getType().typeName} from JSON: ${e instanceof Error ? e.message : String(e)}`);
      }
      return this.fromJson(json, options);
    }
    /**
     * Serialize the message to binary data.
     */
    toBinary(options) {
      const type = this.getType(), bin = type.runtime.bin, opt = bin.makeWriteOptions(options), writer = opt.writerFactory();
      bin.writeMessage(this, writer, opt);
      return writer.finish();
    }
    /**
     * Serialize the message to a JSON value, a JavaScript value that can be
     * passed to JSON.stringify().
     */
    toJson(options) {
      const type = this.getType(), json = type.runtime.json, opt = json.makeWriteOptions(options);
      return json.writeMessage(this, opt);
    }
    /**
     * Serialize the message to a JSON string.
     */
    toJsonString(options) {
      var _a;
      const value = this.toJson(options);
      return JSON.stringify(value, null, (_a = options === null || options === void 0 ? void 0 : options.prettySpaces) !== null && _a !== void 0 ? _a : 0);
    }
    /**
     * Override for serialization behavior. This will be invoked when calling
     * JSON.stringify on this message (i.e. JSON.stringify(msg)).
     *
     * Note that this will not serialize google.protobuf.Any with a packed
     * message because the protobuf JSON format specifies that it needs to be
     * unpacked, and this is only possible with a type registry to look up the
     * message type.  As a result, attempting to serialize a message with this
     * type will throw an Error.
     *
     * This method is protected because you should not need to invoke it
     * directly -- instead use JSON.stringify or toJsonString for
     * stringified JSON.  Alternatively, if actual JSON is desired, you should
     * use toJson.
     */
    toJSON() {
      return this.toJson({
        emitDefaultValues: true
      });
    }
    /**
     * Retrieve the MessageType of this message - a singleton that represents
     * the protobuf message declaration and provides metadata for reflection-
     * based operations.
     */
    getType() {
      return Object.getPrototypeOf(this).constructor;
    }
  };

  // ../../node_modules/@bufbuild/protobuf/dist/esm/private/message-type.js
  function makeMessageType(runtime, typeName, fields, opt) {
    var _a;
    const localName = (_a = opt === null || opt === void 0 ? void 0 : opt.localName) !== null && _a !== void 0 ? _a : typeName.substring(typeName.lastIndexOf(".") + 1);
    const type = {
      [localName]: function(data) {
        runtime.util.initFields(this);
        runtime.util.initPartial(data, this);
      }
    }[localName];
    Object.setPrototypeOf(type.prototype, new Message());
    Object.assign(type, {
      runtime,
      typeName,
      fields: runtime.util.newFieldList(fields),
      fromBinary(bytes, options) {
        return new type().fromBinary(bytes, options);
      },
      fromJson(jsonValue, options) {
        return new type().fromJson(jsonValue, options);
      },
      fromJsonString(jsonString, options) {
        return new type().fromJsonString(jsonString, options);
      },
      equals(a, b) {
        return runtime.util.equals(type, a, b);
      }
    });
    return type;
  }

  // ../../node_modules/@bufbuild/protobuf/dist/esm/google/varint.js
  function varint64read() {
    let lowBits = 0;
    let highBits = 0;
    for (let shift = 0; shift < 28; shift += 7) {
      let b = this.buf[this.pos++];
      lowBits |= (b & 127) << shift;
      if ((b & 128) == 0) {
        this.assertBounds();
        return [lowBits, highBits];
      }
    }
    let middleByte = this.buf[this.pos++];
    lowBits |= (middleByte & 15) << 28;
    highBits = (middleByte & 112) >> 4;
    if ((middleByte & 128) == 0) {
      this.assertBounds();
      return [lowBits, highBits];
    }
    for (let shift = 3; shift <= 31; shift += 7) {
      let b = this.buf[this.pos++];
      highBits |= (b & 127) << shift;
      if ((b & 128) == 0) {
        this.assertBounds();
        return [lowBits, highBits];
      }
    }
    throw new Error("invalid varint");
  }
  function varint64write(lo, hi, bytes) {
    for (let i = 0; i < 28; i = i + 7) {
      const shift = lo >>> i;
      const hasNext = !(shift >>> 7 == 0 && hi == 0);
      const byte = (hasNext ? shift | 128 : shift) & 255;
      bytes.push(byte);
      if (!hasNext) {
        return;
      }
    }
    const splitBits = lo >>> 28 & 15 | (hi & 7) << 4;
    const hasMoreBits = !(hi >> 3 == 0);
    bytes.push((hasMoreBits ? splitBits | 128 : splitBits) & 255);
    if (!hasMoreBits) {
      return;
    }
    for (let i = 3; i < 31; i = i + 7) {
      const shift = hi >>> i;
      const hasNext = !(shift >>> 7 == 0);
      const byte = (hasNext ? shift | 128 : shift) & 255;
      bytes.push(byte);
      if (!hasNext) {
        return;
      }
    }
    bytes.push(hi >>> 31 & 1);
  }
  var TWO_PWR_32_DBL = 4294967296;
  function int64FromString(dec) {
    const minus = dec[0] === "-";
    if (minus) {
      dec = dec.slice(1);
    }
    const base = 1e6;
    let lowBits = 0;
    let highBits = 0;
    function add1e6digit(begin, end) {
      const digit1e6 = Number(dec.slice(begin, end));
      highBits *= base;
      lowBits = lowBits * base + digit1e6;
      if (lowBits >= TWO_PWR_32_DBL) {
        highBits = highBits + (lowBits / TWO_PWR_32_DBL | 0);
        lowBits = lowBits % TWO_PWR_32_DBL;
      }
    }
    add1e6digit(-24, -18);
    add1e6digit(-18, -12);
    add1e6digit(-12, -6);
    add1e6digit(-6);
    return minus ? negate(lowBits, highBits) : newBits(lowBits, highBits);
  }
  function int64ToString(lo, hi) {
    let bits = newBits(lo, hi);
    const negative = bits.hi & 2147483648;
    if (negative) {
      bits = negate(bits.lo, bits.hi);
    }
    const result = uInt64ToString(bits.lo, bits.hi);
    return negative ? "-" + result : result;
  }
  function uInt64ToString(lo, hi) {
    ({ lo, hi } = toUnsigned(lo, hi));
    if (hi <= 2097151) {
      return String(TWO_PWR_32_DBL * hi + lo);
    }
    const low = lo & 16777215;
    const mid = (lo >>> 24 | hi << 8) & 16777215;
    const high = hi >> 16 & 65535;
    let digitA = low + mid * 6777216 + high * 6710656;
    let digitB = mid + high * 8147497;
    let digitC = high * 2;
    const base = 1e7;
    if (digitA >= base) {
      digitB += Math.floor(digitA / base);
      digitA %= base;
    }
    if (digitB >= base) {
      digitC += Math.floor(digitB / base);
      digitB %= base;
    }
    return digitC.toString() + decimalFrom1e7WithLeadingZeros(digitB) + decimalFrom1e7WithLeadingZeros(digitA);
  }
  function toUnsigned(lo, hi) {
    return { lo: lo >>> 0, hi: hi >>> 0 };
  }
  function newBits(lo, hi) {
    return { lo: lo | 0, hi: hi | 0 };
  }
  function negate(lowBits, highBits) {
    highBits = ~highBits;
    if (lowBits) {
      lowBits = ~lowBits + 1;
    } else {
      highBits += 1;
    }
    return newBits(lowBits, highBits);
  }
  var decimalFrom1e7WithLeadingZeros = (digit1e7) => {
    const partial = String(digit1e7);
    return "0000000".slice(partial.length) + partial;
  };
  function varint32write(value, bytes) {
    if (value >= 0) {
      while (value > 127) {
        bytes.push(value & 127 | 128);
        value = value >>> 7;
      }
      bytes.push(value);
    } else {
      for (let i = 0; i < 9; i++) {
        bytes.push(value & 127 | 128);
        value = value >> 7;
      }
      bytes.push(1);
    }
  }
  function varint32read() {
    let b = this.buf[this.pos++];
    let result = b & 127;
    if ((b & 128) == 0) {
      this.assertBounds();
      return result;
    }
    b = this.buf[this.pos++];
    result |= (b & 127) << 7;
    if ((b & 128) == 0) {
      this.assertBounds();
      return result;
    }
    b = this.buf[this.pos++];
    result |= (b & 127) << 14;
    if ((b & 128) == 0) {
      this.assertBounds();
      return result;
    }
    b = this.buf[this.pos++];
    result |= (b & 127) << 21;
    if ((b & 128) == 0) {
      this.assertBounds();
      return result;
    }
    b = this.buf[this.pos++];
    result |= (b & 15) << 28;
    for (let readBytes = 5; (b & 128) !== 0 && readBytes < 10; readBytes++)
      b = this.buf[this.pos++];
    if ((b & 128) != 0)
      throw new Error("invalid varint");
    this.assertBounds();
    return result >>> 0;
  }

  // ../../node_modules/@bufbuild/protobuf/dist/esm/proto-int64.js
  function makeInt64Support() {
    const dv = new DataView(new ArrayBuffer(8));
    const ok = typeof BigInt === "function" && typeof dv.getBigInt64 === "function" && typeof dv.getBigUint64 === "function" && typeof dv.setBigInt64 === "function" && typeof dv.setBigUint64 === "function" && (typeof process != "object" || typeof process.env != "object" || process.env.BUF_BIGINT_DISABLE !== "1");
    if (ok) {
      const MIN = BigInt("-9223372036854775808"), MAX = BigInt("9223372036854775807"), UMIN = BigInt("0"), UMAX = BigInt("18446744073709551615");
      return {
        zero: BigInt(0),
        supported: true,
        parse(value) {
          const bi = typeof value == "bigint" ? value : BigInt(value);
          if (bi > MAX || bi < MIN) {
            throw new Error(`int64 invalid: ${value}`);
          }
          return bi;
        },
        uParse(value) {
          const bi = typeof value == "bigint" ? value : BigInt(value);
          if (bi > UMAX || bi < UMIN) {
            throw new Error(`uint64 invalid: ${value}`);
          }
          return bi;
        },
        enc(value) {
          dv.setBigInt64(0, this.parse(value), true);
          return {
            lo: dv.getInt32(0, true),
            hi: dv.getInt32(4, true)
          };
        },
        uEnc(value) {
          dv.setBigInt64(0, this.uParse(value), true);
          return {
            lo: dv.getInt32(0, true),
            hi: dv.getInt32(4, true)
          };
        },
        dec(lo, hi) {
          dv.setInt32(0, lo, true);
          dv.setInt32(4, hi, true);
          return dv.getBigInt64(0, true);
        },
        uDec(lo, hi) {
          dv.setInt32(0, lo, true);
          dv.setInt32(4, hi, true);
          return dv.getBigUint64(0, true);
        }
      };
    }
    const assertInt64String = (value) => assert(/^-?[0-9]+$/.test(value), `int64 invalid: ${value}`);
    const assertUInt64String = (value) => assert(/^[0-9]+$/.test(value), `uint64 invalid: ${value}`);
    return {
      zero: "0",
      supported: false,
      parse(value) {
        if (typeof value != "string") {
          value = value.toString();
        }
        assertInt64String(value);
        return value;
      },
      uParse(value) {
        if (typeof value != "string") {
          value = value.toString();
        }
        assertUInt64String(value);
        return value;
      },
      enc(value) {
        if (typeof value != "string") {
          value = value.toString();
        }
        assertInt64String(value);
        return int64FromString(value);
      },
      uEnc(value) {
        if (typeof value != "string") {
          value = value.toString();
        }
        assertUInt64String(value);
        return int64FromString(value);
      },
      dec(lo, hi) {
        return int64ToString(lo, hi);
      },
      uDec(lo, hi) {
        return uInt64ToString(lo, hi);
      }
    };
  }
  var protoInt64 = makeInt64Support();

  // ../../node_modules/@bufbuild/protobuf/dist/esm/scalar.js
  var ScalarType;
  (function(ScalarType2) {
    ScalarType2[ScalarType2["DOUBLE"] = 1] = "DOUBLE";
    ScalarType2[ScalarType2["FLOAT"] = 2] = "FLOAT";
    ScalarType2[ScalarType2["INT64"] = 3] = "INT64";
    ScalarType2[ScalarType2["UINT64"] = 4] = "UINT64";
    ScalarType2[ScalarType2["INT32"] = 5] = "INT32";
    ScalarType2[ScalarType2["FIXED64"] = 6] = "FIXED64";
    ScalarType2[ScalarType2["FIXED32"] = 7] = "FIXED32";
    ScalarType2[ScalarType2["BOOL"] = 8] = "BOOL";
    ScalarType2[ScalarType2["STRING"] = 9] = "STRING";
    ScalarType2[ScalarType2["BYTES"] = 12] = "BYTES";
    ScalarType2[ScalarType2["UINT32"] = 13] = "UINT32";
    ScalarType2[ScalarType2["SFIXED32"] = 15] = "SFIXED32";
    ScalarType2[ScalarType2["SFIXED64"] = 16] = "SFIXED64";
    ScalarType2[ScalarType2["SINT32"] = 17] = "SINT32";
    ScalarType2[ScalarType2["SINT64"] = 18] = "SINT64";
  })(ScalarType || (ScalarType = {}));
  var LongType;
  (function(LongType2) {
    LongType2[LongType2["BIGINT"] = 0] = "BIGINT";
    LongType2[LongType2["STRING"] = 1] = "STRING";
  })(LongType || (LongType = {}));

  // ../../node_modules/@bufbuild/protobuf/dist/esm/private/scalars.js
  function scalarEquals(type, a, b) {
    if (a === b) {
      return true;
    }
    if (type == ScalarType.BYTES) {
      if (!(a instanceof Uint8Array) || !(b instanceof Uint8Array)) {
        return false;
      }
      if (a.length !== b.length) {
        return false;
      }
      for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) {
          return false;
        }
      }
      return true;
    }
    switch (type) {
      case ScalarType.UINT64:
      case ScalarType.FIXED64:
      case ScalarType.INT64:
      case ScalarType.SFIXED64:
      case ScalarType.SINT64:
        return a == b;
    }
    return false;
  }
  function scalarZeroValue(type, longType) {
    switch (type) {
      case ScalarType.BOOL:
        return false;
      case ScalarType.UINT64:
      case ScalarType.FIXED64:
      case ScalarType.INT64:
      case ScalarType.SFIXED64:
      case ScalarType.SINT64:
        return longType == 0 ? protoInt64.zero : "0";
      case ScalarType.DOUBLE:
      case ScalarType.FLOAT:
        return 0;
      case ScalarType.BYTES:
        return new Uint8Array(0);
      case ScalarType.STRING:
        return "";
      default:
        return 0;
    }
  }
  function isScalarZeroValue(type, value) {
    switch (type) {
      case ScalarType.BOOL:
        return value === false;
      case ScalarType.STRING:
        return value === "";
      case ScalarType.BYTES:
        return value instanceof Uint8Array && !value.byteLength;
      default:
        return value == 0;
    }
  }

  // ../../node_modules/@bufbuild/protobuf/dist/esm/binary-encoding.js
  var WireType;
  (function(WireType2) {
    WireType2[WireType2["Varint"] = 0] = "Varint";
    WireType2[WireType2["Bit64"] = 1] = "Bit64";
    WireType2[WireType2["LengthDelimited"] = 2] = "LengthDelimited";
    WireType2[WireType2["StartGroup"] = 3] = "StartGroup";
    WireType2[WireType2["EndGroup"] = 4] = "EndGroup";
    WireType2[WireType2["Bit32"] = 5] = "Bit32";
  })(WireType || (WireType = {}));
  var BinaryWriter = class {
    constructor(textEncoder) {
      this.stack = [];
      this.textEncoder = textEncoder !== null && textEncoder !== void 0 ? textEncoder : new TextEncoder();
      this.chunks = [];
      this.buf = [];
    }
    /**
     * Return all bytes written and reset this writer.
     */
    finish() {
      this.chunks.push(new Uint8Array(this.buf));
      let len = 0;
      for (let i = 0; i < this.chunks.length; i++)
        len += this.chunks[i].length;
      let bytes = new Uint8Array(len);
      let offset = 0;
      for (let i = 0; i < this.chunks.length; i++) {
        bytes.set(this.chunks[i], offset);
        offset += this.chunks[i].length;
      }
      this.chunks = [];
      return bytes;
    }
    /**
     * Start a new fork for length-delimited data like a message
     * or a packed repeated field.
     *
     * Must be joined later with `join()`.
     */
    fork() {
      this.stack.push({ chunks: this.chunks, buf: this.buf });
      this.chunks = [];
      this.buf = [];
      return this;
    }
    /**
     * Join the last fork. Write its length and bytes, then
     * return to the previous state.
     */
    join() {
      let chunk = this.finish();
      let prev = this.stack.pop();
      if (!prev)
        throw new Error("invalid state, fork stack empty");
      this.chunks = prev.chunks;
      this.buf = prev.buf;
      this.uint32(chunk.byteLength);
      return this.raw(chunk);
    }
    /**
     * Writes a tag (field number and wire type).
     *
     * Equivalent to `uint32( (fieldNo << 3 | type) >>> 0 )`.
     *
     * Generated code should compute the tag ahead of time and call `uint32()`.
     */
    tag(fieldNo, type) {
      return this.uint32((fieldNo << 3 | type) >>> 0);
    }
    /**
     * Write a chunk of raw bytes.
     */
    raw(chunk) {
      if (this.buf.length) {
        this.chunks.push(new Uint8Array(this.buf));
        this.buf = [];
      }
      this.chunks.push(chunk);
      return this;
    }
    /**
     * Write a `uint32` value, an unsigned 32 bit varint.
     */
    uint32(value) {
      assertUInt32(value);
      while (value > 127) {
        this.buf.push(value & 127 | 128);
        value = value >>> 7;
      }
      this.buf.push(value);
      return this;
    }
    /**
     * Write a `int32` value, a signed 32 bit varint.
     */
    int32(value) {
      assertInt32(value);
      varint32write(value, this.buf);
      return this;
    }
    /**
     * Write a `bool` value, a variant.
     */
    bool(value) {
      this.buf.push(value ? 1 : 0);
      return this;
    }
    /**
     * Write a `bytes` value, length-delimited arbitrary data.
     */
    bytes(value) {
      this.uint32(value.byteLength);
      return this.raw(value);
    }
    /**
     * Write a `string` value, length-delimited data converted to UTF-8 text.
     */
    string(value) {
      let chunk = this.textEncoder.encode(value);
      this.uint32(chunk.byteLength);
      return this.raw(chunk);
    }
    /**
     * Write a `float` value, 32-bit floating point number.
     */
    float(value) {
      assertFloat32(value);
      let chunk = new Uint8Array(4);
      new DataView(chunk.buffer).setFloat32(0, value, true);
      return this.raw(chunk);
    }
    /**
     * Write a `double` value, a 64-bit floating point number.
     */
    double(value) {
      let chunk = new Uint8Array(8);
      new DataView(chunk.buffer).setFloat64(0, value, true);
      return this.raw(chunk);
    }
    /**
     * Write a `fixed32` value, an unsigned, fixed-length 32-bit integer.
     */
    fixed32(value) {
      assertUInt32(value);
      let chunk = new Uint8Array(4);
      new DataView(chunk.buffer).setUint32(0, value, true);
      return this.raw(chunk);
    }
    /**
     * Write a `sfixed32` value, a signed, fixed-length 32-bit integer.
     */
    sfixed32(value) {
      assertInt32(value);
      let chunk = new Uint8Array(4);
      new DataView(chunk.buffer).setInt32(0, value, true);
      return this.raw(chunk);
    }
    /**
     * Write a `sint32` value, a signed, zigzag-encoded 32-bit varint.
     */
    sint32(value) {
      assertInt32(value);
      value = (value << 1 ^ value >> 31) >>> 0;
      varint32write(value, this.buf);
      return this;
    }
    /**
     * Write a `fixed64` value, a signed, fixed-length 64-bit integer.
     */
    sfixed64(value) {
      let chunk = new Uint8Array(8), view = new DataView(chunk.buffer), tc = protoInt64.enc(value);
      view.setInt32(0, tc.lo, true);
      view.setInt32(4, tc.hi, true);
      return this.raw(chunk);
    }
    /**
     * Write a `fixed64` value, an unsigned, fixed-length 64 bit integer.
     */
    fixed64(value) {
      let chunk = new Uint8Array(8), view = new DataView(chunk.buffer), tc = protoInt64.uEnc(value);
      view.setInt32(0, tc.lo, true);
      view.setInt32(4, tc.hi, true);
      return this.raw(chunk);
    }
    /**
     * Write a `int64` value, a signed 64-bit varint.
     */
    int64(value) {
      let tc = protoInt64.enc(value);
      varint64write(tc.lo, tc.hi, this.buf);
      return this;
    }
    /**
     * Write a `sint64` value, a signed, zig-zag-encoded 64-bit varint.
     */
    sint64(value) {
      let tc = protoInt64.enc(value), sign = tc.hi >> 31, lo = tc.lo << 1 ^ sign, hi = (tc.hi << 1 | tc.lo >>> 31) ^ sign;
      varint64write(lo, hi, this.buf);
      return this;
    }
    /**
     * Write a `uint64` value, an unsigned 64-bit varint.
     */
    uint64(value) {
      let tc = protoInt64.uEnc(value);
      varint64write(tc.lo, tc.hi, this.buf);
      return this;
    }
  };
  var BinaryReader = class {
    constructor(buf, textDecoder) {
      this.varint64 = varint64read;
      this.uint32 = varint32read;
      this.buf = buf;
      this.len = buf.length;
      this.pos = 0;
      this.view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
      this.textDecoder = textDecoder !== null && textDecoder !== void 0 ? textDecoder : new TextDecoder();
    }
    /**
     * Reads a tag - field number and wire type.
     */
    tag() {
      let tag = this.uint32(), fieldNo = tag >>> 3, wireType = tag & 7;
      if (fieldNo <= 0 || wireType < 0 || wireType > 5)
        throw new Error("illegal tag: field no " + fieldNo + " wire type " + wireType);
      return [fieldNo, wireType];
    }
    /**
     * Skip one element and return the skipped data.
     *
     * When skipping StartGroup, provide the tags field number to check for
     * matching field number in the EndGroup tag.
     */
    skip(wireType, fieldNo) {
      let start = this.pos;
      switch (wireType) {
        case WireType.Varint:
          while (this.buf[this.pos++] & 128) {
          }
          break;
        // eslint-disable-next-line
        // @ts-ignore TS7029: Fallthrough case in switch
        case WireType.Bit64:
          this.pos += 4;
        // eslint-disable-next-line
        // @ts-ignore TS7029: Fallthrough case in switch
        case WireType.Bit32:
          this.pos += 4;
          break;
        case WireType.LengthDelimited:
          let len = this.uint32();
          this.pos += len;
          break;
        case WireType.StartGroup:
          for (; ; ) {
            const [fn, wt] = this.tag();
            if (wt === WireType.EndGroup) {
              if (fieldNo !== void 0 && fn !== fieldNo) {
                throw new Error("invalid end group tag");
              }
              break;
            }
            this.skip(wt, fn);
          }
          break;
        default:
          throw new Error("cant skip wire type " + wireType);
      }
      this.assertBounds();
      return this.buf.subarray(start, this.pos);
    }
    /**
     * Throws error if position in byte array is out of range.
     */
    assertBounds() {
      if (this.pos > this.len)
        throw new RangeError("premature EOF");
    }
    /**
     * Read a `int32` field, a signed 32 bit varint.
     */
    int32() {
      return this.uint32() | 0;
    }
    /**
     * Read a `sint32` field, a signed, zigzag-encoded 32-bit varint.
     */
    sint32() {
      let zze = this.uint32();
      return zze >>> 1 ^ -(zze & 1);
    }
    /**
     * Read a `int64` field, a signed 64-bit varint.
     */
    int64() {
      return protoInt64.dec(...this.varint64());
    }
    /**
     * Read a `uint64` field, an unsigned 64-bit varint.
     */
    uint64() {
      return protoInt64.uDec(...this.varint64());
    }
    /**
     * Read a `sint64` field, a signed, zig-zag-encoded 64-bit varint.
     */
    sint64() {
      let [lo, hi] = this.varint64();
      let s = -(lo & 1);
      lo = (lo >>> 1 | (hi & 1) << 31) ^ s;
      hi = hi >>> 1 ^ s;
      return protoInt64.dec(lo, hi);
    }
    /**
     * Read a `bool` field, a variant.
     */
    bool() {
      let [lo, hi] = this.varint64();
      return lo !== 0 || hi !== 0;
    }
    /**
     * Read a `fixed32` field, an unsigned, fixed-length 32-bit integer.
     */
    fixed32() {
      return this.view.getUint32((this.pos += 4) - 4, true);
    }
    /**
     * Read a `sfixed32` field, a signed, fixed-length 32-bit integer.
     */
    sfixed32() {
      return this.view.getInt32((this.pos += 4) - 4, true);
    }
    /**
     * Read a `fixed64` field, an unsigned, fixed-length 64 bit integer.
     */
    fixed64() {
      return protoInt64.uDec(this.sfixed32(), this.sfixed32());
    }
    /**
     * Read a `fixed64` field, a signed, fixed-length 64-bit integer.
     */
    sfixed64() {
      return protoInt64.dec(this.sfixed32(), this.sfixed32());
    }
    /**
     * Read a `float` field, 32-bit floating point number.
     */
    float() {
      return this.view.getFloat32((this.pos += 4) - 4, true);
    }
    /**
     * Read a `double` field, a 64-bit floating point number.
     */
    double() {
      return this.view.getFloat64((this.pos += 8) - 8, true);
    }
    /**
     * Read a `bytes` field, length-delimited arbitrary data.
     */
    bytes() {
      let len = this.uint32(), start = this.pos;
      this.pos += len;
      this.assertBounds();
      return this.buf.subarray(start, start + len);
    }
    /**
     * Read a `string` field, length-delimited data converted to UTF-8 text.
     */
    string() {
      return this.textDecoder.decode(this.bytes());
    }
  };

  // ../../node_modules/@bufbuild/protobuf/dist/esm/private/extensions.js
  function makeExtension(runtime, typeName, extendee, field) {
    let fi;
    return {
      typeName,
      extendee,
      get field() {
        if (!fi) {
          const i = typeof field == "function" ? field() : field;
          i.name = typeName.split(".").pop();
          i.jsonName = `[${typeName}]`;
          fi = runtime.util.newFieldList([i]).list()[0];
        }
        return fi;
      },
      runtime
    };
  }
  function createExtensionContainer(extension) {
    const localName = extension.field.localName;
    const container = /* @__PURE__ */ Object.create(null);
    container[localName] = initExtensionField(extension);
    return [container, () => container[localName]];
  }
  function initExtensionField(ext) {
    const field = ext.field;
    if (field.repeated) {
      return [];
    }
    if (field.default !== void 0) {
      return field.default;
    }
    switch (field.kind) {
      case "enum":
        return field.T.values[0].no;
      case "scalar":
        return scalarZeroValue(field.T, field.L);
      case "message":
        const T = field.T, value = new T();
        return T.fieldWrapper ? T.fieldWrapper.unwrapField(value) : value;
      case "map":
        throw "map fields are not allowed to be extensions";
    }
  }
  function filterUnknownFields(unknownFields, field) {
    if (!field.repeated && (field.kind == "enum" || field.kind == "scalar")) {
      for (let i = unknownFields.length - 1; i >= 0; --i) {
        if (unknownFields[i].no == field.no) {
          return [unknownFields[i]];
        }
      }
      return [];
    }
    return unknownFields.filter((uf) => uf.no === field.no);
  }

  // ../../node_modules/@bufbuild/protobuf/dist/esm/proto-base64.js
  var encTable = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
  var decTable = [];
  for (let i = 0; i < encTable.length; i++)
    decTable[encTable[i].charCodeAt(0)] = i;
  decTable["-".charCodeAt(0)] = encTable.indexOf("+");
  decTable["_".charCodeAt(0)] = encTable.indexOf("/");
  var protoBase64 = {
    /**
     * Decodes a base64 string to a byte array.
     *
     * - ignores white-space, including line breaks and tabs
     * - allows inner padding (can decode concatenated base64 strings)
     * - does not require padding
     * - understands base64url encoding:
     *   "-" instead of "+",
     *   "_" instead of "/",
     *   no padding
     */
    dec(base64Str) {
      let es = base64Str.length * 3 / 4;
      if (base64Str[base64Str.length - 2] == "=")
        es -= 2;
      else if (base64Str[base64Str.length - 1] == "=")
        es -= 1;
      let bytes = new Uint8Array(es), bytePos = 0, groupPos = 0, b, p = 0;
      for (let i = 0; i < base64Str.length; i++) {
        b = decTable[base64Str.charCodeAt(i)];
        if (b === void 0) {
          switch (base64Str[i]) {
            // @ts-ignore TS7029: Fallthrough case in switch
            case "=":
              groupPos = 0;
            // reset state when padding found
            // @ts-ignore TS7029: Fallthrough case in switch
            case "\n":
            case "\r":
            case "	":
            case " ":
              continue;
            // skip white-space, and padding
            default:
              throw Error("invalid base64 string.");
          }
        }
        switch (groupPos) {
          case 0:
            p = b;
            groupPos = 1;
            break;
          case 1:
            bytes[bytePos++] = p << 2 | (b & 48) >> 4;
            p = b;
            groupPos = 2;
            break;
          case 2:
            bytes[bytePos++] = (p & 15) << 4 | (b & 60) >> 2;
            p = b;
            groupPos = 3;
            break;
          case 3:
            bytes[bytePos++] = (p & 3) << 6 | b;
            groupPos = 0;
            break;
        }
      }
      if (groupPos == 1)
        throw Error("invalid base64 string.");
      return bytes.subarray(0, bytePos);
    },
    /**
     * Encode a byte array to a base64 string.
     */
    enc(bytes) {
      let base64 = "", groupPos = 0, b, p = 0;
      for (let i = 0; i < bytes.length; i++) {
        b = bytes[i];
        switch (groupPos) {
          case 0:
            base64 += encTable[b >> 2];
            p = (b & 3) << 4;
            groupPos = 1;
            break;
          case 1:
            base64 += encTable[p | b >> 4];
            p = (b & 15) << 2;
            groupPos = 2;
            break;
          case 2:
            base64 += encTable[p | b >> 6];
            base64 += encTable[b & 63];
            groupPos = 0;
            break;
        }
      }
      if (groupPos) {
        base64 += encTable[p];
        base64 += "=";
        if (groupPos == 1)
          base64 += "=";
      }
      return base64;
    }
  };

  // ../../node_modules/@bufbuild/protobuf/dist/esm/extension-accessor.js
  function getExtension(message, extension, options) {
    assertExtendee(extension, message);
    const opt = extension.runtime.bin.makeReadOptions(options);
    const ufs = filterUnknownFields(message.getType().runtime.bin.listUnknownFields(message), extension.field);
    const [container, get] = createExtensionContainer(extension);
    for (const uf of ufs) {
      extension.runtime.bin.readField(container, opt.readerFactory(uf.data), extension.field, uf.wireType, opt);
    }
    return get();
  }
  function setExtension(message, extension, value, options) {
    assertExtendee(extension, message);
    const readOpt = extension.runtime.bin.makeReadOptions(options);
    const writeOpt = extension.runtime.bin.makeWriteOptions(options);
    if (hasExtension(message, extension)) {
      const ufs = message.getType().runtime.bin.listUnknownFields(message).filter((uf) => uf.no != extension.field.no);
      message.getType().runtime.bin.discardUnknownFields(message);
      for (const uf of ufs) {
        message.getType().runtime.bin.onUnknownField(message, uf.no, uf.wireType, uf.data);
      }
    }
    const writer = writeOpt.writerFactory();
    let f = extension.field;
    if (!f.opt && !f.repeated && (f.kind == "enum" || f.kind == "scalar")) {
      f = Object.assign(Object.assign({}, extension.field), { opt: true });
    }
    extension.runtime.bin.writeField(f, value, writer, writeOpt);
    const reader = readOpt.readerFactory(writer.finish());
    while (reader.pos < reader.len) {
      const [no, wireType] = reader.tag();
      const data = reader.skip(wireType, no);
      message.getType().runtime.bin.onUnknownField(message, no, wireType, data);
    }
  }
  function hasExtension(message, extension) {
    const messageType = message.getType();
    return extension.extendee.typeName === messageType.typeName && !!messageType.runtime.bin.listUnknownFields(message).find((uf) => uf.no == extension.field.no);
  }
  function assertExtendee(extension, message) {
    assert(extension.extendee.typeName == message.getType().typeName, `extension ${extension.typeName} can only be applied to message ${extension.extendee.typeName}`);
  }

  // ../../node_modules/@bufbuild/protobuf/dist/esm/private/reflect.js
  function isFieldSet(field, target) {
    const localName = field.localName;
    if (field.repeated) {
      return target[localName].length > 0;
    }
    if (field.oneof) {
      return target[field.oneof.localName].case === localName;
    }
    switch (field.kind) {
      case "enum":
      case "scalar":
        if (field.opt || field.req) {
          return target[localName] !== void 0;
        }
        if (field.kind == "enum") {
          return target[localName] !== field.T.values[0].no;
        }
        return !isScalarZeroValue(field.T, target[localName]);
      case "message":
        return target[localName] !== void 0;
      case "map":
        return Object.keys(target[localName]).length > 0;
    }
  }
  function clearField(field, target) {
    const localName = field.localName;
    const implicitPresence = !field.opt && !field.req;
    if (field.repeated) {
      target[localName] = [];
    } else if (field.oneof) {
      target[field.oneof.localName] = { case: void 0 };
    } else {
      switch (field.kind) {
        case "map":
          target[localName] = {};
          break;
        case "enum":
          target[localName] = implicitPresence ? field.T.values[0].no : void 0;
          break;
        case "scalar":
          target[localName] = implicitPresence ? scalarZeroValue(field.T, field.L) : void 0;
          break;
        case "message":
          target[localName] = void 0;
          break;
      }
    }
  }

  // ../../node_modules/@bufbuild/protobuf/dist/esm/is-message.js
  function isMessage(arg, type) {
    if (arg === null || typeof arg != "object") {
      return false;
    }
    if (!Object.getOwnPropertyNames(Message.prototype).every((m) => m in arg && typeof arg[m] == "function")) {
      return false;
    }
    const actualType = arg.getType();
    if (actualType === null || typeof actualType != "function" || !("typeName" in actualType) || typeof actualType.typeName != "string") {
      return false;
    }
    return type === void 0 ? true : actualType.typeName == type.typeName;
  }

  // ../../node_modules/@bufbuild/protobuf/dist/esm/private/field-wrapper.js
  function wrapField(type, value) {
    if (isMessage(value) || !type.fieldWrapper) {
      return value;
    }
    return type.fieldWrapper.wrapField(value);
  }
  ({
    "google.protobuf.DoubleValue": ScalarType.DOUBLE,
    "google.protobuf.FloatValue": ScalarType.FLOAT,
    "google.protobuf.Int64Value": ScalarType.INT64,
    "google.protobuf.UInt64Value": ScalarType.UINT64,
    "google.protobuf.Int32Value": ScalarType.INT32,
    "google.protobuf.UInt32Value": ScalarType.UINT32,
    "google.protobuf.BoolValue": ScalarType.BOOL,
    "google.protobuf.StringValue": ScalarType.STRING,
    "google.protobuf.BytesValue": ScalarType.BYTES
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/private/json-format.js
  var jsonReadDefaults = {
    ignoreUnknownFields: false
  };
  var jsonWriteDefaults = {
    emitDefaultValues: false,
    enumAsInteger: false,
    useProtoFieldName: false,
    prettySpaces: 0
  };
  function makeReadOptions(options) {
    return options ? Object.assign(Object.assign({}, jsonReadDefaults), options) : jsonReadDefaults;
  }
  function makeWriteOptions(options) {
    return options ? Object.assign(Object.assign({}, jsonWriteDefaults), options) : jsonWriteDefaults;
  }
  var tokenNull = Symbol();
  var tokenIgnoredUnknownEnum = Symbol();
  function makeJsonFormat() {
    return {
      makeReadOptions,
      makeWriteOptions,
      readMessage(type, json, options, message) {
        if (json == null || Array.isArray(json) || typeof json != "object") {
          throw new Error(`cannot decode message ${type.typeName} from JSON: ${debugJsonValue(json)}`);
        }
        message = message !== null && message !== void 0 ? message : new type();
        const oneofSeen = /* @__PURE__ */ new Map();
        const registry = options.typeRegistry;
        for (const [jsonKey, jsonValue] of Object.entries(json)) {
          const field = type.fields.findJsonName(jsonKey);
          if (field) {
            if (field.oneof) {
              if (jsonValue === null && field.kind == "scalar") {
                continue;
              }
              const seen = oneofSeen.get(field.oneof);
              if (seen !== void 0) {
                throw new Error(`cannot decode message ${type.typeName} from JSON: multiple keys for oneof "${field.oneof.name}" present: "${seen}", "${jsonKey}"`);
              }
              oneofSeen.set(field.oneof, jsonKey);
            }
            readField(message, jsonValue, field, options, type);
          } else {
            let found = false;
            if ((registry === null || registry === void 0 ? void 0 : registry.findExtension) && jsonKey.startsWith("[") && jsonKey.endsWith("]")) {
              const ext = registry.findExtension(jsonKey.substring(1, jsonKey.length - 1));
              if (ext && ext.extendee.typeName == type.typeName) {
                found = true;
                const [container, get] = createExtensionContainer(ext);
                readField(container, jsonValue, ext.field, options, ext);
                setExtension(message, ext, get(), options);
              }
            }
            if (!found && !options.ignoreUnknownFields) {
              throw new Error(`cannot decode message ${type.typeName} from JSON: key "${jsonKey}" is unknown`);
            }
          }
        }
        return message;
      },
      writeMessage(message, options) {
        const type = message.getType();
        const json = {};
        let field;
        try {
          for (field of type.fields.byNumber()) {
            if (!isFieldSet(field, message)) {
              if (field.req) {
                throw `required field not set`;
              }
              if (!options.emitDefaultValues) {
                continue;
              }
              if (!canEmitFieldDefaultValue(field)) {
                continue;
              }
            }
            const value = field.oneof ? message[field.oneof.localName].value : message[field.localName];
            const jsonValue = writeField(field, value, options);
            if (jsonValue !== void 0) {
              json[options.useProtoFieldName ? field.name : field.jsonName] = jsonValue;
            }
          }
          const registry = options.typeRegistry;
          if (registry === null || registry === void 0 ? void 0 : registry.findExtensionFor) {
            for (const uf of type.runtime.bin.listUnknownFields(message)) {
              const ext = registry.findExtensionFor(type.typeName, uf.no);
              if (ext && hasExtension(message, ext)) {
                const value = getExtension(message, ext, options);
                const jsonValue = writeField(ext.field, value, options);
                if (jsonValue !== void 0) {
                  json[ext.field.jsonName] = jsonValue;
                }
              }
            }
          }
        } catch (e) {
          const m = field ? `cannot encode field ${type.typeName}.${field.name} to JSON` : `cannot encode message ${type.typeName} to JSON`;
          const r = e instanceof Error ? e.message : String(e);
          throw new Error(m + (r.length > 0 ? `: ${r}` : ""));
        }
        return json;
      },
      readScalar(type, json, longType) {
        return readScalar(type, json, longType !== null && longType !== void 0 ? longType : LongType.BIGINT, true);
      },
      writeScalar(type, value, emitDefaultValues) {
        if (value === void 0) {
          return void 0;
        }
        if (emitDefaultValues || isScalarZeroValue(type, value)) {
          return writeScalar(type, value);
        }
        return void 0;
      },
      debug: debugJsonValue
    };
  }
  function debugJsonValue(json) {
    if (json === null) {
      return "null";
    }
    switch (typeof json) {
      case "object":
        return Array.isArray(json) ? "array" : "object";
      case "string":
        return json.length > 100 ? "string" : `"${json.split('"').join('\\"')}"`;
      default:
        return String(json);
    }
  }
  function readField(target, jsonValue, field, options, parentType) {
    let localName = field.localName;
    if (field.repeated) {
      assert(field.kind != "map");
      if (jsonValue === null) {
        return;
      }
      if (!Array.isArray(jsonValue)) {
        throw new Error(`cannot decode field ${parentType.typeName}.${field.name} from JSON: ${debugJsonValue(jsonValue)}`);
      }
      const targetArray = target[localName];
      for (const jsonItem of jsonValue) {
        if (jsonItem === null) {
          throw new Error(`cannot decode field ${parentType.typeName}.${field.name} from JSON: ${debugJsonValue(jsonItem)}`);
        }
        switch (field.kind) {
          case "message":
            targetArray.push(field.T.fromJson(jsonItem, options));
            break;
          case "enum":
            const enumValue = readEnum(field.T, jsonItem, options.ignoreUnknownFields, true);
            if (enumValue !== tokenIgnoredUnknownEnum) {
              targetArray.push(enumValue);
            }
            break;
          case "scalar":
            try {
              targetArray.push(readScalar(field.T, jsonItem, field.L, true));
            } catch (e) {
              let m = `cannot decode field ${parentType.typeName}.${field.name} from JSON: ${debugJsonValue(jsonItem)}`;
              if (e instanceof Error && e.message.length > 0) {
                m += `: ${e.message}`;
              }
              throw new Error(m);
            }
            break;
        }
      }
    } else if (field.kind == "map") {
      if (jsonValue === null) {
        return;
      }
      if (typeof jsonValue != "object" || Array.isArray(jsonValue)) {
        throw new Error(`cannot decode field ${parentType.typeName}.${field.name} from JSON: ${debugJsonValue(jsonValue)}`);
      }
      const targetMap = target[localName];
      for (const [jsonMapKey, jsonMapValue] of Object.entries(jsonValue)) {
        if (jsonMapValue === null) {
          throw new Error(`cannot decode field ${parentType.typeName}.${field.name} from JSON: map value null`);
        }
        let key;
        try {
          key = readMapKey(field.K, jsonMapKey);
        } catch (e) {
          let m = `cannot decode map key for field ${parentType.typeName}.${field.name} from JSON: ${debugJsonValue(jsonValue)}`;
          if (e instanceof Error && e.message.length > 0) {
            m += `: ${e.message}`;
          }
          throw new Error(m);
        }
        switch (field.V.kind) {
          case "message":
            targetMap[key] = field.V.T.fromJson(jsonMapValue, options);
            break;
          case "enum":
            const enumValue = readEnum(field.V.T, jsonMapValue, options.ignoreUnknownFields, true);
            if (enumValue !== tokenIgnoredUnknownEnum) {
              targetMap[key] = enumValue;
            }
            break;
          case "scalar":
            try {
              targetMap[key] = readScalar(field.V.T, jsonMapValue, LongType.BIGINT, true);
            } catch (e) {
              let m = `cannot decode map value for field ${parentType.typeName}.${field.name} from JSON: ${debugJsonValue(jsonValue)}`;
              if (e instanceof Error && e.message.length > 0) {
                m += `: ${e.message}`;
              }
              throw new Error(m);
            }
            break;
        }
      }
    } else {
      if (field.oneof) {
        target = target[field.oneof.localName] = { case: localName };
        localName = "value";
      }
      switch (field.kind) {
        case "message":
          const messageType = field.T;
          if (jsonValue === null && messageType.typeName != "google.protobuf.Value") {
            return;
          }
          let currentValue = target[localName];
          if (isMessage(currentValue)) {
            currentValue.fromJson(jsonValue, options);
          } else {
            target[localName] = currentValue = messageType.fromJson(jsonValue, options);
            if (messageType.fieldWrapper && !field.oneof) {
              target[localName] = messageType.fieldWrapper.unwrapField(currentValue);
            }
          }
          break;
        case "enum":
          const enumValue = readEnum(field.T, jsonValue, options.ignoreUnknownFields, false);
          switch (enumValue) {
            case tokenNull:
              clearField(field, target);
              break;
            case tokenIgnoredUnknownEnum:
              break;
            default:
              target[localName] = enumValue;
              break;
          }
          break;
        case "scalar":
          try {
            const scalarValue = readScalar(field.T, jsonValue, field.L, false);
            switch (scalarValue) {
              case tokenNull:
                clearField(field, target);
                break;
              default:
                target[localName] = scalarValue;
                break;
            }
          } catch (e) {
            let m = `cannot decode field ${parentType.typeName}.${field.name} from JSON: ${debugJsonValue(jsonValue)}`;
            if (e instanceof Error && e.message.length > 0) {
              m += `: ${e.message}`;
            }
            throw new Error(m);
          }
          break;
      }
    }
  }
  function readMapKey(type, json) {
    if (type === ScalarType.BOOL) {
      switch (json) {
        case "true":
          json = true;
          break;
        case "false":
          json = false;
          break;
      }
    }
    return readScalar(type, json, LongType.BIGINT, true).toString();
  }
  function readScalar(type, json, longType, nullAsZeroValue) {
    if (json === null) {
      if (nullAsZeroValue) {
        return scalarZeroValue(type, longType);
      }
      return tokenNull;
    }
    switch (type) {
      // float, double: JSON value will be a number or one of the special string values "NaN", "Infinity", and "-Infinity".
      // Either numbers or strings are accepted. Exponent notation is also accepted.
      case ScalarType.DOUBLE:
      case ScalarType.FLOAT:
        if (json === "NaN")
          return Number.NaN;
        if (json === "Infinity")
          return Number.POSITIVE_INFINITY;
        if (json === "-Infinity")
          return Number.NEGATIVE_INFINITY;
        if (json === "") {
          break;
        }
        if (typeof json == "string" && json.trim().length !== json.length) {
          break;
        }
        if (typeof json != "string" && typeof json != "number") {
          break;
        }
        const float = Number(json);
        if (Number.isNaN(float)) {
          break;
        }
        if (!Number.isFinite(float)) {
          break;
        }
        if (type == ScalarType.FLOAT)
          assertFloat32(float);
        return float;
      // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.
      case ScalarType.INT32:
      case ScalarType.FIXED32:
      case ScalarType.SFIXED32:
      case ScalarType.SINT32:
      case ScalarType.UINT32:
        let int32;
        if (typeof json == "number")
          int32 = json;
        else if (typeof json == "string" && json.length > 0) {
          if (json.trim().length === json.length)
            int32 = Number(json);
        }
        if (int32 === void 0)
          break;
        if (type == ScalarType.UINT32 || type == ScalarType.FIXED32)
          assertUInt32(int32);
        else
          assertInt32(int32);
        return int32;
      // int64, fixed64, uint64: JSON value will be a decimal string. Either numbers or strings are accepted.
      case ScalarType.INT64:
      case ScalarType.SFIXED64:
      case ScalarType.SINT64:
        if (typeof json != "number" && typeof json != "string")
          break;
        const long = protoInt64.parse(json);
        return longType ? long.toString() : long;
      case ScalarType.FIXED64:
      case ScalarType.UINT64:
        if (typeof json != "number" && typeof json != "string")
          break;
        const uLong = protoInt64.uParse(json);
        return longType ? uLong.toString() : uLong;
      // bool:
      case ScalarType.BOOL:
        if (typeof json !== "boolean")
          break;
        return json;
      // string:
      case ScalarType.STRING:
        if (typeof json !== "string") {
          break;
        }
        try {
          encodeURIComponent(json);
        } catch (e) {
          throw new Error("invalid UTF8");
        }
        return json;
      // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.
      // Either standard or URL-safe base64 encoding with/without paddings are accepted.
      case ScalarType.BYTES:
        if (json === "")
          return new Uint8Array(0);
        if (typeof json !== "string")
          break;
        return protoBase64.dec(json);
    }
    throw new Error();
  }
  function readEnum(type, json, ignoreUnknownFields, nullAsZeroValue) {
    if (json === null) {
      if (type.typeName == "google.protobuf.NullValue") {
        return 0;
      }
      return nullAsZeroValue ? type.values[0].no : tokenNull;
    }
    switch (typeof json) {
      case "number":
        if (Number.isInteger(json)) {
          return json;
        }
        break;
      case "string":
        const value = type.findName(json);
        if (value !== void 0) {
          return value.no;
        }
        if (ignoreUnknownFields) {
          return tokenIgnoredUnknownEnum;
        }
        break;
    }
    throw new Error(`cannot decode enum ${type.typeName} from JSON: ${debugJsonValue(json)}`);
  }
  function canEmitFieldDefaultValue(field) {
    if (field.repeated || field.kind == "map") {
      return true;
    }
    if (field.oneof) {
      return false;
    }
    if (field.kind == "message") {
      return false;
    }
    if (field.opt || field.req) {
      return false;
    }
    return true;
  }
  function writeField(field, value, options) {
    if (field.kind == "map") {
      assert(typeof value == "object" && value != null);
      const jsonObj = {};
      const entries = Object.entries(value);
      switch (field.V.kind) {
        case "scalar":
          for (const [entryKey, entryValue] of entries) {
            jsonObj[entryKey.toString()] = writeScalar(field.V.T, entryValue);
          }
          break;
        case "message":
          for (const [entryKey, entryValue] of entries) {
            jsonObj[entryKey.toString()] = entryValue.toJson(options);
          }
          break;
        case "enum":
          const enumType2 = field.V.T;
          for (const [entryKey, entryValue] of entries) {
            jsonObj[entryKey.toString()] = writeEnum(enumType2, entryValue, options.enumAsInteger);
          }
          break;
      }
      return options.emitDefaultValues || entries.length > 0 ? jsonObj : void 0;
    }
    if (field.repeated) {
      assert(Array.isArray(value));
      const jsonArr = [];
      switch (field.kind) {
        case "scalar":
          for (let i = 0; i < value.length; i++) {
            jsonArr.push(writeScalar(field.T, value[i]));
          }
          break;
        case "enum":
          for (let i = 0; i < value.length; i++) {
            jsonArr.push(writeEnum(field.T, value[i], options.enumAsInteger));
          }
          break;
        case "message":
          for (let i = 0; i < value.length; i++) {
            jsonArr.push(value[i].toJson(options));
          }
          break;
      }
      return options.emitDefaultValues || jsonArr.length > 0 ? jsonArr : void 0;
    }
    switch (field.kind) {
      case "scalar":
        return writeScalar(field.T, value);
      case "enum":
        return writeEnum(field.T, value, options.enumAsInteger);
      case "message":
        return wrapField(field.T, value).toJson(options);
    }
  }
  function writeEnum(type, value, enumAsInteger) {
    var _a;
    assert(typeof value == "number");
    if (type.typeName == "google.protobuf.NullValue") {
      return null;
    }
    if (enumAsInteger) {
      return value;
    }
    const val = type.findNumber(value);
    return (_a = val === null || val === void 0 ? void 0 : val.name) !== null && _a !== void 0 ? _a : value;
  }
  function writeScalar(type, value) {
    switch (type) {
      // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.
      case ScalarType.INT32:
      case ScalarType.SFIXED32:
      case ScalarType.SINT32:
      case ScalarType.FIXED32:
      case ScalarType.UINT32:
        assert(typeof value == "number");
        return value;
      // float, double: JSON value will be a number or one of the special string values "NaN", "Infinity", and "-Infinity".
      // Either numbers or strings are accepted. Exponent notation is also accepted.
      case ScalarType.FLOAT:
      // assertFloat32(value);
      case ScalarType.DOUBLE:
        assert(typeof value == "number");
        if (Number.isNaN(value))
          return "NaN";
        if (value === Number.POSITIVE_INFINITY)
          return "Infinity";
        if (value === Number.NEGATIVE_INFINITY)
          return "-Infinity";
        return value;
      // string:
      case ScalarType.STRING:
        assert(typeof value == "string");
        return value;
      // bool:
      case ScalarType.BOOL:
        assert(typeof value == "boolean");
        return value;
      // JSON value will be a decimal string. Either numbers or strings are accepted.
      case ScalarType.UINT64:
      case ScalarType.FIXED64:
      case ScalarType.INT64:
      case ScalarType.SFIXED64:
      case ScalarType.SINT64:
        assert(typeof value == "bigint" || typeof value == "string" || typeof value == "number");
        return value.toString();
      // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.
      // Either standard or URL-safe base64 encoding with/without paddings are accepted.
      case ScalarType.BYTES:
        assert(value instanceof Uint8Array);
        return protoBase64.enc(value);
    }
  }

  // ../../node_modules/@bufbuild/protobuf/dist/esm/private/binary-format.js
  var unknownFieldsSymbol = Symbol("@bufbuild/protobuf/unknown-fields");
  var readDefaults = {
    readUnknownFields: true,
    readerFactory: (bytes) => new BinaryReader(bytes)
  };
  var writeDefaults = {
    writeUnknownFields: true,
    writerFactory: () => new BinaryWriter()
  };
  function makeReadOptions2(options) {
    return options ? Object.assign(Object.assign({}, readDefaults), options) : readDefaults;
  }
  function makeWriteOptions2(options) {
    return options ? Object.assign(Object.assign({}, writeDefaults), options) : writeDefaults;
  }
  function makeBinaryFormat() {
    return {
      makeReadOptions: makeReadOptions2,
      makeWriteOptions: makeWriteOptions2,
      listUnknownFields(message) {
        var _a;
        return (_a = message[unknownFieldsSymbol]) !== null && _a !== void 0 ? _a : [];
      },
      discardUnknownFields(message) {
        delete message[unknownFieldsSymbol];
      },
      writeUnknownFields(message, writer) {
        const m = message;
        const c = m[unknownFieldsSymbol];
        if (c) {
          for (const f of c) {
            writer.tag(f.no, f.wireType).raw(f.data);
          }
        }
      },
      onUnknownField(message, no, wireType, data) {
        const m = message;
        if (!Array.isArray(m[unknownFieldsSymbol])) {
          m[unknownFieldsSymbol] = [];
        }
        m[unknownFieldsSymbol].push({ no, wireType, data });
      },
      readMessage(message, reader, lengthOrEndTagFieldNo, options, delimitedMessageEncoding) {
        const type = message.getType();
        const end = delimitedMessageEncoding ? reader.len : reader.pos + lengthOrEndTagFieldNo;
        let fieldNo, wireType;
        while (reader.pos < end) {
          [fieldNo, wireType] = reader.tag();
          if (delimitedMessageEncoding === true && wireType == WireType.EndGroup) {
            break;
          }
          const field = type.fields.find(fieldNo);
          if (!field) {
            const data = reader.skip(wireType, fieldNo);
            if (options.readUnknownFields) {
              this.onUnknownField(message, fieldNo, wireType, data);
            }
            continue;
          }
          readField2(message, reader, field, wireType, options);
        }
        if (delimitedMessageEncoding && // eslint-disable-line @typescript-eslint/strict-boolean-expressions
        (wireType != WireType.EndGroup || fieldNo !== lengthOrEndTagFieldNo)) {
          throw new Error(`invalid end group tag`);
        }
      },
      readField: readField2,
      writeMessage(message, writer, options) {
        const type = message.getType();
        for (const field of type.fields.byNumber()) {
          if (!isFieldSet(field, message)) {
            if (field.req) {
              throw new Error(`cannot encode field ${type.typeName}.${field.name} to binary: required field not set`);
            }
            continue;
          }
          const value = field.oneof ? message[field.oneof.localName].value : message[field.localName];
          writeField2(field, value, writer, options);
        }
        if (options.writeUnknownFields) {
          this.writeUnknownFields(message, writer);
        }
        return writer;
      },
      writeField(field, value, writer, options) {
        if (value === void 0) {
          return void 0;
        }
        writeField2(field, value, writer, options);
      }
    };
  }
  function readField2(target, reader, field, wireType, options) {
    let { repeated, localName } = field;
    if (field.oneof) {
      target = target[field.oneof.localName];
      if (target.case != localName) {
        delete target.value;
      }
      target.case = localName;
      localName = "value";
    }
    switch (field.kind) {
      case "scalar":
      case "enum":
        const scalarType = field.kind == "enum" ? ScalarType.INT32 : field.T;
        let read = readScalar2;
        if (field.kind == "scalar" && field.L > 0) {
          read = readScalarLTString;
        }
        if (repeated) {
          let arr = target[localName];
          const isPacked = wireType == WireType.LengthDelimited && scalarType != ScalarType.STRING && scalarType != ScalarType.BYTES;
          if (isPacked) {
            let e = reader.uint32() + reader.pos;
            while (reader.pos < e) {
              arr.push(read(reader, scalarType));
            }
          } else {
            arr.push(read(reader, scalarType));
          }
        } else {
          target[localName] = read(reader, scalarType);
        }
        break;
      case "message":
        const messageType = field.T;
        if (repeated) {
          target[localName].push(readMessageField(reader, new messageType(), options, field));
        } else {
          if (isMessage(target[localName])) {
            readMessageField(reader, target[localName], options, field);
          } else {
            target[localName] = readMessageField(reader, new messageType(), options, field);
            if (messageType.fieldWrapper && !field.oneof && !field.repeated) {
              target[localName] = messageType.fieldWrapper.unwrapField(target[localName]);
            }
          }
        }
        break;
      case "map":
        let [mapKey, mapVal] = readMapEntry(field, reader, options);
        target[localName][mapKey] = mapVal;
        break;
    }
  }
  function readMessageField(reader, message, options, field) {
    const format = message.getType().runtime.bin;
    const delimited = field === null || field === void 0 ? void 0 : field.delimited;
    format.readMessage(
      message,
      reader,
      delimited ? field.no : reader.uint32(),
      // eslint-disable-line @typescript-eslint/strict-boolean-expressions
      options,
      delimited
    );
    return message;
  }
  function readMapEntry(field, reader, options) {
    const length = reader.uint32(), end = reader.pos + length;
    let key, val;
    while (reader.pos < end) {
      const [fieldNo] = reader.tag();
      switch (fieldNo) {
        case 1:
          key = readScalar2(reader, field.K);
          break;
        case 2:
          switch (field.V.kind) {
            case "scalar":
              val = readScalar2(reader, field.V.T);
              break;
            case "enum":
              val = reader.int32();
              break;
            case "message":
              val = readMessageField(reader, new field.V.T(), options, void 0);
              break;
          }
          break;
      }
    }
    if (key === void 0) {
      key = scalarZeroValue(field.K, LongType.BIGINT);
    }
    if (typeof key != "string" && typeof key != "number") {
      key = key.toString();
    }
    if (val === void 0) {
      switch (field.V.kind) {
        case "scalar":
          val = scalarZeroValue(field.V.T, LongType.BIGINT);
          break;
        case "enum":
          val = field.V.T.values[0].no;
          break;
        case "message":
          val = new field.V.T();
          break;
      }
    }
    return [key, val];
  }
  function readScalarLTString(reader, type) {
    const v = readScalar2(reader, type);
    return typeof v == "bigint" ? v.toString() : v;
  }
  function readScalar2(reader, type) {
    switch (type) {
      case ScalarType.STRING:
        return reader.string();
      case ScalarType.BOOL:
        return reader.bool();
      case ScalarType.DOUBLE:
        return reader.double();
      case ScalarType.FLOAT:
        return reader.float();
      case ScalarType.INT32:
        return reader.int32();
      case ScalarType.INT64:
        return reader.int64();
      case ScalarType.UINT64:
        return reader.uint64();
      case ScalarType.FIXED64:
        return reader.fixed64();
      case ScalarType.BYTES:
        return reader.bytes();
      case ScalarType.FIXED32:
        return reader.fixed32();
      case ScalarType.SFIXED32:
        return reader.sfixed32();
      case ScalarType.SFIXED64:
        return reader.sfixed64();
      case ScalarType.SINT64:
        return reader.sint64();
      case ScalarType.UINT32:
        return reader.uint32();
      case ScalarType.SINT32:
        return reader.sint32();
    }
  }
  function writeField2(field, value, writer, options) {
    assert(value !== void 0);
    const repeated = field.repeated;
    switch (field.kind) {
      case "scalar":
      case "enum":
        let scalarType = field.kind == "enum" ? ScalarType.INT32 : field.T;
        if (repeated) {
          assert(Array.isArray(value));
          if (field.packed) {
            writePacked(writer, scalarType, field.no, value);
          } else {
            for (const item of value) {
              writeScalar2(writer, scalarType, field.no, item);
            }
          }
        } else {
          writeScalar2(writer, scalarType, field.no, value);
        }
        break;
      case "message":
        if (repeated) {
          assert(Array.isArray(value));
          for (const item of value) {
            writeMessageField(writer, options, field, item);
          }
        } else {
          writeMessageField(writer, options, field, value);
        }
        break;
      case "map":
        assert(typeof value == "object" && value != null);
        for (const [key, val] of Object.entries(value)) {
          writeMapEntry(writer, options, field, key, val);
        }
        break;
    }
  }
  function writeMapEntry(writer, options, field, key, value) {
    writer.tag(field.no, WireType.LengthDelimited);
    writer.fork();
    let keyValue = key;
    switch (field.K) {
      case ScalarType.INT32:
      case ScalarType.FIXED32:
      case ScalarType.UINT32:
      case ScalarType.SFIXED32:
      case ScalarType.SINT32:
        keyValue = Number.parseInt(key);
        break;
      case ScalarType.BOOL:
        assert(key == "true" || key == "false");
        keyValue = key == "true";
        break;
    }
    writeScalar2(writer, field.K, 1, keyValue);
    switch (field.V.kind) {
      case "scalar":
        writeScalar2(writer, field.V.T, 2, value);
        break;
      case "enum":
        writeScalar2(writer, ScalarType.INT32, 2, value);
        break;
      case "message":
        assert(value !== void 0);
        writer.tag(2, WireType.LengthDelimited).bytes(value.toBinary(options));
        break;
    }
    writer.join();
  }
  function writeMessageField(writer, options, field, value) {
    const message = wrapField(field.T, value);
    if (field.delimited)
      writer.tag(field.no, WireType.StartGroup).raw(message.toBinary(options)).tag(field.no, WireType.EndGroup);
    else
      writer.tag(field.no, WireType.LengthDelimited).bytes(message.toBinary(options));
  }
  function writeScalar2(writer, type, fieldNo, value) {
    assert(value !== void 0);
    let [wireType, method] = scalarTypeInfo(type);
    writer.tag(fieldNo, wireType)[method](value);
  }
  function writePacked(writer, type, fieldNo, value) {
    if (!value.length) {
      return;
    }
    writer.tag(fieldNo, WireType.LengthDelimited).fork();
    let [, method] = scalarTypeInfo(type);
    for (let i = 0; i < value.length; i++) {
      writer[method](value[i]);
    }
    writer.join();
  }
  function scalarTypeInfo(type) {
    let wireType = WireType.Varint;
    switch (type) {
      case ScalarType.BYTES:
      case ScalarType.STRING:
        wireType = WireType.LengthDelimited;
        break;
      case ScalarType.DOUBLE:
      case ScalarType.FIXED64:
      case ScalarType.SFIXED64:
        wireType = WireType.Bit64;
        break;
      case ScalarType.FIXED32:
      case ScalarType.SFIXED32:
      case ScalarType.FLOAT:
        wireType = WireType.Bit32;
        break;
    }
    const method = ScalarType[type].toLowerCase();
    return [wireType, method];
  }

  // ../../node_modules/@bufbuild/protobuf/dist/esm/private/util-common.js
  function makeUtilCommon() {
    return {
      setEnumType,
      initPartial(source, target) {
        if (source === void 0) {
          return;
        }
        const type = target.getType();
        for (const member of type.fields.byMember()) {
          const localName = member.localName, t = target, s = source;
          if (s[localName] == null) {
            continue;
          }
          switch (member.kind) {
            case "oneof":
              const sk = s[localName].case;
              if (sk === void 0) {
                continue;
              }
              const sourceField = member.findField(sk);
              let val = s[localName].value;
              if (sourceField && sourceField.kind == "message" && !isMessage(val, sourceField.T)) {
                val = new sourceField.T(val);
              } else if (sourceField && sourceField.kind === "scalar" && sourceField.T === ScalarType.BYTES) {
                val = toU8Arr(val);
              }
              t[localName] = { case: sk, value: val };
              break;
            case "scalar":
            case "enum":
              let copy = s[localName];
              if (member.T === ScalarType.BYTES) {
                copy = member.repeated ? copy.map(toU8Arr) : toU8Arr(copy);
              }
              t[localName] = copy;
              break;
            case "map":
              switch (member.V.kind) {
                case "scalar":
                case "enum":
                  if (member.V.T === ScalarType.BYTES) {
                    for (const [k, v] of Object.entries(s[localName])) {
                      t[localName][k] = toU8Arr(v);
                    }
                  } else {
                    Object.assign(t[localName], s[localName]);
                  }
                  break;
                case "message":
                  const messageType = member.V.T;
                  for (const k of Object.keys(s[localName])) {
                    let val2 = s[localName][k];
                    if (!messageType.fieldWrapper) {
                      val2 = new messageType(val2);
                    }
                    t[localName][k] = val2;
                  }
                  break;
              }
              break;
            case "message":
              const mt = member.T;
              if (member.repeated) {
                t[localName] = s[localName].map((val2) => isMessage(val2, mt) ? val2 : new mt(val2));
              } else {
                const val2 = s[localName];
                if (mt.fieldWrapper) {
                  if (
                    // We can't use BytesValue.typeName as that will create a circular import
                    mt.typeName === "google.protobuf.BytesValue"
                  ) {
                    t[localName] = toU8Arr(val2);
                  } else {
                    t[localName] = val2;
                  }
                } else {
                  t[localName] = isMessage(val2, mt) ? val2 : new mt(val2);
                }
              }
              break;
          }
        }
      },
      // TODO use isFieldSet() here to support future field presence
      equals(type, a, b) {
        if (a === b) {
          return true;
        }
        if (!a || !b) {
          return false;
        }
        return type.fields.byMember().every((m) => {
          const va = a[m.localName];
          const vb = b[m.localName];
          if (m.repeated) {
            if (va.length !== vb.length) {
              return false;
            }
            switch (m.kind) {
              case "message":
                return va.every((a2, i) => m.T.equals(a2, vb[i]));
              case "scalar":
                return va.every((a2, i) => scalarEquals(m.T, a2, vb[i]));
              case "enum":
                return va.every((a2, i) => scalarEquals(ScalarType.INT32, a2, vb[i]));
            }
            throw new Error(`repeated cannot contain ${m.kind}`);
          }
          switch (m.kind) {
            case "message":
              return m.T.equals(va, vb);
            case "enum":
              return scalarEquals(ScalarType.INT32, va, vb);
            case "scalar":
              return scalarEquals(m.T, va, vb);
            case "oneof":
              if (va.case !== vb.case) {
                return false;
              }
              const s = m.findField(va.case);
              if (s === void 0) {
                return true;
              }
              switch (s.kind) {
                case "message":
                  return s.T.equals(va.value, vb.value);
                case "enum":
                  return scalarEquals(ScalarType.INT32, va.value, vb.value);
                case "scalar":
                  return scalarEquals(s.T, va.value, vb.value);
              }
              throw new Error(`oneof cannot contain ${s.kind}`);
            case "map":
              const keys = Object.keys(va).concat(Object.keys(vb));
              switch (m.V.kind) {
                case "message":
                  const messageType = m.V.T;
                  return keys.every((k) => messageType.equals(va[k], vb[k]));
                case "enum":
                  return keys.every((k) => scalarEquals(ScalarType.INT32, va[k], vb[k]));
                case "scalar":
                  const scalarType = m.V.T;
                  return keys.every((k) => scalarEquals(scalarType, va[k], vb[k]));
              }
              break;
          }
        });
      },
      // TODO use isFieldSet() here to support future field presence
      clone(message) {
        const type = message.getType(), target = new type(), any = target;
        for (const member of type.fields.byMember()) {
          const source = message[member.localName];
          let copy;
          if (member.repeated) {
            copy = source.map(cloneSingularField);
          } else if (member.kind == "map") {
            copy = any[member.localName];
            for (const [key, v] of Object.entries(source)) {
              copy[key] = cloneSingularField(v);
            }
          } else if (member.kind == "oneof") {
            const f = member.findField(source.case);
            copy = f ? { case: source.case, value: cloneSingularField(source.value) } : { case: void 0 };
          } else {
            copy = cloneSingularField(source);
          }
          any[member.localName] = copy;
        }
        for (const uf of type.runtime.bin.listUnknownFields(message)) {
          type.runtime.bin.onUnknownField(any, uf.no, uf.wireType, uf.data);
        }
        return target;
      }
    };
  }
  function cloneSingularField(value) {
    if (value === void 0) {
      return value;
    }
    if (isMessage(value)) {
      return value.clone();
    }
    if (value instanceof Uint8Array) {
      const c = new Uint8Array(value.byteLength);
      c.set(value);
      return c;
    }
    return value;
  }
  function toU8Arr(input) {
    return input instanceof Uint8Array ? input : new Uint8Array(input);
  }

  // ../../node_modules/@bufbuild/protobuf/dist/esm/private/proto-runtime.js
  function makeProtoRuntime(syntax, newFieldList, initFields) {
    return {
      syntax,
      json: makeJsonFormat(),
      bin: makeBinaryFormat(),
      util: Object.assign(Object.assign({}, makeUtilCommon()), {
        newFieldList,
        initFields
      }),
      makeMessageType(typeName, fields, opt) {
        return makeMessageType(this, typeName, fields, opt);
      },
      makeEnum,
      makeEnumType,
      getEnumType,
      makeExtension(typeName, extendee, field) {
        return makeExtension(this, typeName, extendee, field);
      }
    };
  }

  // ../../node_modules/@bufbuild/protobuf/dist/esm/private/field-list.js
  var InternalFieldList = class {
    constructor(fields, normalizer) {
      this._fields = fields;
      this._normalizer = normalizer;
    }
    findJsonName(jsonName) {
      if (!this.jsonNames) {
        const t = {};
        for (const f of this.list()) {
          t[f.jsonName] = t[f.name] = f;
        }
        this.jsonNames = t;
      }
      return this.jsonNames[jsonName];
    }
    find(fieldNo) {
      if (!this.numbers) {
        const t = {};
        for (const f of this.list()) {
          t[f.no] = f;
        }
        this.numbers = t;
      }
      return this.numbers[fieldNo];
    }
    list() {
      if (!this.all) {
        this.all = this._normalizer(this._fields);
      }
      return this.all;
    }
    byNumber() {
      if (!this.numbersAsc) {
        this.numbersAsc = this.list().concat().sort((a, b) => a.no - b.no);
      }
      return this.numbersAsc;
    }
    byMember() {
      if (!this.members) {
        this.members = [];
        const a = this.members;
        let o;
        for (const f of this.list()) {
          if (f.oneof) {
            if (f.oneof !== o) {
              o = f.oneof;
              a.push(o);
            }
          } else {
            a.push(f);
          }
        }
      }
      return this.members;
    }
  };

  // ../../node_modules/@bufbuild/protobuf/dist/esm/private/names.js
  function localFieldName(protoName, inOneof) {
    const name = protoCamelCase(protoName);
    if (inOneof) {
      return name;
    }
    return safeObjectProperty(safeMessageProperty(name));
  }
  function localOneofName(protoName) {
    return localFieldName(protoName, false);
  }
  var fieldJsonName = protoCamelCase;
  function protoCamelCase(snakeCase) {
    let capNext = false;
    const b = [];
    for (let i = 0; i < snakeCase.length; i++) {
      let c = snakeCase.charAt(i);
      switch (c) {
        case "_":
          capNext = true;
          break;
        case "0":
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
          b.push(c);
          capNext = false;
          break;
        default:
          if (capNext) {
            capNext = false;
            c = c.toUpperCase();
          }
          b.push(c);
          break;
      }
    }
    return b.join("");
  }
  var reservedObjectProperties = /* @__PURE__ */ new Set([
    // names reserved by JavaScript
    "constructor",
    "toString",
    "toJSON",
    "valueOf"
  ]);
  var reservedMessageProperties = /* @__PURE__ */ new Set([
    // names reserved by the runtime
    "getType",
    "clone",
    "equals",
    "fromBinary",
    "fromJson",
    "fromJsonString",
    "toBinary",
    "toJson",
    "toJsonString",
    // names reserved by the runtime for the future
    "toObject"
  ]);
  var fallback = (name) => `${name}$`;
  var safeMessageProperty = (name) => {
    if (reservedMessageProperties.has(name)) {
      return fallback(name);
    }
    return name;
  };
  var safeObjectProperty = (name) => {
    if (reservedObjectProperties.has(name)) {
      return fallback(name);
    }
    return name;
  };

  // ../../node_modules/@bufbuild/protobuf/dist/esm/private/field.js
  var InternalOneofInfo = class {
    constructor(name) {
      this.kind = "oneof";
      this.repeated = false;
      this.packed = false;
      this.opt = false;
      this.req = false;
      this.default = void 0;
      this.fields = [];
      this.name = name;
      this.localName = localOneofName(name);
    }
    addField(field) {
      assert(field.oneof === this, `field ${field.name} not one of ${this.name}`);
      this.fields.push(field);
    }
    findField(localName) {
      if (!this._lookup) {
        this._lookup = /* @__PURE__ */ Object.create(null);
        for (let i = 0; i < this.fields.length; i++) {
          this._lookup[this.fields[i].localName] = this.fields[i];
        }
      }
      return this._lookup[localName];
    }
  };

  // ../../node_modules/@bufbuild/protobuf/dist/esm/private/field-normalize.js
  function normalizeFieldInfos(fieldInfos, packedByDefault) {
    var _a, _b, _c, _d, _e, _f;
    const r = [];
    let o;
    for (const field of typeof fieldInfos == "function" ? fieldInfos() : fieldInfos) {
      const f = field;
      f.localName = localFieldName(field.name, field.oneof !== void 0);
      f.jsonName = (_a = field.jsonName) !== null && _a !== void 0 ? _a : fieldJsonName(field.name);
      f.repeated = (_b = field.repeated) !== null && _b !== void 0 ? _b : false;
      if (field.kind == "scalar") {
        f.L = (_c = field.L) !== null && _c !== void 0 ? _c : LongType.BIGINT;
      }
      f.delimited = (_d = field.delimited) !== null && _d !== void 0 ? _d : false;
      f.req = (_e = field.req) !== null && _e !== void 0 ? _e : false;
      f.opt = (_f = field.opt) !== null && _f !== void 0 ? _f : false;
      if (field.packed === void 0) {
        if (packedByDefault) {
          f.packed = field.kind == "enum" || field.kind == "scalar" && field.T != ScalarType.BYTES && field.T != ScalarType.STRING;
        } else {
          f.packed = false;
        }
      }
      if (field.oneof !== void 0) {
        const ooname = typeof field.oneof == "string" ? field.oneof : field.oneof.name;
        if (!o || o.name != ooname) {
          o = new InternalOneofInfo(ooname);
        }
        f.oneof = o;
        o.addField(f);
      }
      r.push(f);
    }
    return r;
  }

  // ../../node_modules/@bufbuild/protobuf/dist/esm/proto3.js
  var proto3 = makeProtoRuntime(
    "proto3",
    (fields) => {
      return new InternalFieldList(fields, (source) => normalizeFieldInfos(source, true));
    },
    // TODO merge with proto2 and initExtensionField, also see initPartial, equals, clone
    (target) => {
      for (const member of target.getType().fields.byMember()) {
        if (member.opt) {
          continue;
        }
        const name = member.localName, t = target;
        if (member.repeated) {
          t[name] = [];
          continue;
        }
        switch (member.kind) {
          case "oneof":
            t[name] = { case: void 0 };
            break;
          case "enum":
            t[name] = 0;
            break;
          case "map":
            t[name] = {};
            break;
          case "scalar":
            t[name] = scalarZeroValue(member.T, member.L);
            break;
        }
      }
    }
  );

  // ../../node_modules/@bufbuild/protobuf/dist/esm/proto2.js
  var proto2 = makeProtoRuntime(
    "proto2",
    (fields) => {
      return new InternalFieldList(fields, (source) => normalizeFieldInfos(source, false));
    },
    // TODO merge with proto3 and initExtensionField, also see initPartial, equals, clone
    (target) => {
      for (const member of target.getType().fields.byMember()) {
        const name = member.localName, t = target;
        if (member.repeated) {
          t[name] = [];
          continue;
        }
        switch (member.kind) {
          case "oneof":
            t[name] = { case: void 0 };
            break;
          case "map":
            t[name] = {};
            break;
        }
      }
    }
  );

  // ../protoc/dist/rtc/sctp_capabilities_pb.js
  var ProtoNumSctpStreams = class _ProtoNumSctpStreams extends Message {
    /**
     * Initially requested number of outgoing SCTP streams
     *
     * @generated from field: int32 OS = 1;
     */
    OS = 0;
    /**
     * Maximum number of incoming SCTP streams
     *
     * @generated from field: int32 MIS = 2;
     */
    MIS = 0;
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "ProtoNumSctpStreams";
    static fields = proto3.util.newFieldList(() => [
      {
        no: 1,
        name: "OS",
        kind: "scalar",
        T: 5
        /* ScalarType.INT32 */
      },
      {
        no: 2,
        name: "MIS",
        kind: "scalar",
        T: 5
        /* ScalarType.INT32 */
      }
    ]);
    static fromBinary(bytes, options) {
      return new _ProtoNumSctpStreams().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _ProtoNumSctpStreams().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _ProtoNumSctpStreams().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto3.util.equals(_ProtoNumSctpStreams, a, b);
    }
  };
  var ProtoSctpCapabilities = class _ProtoSctpCapabilities extends Message {
    /**
     * @generated from field: ProtoNumSctpStreams numStreams = 1;
     */
    numStreams;
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "ProtoSctpCapabilities";
    static fields = proto3.util.newFieldList(() => [
      { no: 1, name: "numStreams", kind: "message", T: ProtoNumSctpStreams }
    ]);
    static fromBinary(bytes, options) {
      return new _ProtoSctpCapabilities().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _ProtoSctpCapabilities().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _ProtoSctpCapabilities().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto3.util.equals(_ProtoSctpCapabilities, a, b);
    }
  };

  // ../protoc/dist/rtc/sdp_info_pb.js
  var ProtoDtlsFingerPrints = class _ProtoDtlsFingerPrints extends Message {
    /**
     * @generated from field: string algorithm = 1;
     */
    algorithm = "";
    /**
     * @generated from field: string value = 2;
     */
    value = "";
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "ProtoDtlsFingerPrints";
    static fields = proto3.util.newFieldList(() => [
      {
        no: 1,
        name: "algorithm",
        kind: "scalar",
        T: 9
        /* ScalarType.STRING */
      },
      {
        no: 2,
        name: "value",
        kind: "scalar",
        T: 9
        /* ScalarType.STRING */
      }
    ]);
    static fromBinary(bytes, options) {
      return new _ProtoDtlsFingerPrints().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _ProtoDtlsFingerPrints().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _ProtoDtlsFingerPrints().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto3.util.equals(_ProtoDtlsFingerPrints, a, b);
    }
  };
  var ProtoIceParameters = class _ProtoIceParameters extends Message {
    /**
     * @generated from field: string usernameFragment = 1;
     */
    usernameFragment = "";
    /**
     * @generated from field: string password = 2;
     */
    password = "";
    /**
     * @generated from field: bool iceLite = 3;
     */
    iceLite = false;
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "ProtoIceParameters";
    static fields = proto3.util.newFieldList(() => [
      {
        no: 1,
        name: "usernameFragment",
        kind: "scalar",
        T: 9
        /* ScalarType.STRING */
      },
      {
        no: 2,
        name: "password",
        kind: "scalar",
        T: 9
        /* ScalarType.STRING */
      },
      {
        no: 3,
        name: "iceLite",
        kind: "scalar",
        T: 8
        /* ScalarType.BOOL */
      }
    ]);
    static fromBinary(bytes, options) {
      return new _ProtoIceParameters().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _ProtoIceParameters().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _ProtoIceParameters().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto3.util.equals(_ProtoIceParameters, a, b);
    }
  };
  var ProtoIceCandidates = class _ProtoIceCandidates extends Message {
    /**
     * @generated from field: string foundation = 1;
     */
    foundation = "";
    /**
     * @generated from field: int32 priority = 2;
     */
    priority = 0;
    /**
     * @generated from field: string ip = 3;
     */
    ip = "";
    /**
     * @generated from field: int32 port = 4;
     */
    port = 0;
    /**
     * @generated from field: string type = 5;
     */
    type = "";
    /**
     * @generated from field: string protocol = 6;
     */
    protocol = "";
    /**
     * @generated from field: string tcpType = 7;
     */
    tcpType = "";
    /**
     * @generated from field: string address = 8;
     */
    address = "";
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "ProtoIceCandidates";
    static fields = proto3.util.newFieldList(() => [
      {
        no: 1,
        name: "foundation",
        kind: "scalar",
        T: 9
        /* ScalarType.STRING */
      },
      {
        no: 2,
        name: "priority",
        kind: "scalar",
        T: 5
        /* ScalarType.INT32 */
      },
      {
        no: 3,
        name: "ip",
        kind: "scalar",
        T: 9
        /* ScalarType.STRING */
      },
      {
        no: 4,
        name: "port",
        kind: "scalar",
        T: 5
        /* ScalarType.INT32 */
      },
      {
        no: 5,
        name: "type",
        kind: "scalar",
        T: 9
        /* ScalarType.STRING */
      },
      {
        no: 6,
        name: "protocol",
        kind: "scalar",
        T: 9
        /* ScalarType.STRING */
      },
      {
        no: 7,
        name: "tcpType",
        kind: "scalar",
        T: 9
        /* ScalarType.STRING */
      },
      {
        no: 8,
        name: "address",
        kind: "scalar",
        T: 9
        /* ScalarType.STRING */
      }
    ]);
    static fromBinary(bytes, options) {
      return new _ProtoIceCandidates().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _ProtoIceCandidates().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _ProtoIceCandidates().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto3.util.equals(_ProtoIceCandidates, a, b);
    }
  };
  var ProtoDtlsParameters = class _ProtoDtlsParameters extends Message {
    /**
     * @generated from field: string role = 1;
     */
    role = "";
    /**
     * @generated from field: repeated ProtoDtlsFingerPrints fingerprints = 2;
     */
    fingerprints = [];
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "ProtoDtlsParameters";
    static fields = proto3.util.newFieldList(() => [
      {
        no: 1,
        name: "role",
        kind: "scalar",
        T: 9
        /* ScalarType.STRING */
      },
      { no: 2, name: "fingerprints", kind: "message", T: ProtoDtlsFingerPrints, repeated: true }
    ]);
    static fromBinary(bytes, options) {
      return new _ProtoDtlsParameters().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _ProtoDtlsParameters().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _ProtoDtlsParameters().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto3.util.equals(_ProtoDtlsParameters, a, b);
    }
  };
  var ProtoSctpParameters = class _ProtoSctpParameters extends Message {
    /**
     * @generated from field: int32 port = 1;
     */
    port = 0;
    /**
     * @generated from field: int32 OS = 2;
     */
    OS = 0;
    /**
     * @generated from field: int32 MIS = 3;
     */
    MIS = 0;
    /**
     * @generated from field: int32 maxMessageSize = 4;
     */
    maxMessageSize = 0;
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "ProtoSctpParameters";
    static fields = proto3.util.newFieldList(() => [
      {
        no: 1,
        name: "port",
        kind: "scalar",
        T: 5
        /* ScalarType.INT32 */
      },
      {
        no: 2,
        name: "OS",
        kind: "scalar",
        T: 5
        /* ScalarType.INT32 */
      },
      {
        no: 3,
        name: "MIS",
        kind: "scalar",
        T: 5
        /* ScalarType.INT32 */
      },
      {
        no: 4,
        name: "maxMessageSize",
        kind: "scalar",
        T: 5
        /* ScalarType.INT32 */
      }
    ]);
    static fromBinary(bytes, options) {
      return new _ProtoSctpParameters().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _ProtoSctpParameters().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _ProtoSctpParameters().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto3.util.equals(_ProtoSctpParameters, a, b);
    }
  };
  var ProtoTransportSDPInfo = class _ProtoTransportSDPInfo extends Message {
    /**
     * @generated from field: string id = 1;
     */
    id = "";
    /**
     * @generated from field: repeated ProtoIceCandidates iceCandidates = 2;
     */
    iceCandidates = [];
    /**
     * @generated from field: ProtoIceParameters iceParameters = 3;
     */
    iceParameters;
    /**
     * @generated from field: ProtoDtlsParameters dtlsParameters = 4;
     */
    dtlsParameters;
    /**
     * @generated from field: ProtoSctpParameters sctpParameters = 5;
     */
    sctpParameters;
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "ProtoTransportSDPInfo";
    static fields = proto3.util.newFieldList(() => [
      {
        no: 1,
        name: "id",
        kind: "scalar",
        T: 9
        /* ScalarType.STRING */
      },
      { no: 2, name: "iceCandidates", kind: "message", T: ProtoIceCandidates, repeated: true },
      { no: 3, name: "iceParameters", kind: "message", T: ProtoIceParameters },
      { no: 4, name: "dtlsParameters", kind: "message", T: ProtoDtlsParameters },
      { no: 5, name: "sctpParameters", kind: "message", T: ProtoSctpParameters }
    ]);
    static fromBinary(bytes, options) {
      return new _ProtoTransportSDPInfo().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _ProtoTransportSDPInfo().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _ProtoTransportSDPInfo().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto3.util.equals(_ProtoTransportSDPInfo, a, b);
    }
  };

  // ../protoc/dist/rtc/rtp_parameters_pb.js
  var ProtoRtcpFeedback = class _ProtoRtcpFeedback extends Message {
    /**
     * @generated from field: string type = 1;
     */
    type = "";
    /**
     * @generated from field: string parameter = 2;
     */
    parameter = "";
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "ProtoRtcpFeedback";
    static fields = proto3.util.newFieldList(() => [
      {
        no: 1,
        name: "type",
        kind: "scalar",
        T: 9
        /* ScalarType.STRING */
      },
      {
        no: 2,
        name: "parameter",
        kind: "scalar",
        T: 9
        /* ScalarType.STRING */
      }
    ]);
    static fromBinary(bytes, options) {
      return new _ProtoRtcpFeedback().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _ProtoRtcpFeedback().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _ProtoRtcpFeedback().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto3.util.equals(_ProtoRtcpFeedback, a, b);
    }
  };
  var ProtoCodecParameters = class _ProtoCodecParameters extends Message {
    /**
     * @generated from field: string mimeType = 1;
     */
    mimeType = "";
    /**
     * @generated from field: int32 payloadType = 2;
     */
    payloadType = 0;
    /**
     * @generated from field: int32 clockRate = 3;
     */
    clockRate = 0;
    /**
     * @generated from field: int32 channels = 4;
     */
    channels = 0;
    /**
     * @generated from field: map<string, string> parameters = 6;
     */
    parameters = {};
    /**
     * @generated from field: repeated ProtoRtcpFeedback rtcpFeedback = 7;
     */
    rtcpFeedback = [];
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "ProtoCodecParameters";
    static fields = proto3.util.newFieldList(() => [
      {
        no: 1,
        name: "mimeType",
        kind: "scalar",
        T: 9
        /* ScalarType.STRING */
      },
      {
        no: 2,
        name: "payloadType",
        kind: "scalar",
        T: 5
        /* ScalarType.INT32 */
      },
      {
        no: 3,
        name: "clockRate",
        kind: "scalar",
        T: 5
        /* ScalarType.INT32 */
      },
      {
        no: 4,
        name: "channels",
        kind: "scalar",
        T: 5
        /* ScalarType.INT32 */
      },
      { no: 6, name: "parameters", kind: "map", K: 9, V: {
        kind: "scalar",
        T: 9
        /* ScalarType.STRING */
      } },
      { no: 7, name: "rtcpFeedback", kind: "message", T: ProtoRtcpFeedback, repeated: true }
    ]);
    static fromBinary(bytes, options) {
      return new _ProtoCodecParameters().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _ProtoCodecParameters().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _ProtoCodecParameters().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto3.util.equals(_ProtoCodecParameters, a, b);
    }
  };
  var ProtoHeaderExtensionParameters = class _ProtoHeaderExtensionParameters extends Message {
    /**
     * @generated from field: string uri = 1;
     */
    uri = "";
    /**
     * @generated from field: int32 id = 2;
     */
    id = 0;
    /**
     * @generated from field: bool encrypt = 3;
     */
    encrypt = false;
    /**
     * @generated from field: map<string, string> parameters = 4;
     */
    parameters = {};
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "ProtoHeaderExtensionParameters";
    static fields = proto3.util.newFieldList(() => [
      {
        no: 1,
        name: "uri",
        kind: "scalar",
        T: 9
        /* ScalarType.STRING */
      },
      {
        no: 2,
        name: "id",
        kind: "scalar",
        T: 5
        /* ScalarType.INT32 */
      },
      {
        no: 3,
        name: "encrypt",
        kind: "scalar",
        T: 8
        /* ScalarType.BOOL */
      },
      { no: 4, name: "parameters", kind: "map", K: 9, V: {
        kind: "scalar",
        T: 9
        /* ScalarType.STRING */
      } }
    ]);
    static fromBinary(bytes, options) {
      return new _ProtoHeaderExtensionParameters().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _ProtoHeaderExtensionParameters().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _ProtoHeaderExtensionParameters().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto3.util.equals(_ProtoHeaderExtensionParameters, a, b);
    }
  };
  var ProtoEncodings = class _ProtoEncodings extends Message {
    /**
     * @generated from field: int64 ssrc = 1;
     */
    ssrc = protoInt64.zero;
    /**
     * @generated from field: string rid = 2;
     */
    rid = "";
    /**
     * @generated from field: int32 codecPayloadType = 3;
     */
    codecPayloadType = 0;
    /**
     * @generated from field: ProtoEncodings.ProtoRTX rtx = 4;
     */
    rtx;
    /**
     * @generated from field: bool dtx = 5;
     */
    dtx = false;
    /**
     * @generated from field: string scalabilityMode = 6;
     */
    scalabilityMode = "";
    /**
     * @generated from field: int32 scaleResolutionDownBy = 7;
     */
    scaleResolutionDownBy = 0;
    /**
     * @generated from field: int32 maxBitrate = 8;
     */
    maxBitrate = 0;
    /**
     * @generated from field: bool active = 9;
     */
    active = false;
    /**
     * @generated from field: int32 maxFramerate = 10;
     */
    maxFramerate = 0;
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "ProtoEncodings";
    static fields = proto3.util.newFieldList(() => [
      {
        no: 1,
        name: "ssrc",
        kind: "scalar",
        T: 3
        /* ScalarType.INT64 */
      },
      {
        no: 2,
        name: "rid",
        kind: "scalar",
        T: 9
        /* ScalarType.STRING */
      },
      {
        no: 3,
        name: "codecPayloadType",
        kind: "scalar",
        T: 5
        /* ScalarType.INT32 */
      },
      { no: 4, name: "rtx", kind: "message", T: ProtoEncodings_ProtoRTX },
      {
        no: 5,
        name: "dtx",
        kind: "scalar",
        T: 8
        /* ScalarType.BOOL */
      },
      {
        no: 6,
        name: "scalabilityMode",
        kind: "scalar",
        T: 9
        /* ScalarType.STRING */
      },
      {
        no: 7,
        name: "scaleResolutionDownBy",
        kind: "scalar",
        T: 5
        /* ScalarType.INT32 */
      },
      {
        no: 8,
        name: "maxBitrate",
        kind: "scalar",
        T: 5
        /* ScalarType.INT32 */
      },
      {
        no: 9,
        name: "active",
        kind: "scalar",
        T: 8
        /* ScalarType.BOOL */
      },
      {
        no: 10,
        name: "maxFramerate",
        kind: "scalar",
        T: 5
        /* ScalarType.INT32 */
      }
    ]);
    static fromBinary(bytes, options) {
      return new _ProtoEncodings().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _ProtoEncodings().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _ProtoEncodings().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto3.util.equals(_ProtoEncodings, a, b);
    }
  };
  var ProtoEncodings_ProtoRTX = class _ProtoEncodings_ProtoRTX extends Message {
    /**
     * @generated from field: int64 ssrc = 1;
     */
    ssrc = protoInt64.zero;
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "ProtoEncodings.ProtoRTX";
    static fields = proto3.util.newFieldList(() => [
      {
        no: 1,
        name: "ssrc",
        kind: "scalar",
        T: 3
        /* ScalarType.INT64 */
      }
    ]);
    static fromBinary(bytes, options) {
      return new _ProtoEncodings_ProtoRTX().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _ProtoEncodings_ProtoRTX().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _ProtoEncodings_ProtoRTX().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto3.util.equals(_ProtoEncodings_ProtoRTX, a, b);
    }
  };
  var RtcpParameters = class _RtcpParameters extends Message {
    /**
     * @generated from field: string cname = 1;
     */
    cname = "";
    /**
     * @generated from field: bool reducedSize = 2;
     */
    reducedSize = false;
    /**
     * @generated from field: bool mux = 3;
     */
    mux = false;
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "RtcpParameters";
    static fields = proto3.util.newFieldList(() => [
      {
        no: 1,
        name: "cname",
        kind: "scalar",
        T: 9
        /* ScalarType.STRING */
      },
      {
        no: 2,
        name: "reducedSize",
        kind: "scalar",
        T: 8
        /* ScalarType.BOOL */
      },
      {
        no: 3,
        name: "mux",
        kind: "scalar",
        T: 8
        /* ScalarType.BOOL */
      }
    ]);
    static fromBinary(bytes, options) {
      return new _RtcpParameters().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _RtcpParameters().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _RtcpParameters().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto3.util.equals(_RtcpParameters, a, b);
    }
  };
  var ProtoRtpParameters = class _ProtoRtpParameters extends Message {
    /**
     * @generated from field: string mid = 1;
     */
    mid = "";
    /**
     * @generated from field: repeated ProtoCodecParameters codecs = 2;
     */
    codecs = [];
    /**
     * @generated from field: repeated ProtoHeaderExtensionParameters headerExtensions = 3;
     */
    headerExtensions = [];
    /**
     * @generated from field: repeated ProtoEncodings encodings = 4;
     */
    encodings = [];
    /**
     * @generated from field: RtcpParameters rtcp = 5;
     */
    rtcp;
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "ProtoRtpParameters";
    static fields = proto3.util.newFieldList(() => [
      {
        no: 1,
        name: "mid",
        kind: "scalar",
        T: 9
        /* ScalarType.STRING */
      },
      { no: 2, name: "codecs", kind: "message", T: ProtoCodecParameters, repeated: true },
      { no: 3, name: "headerExtensions", kind: "message", T: ProtoHeaderExtensionParameters, repeated: true },
      { no: 4, name: "encodings", kind: "message", T: ProtoEncodings, repeated: true },
      { no: 5, name: "rtcp", kind: "message", T: RtcpParameters }
    ]);
    static fromBinary(bytes, options) {
      return new _ProtoRtpParameters().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _ProtoRtpParameters().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _ProtoRtpParameters().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto3.util.equals(_ProtoRtpParameters, a, b);
    }
  };
  (class _ProtoSrtpParameters extends Message {
    /**
     * @generated from field: string cryptoSuite = 1;
     */
    cryptoSuite = "";
    /**
     * @generated from field: string keyBase64 = 2;
     */
    keyBase64 = "";
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "ProtoSrtpParameters";
    static fields = proto3.util.newFieldList(() => [
      {
        no: 1,
        name: "cryptoSuite",
        kind: "scalar",
        T: 9
        /* ScalarType.STRING */
      },
      {
        no: 2,
        name: "keyBase64",
        kind: "scalar",
        T: 9
        /* ScalarType.STRING */
      }
    ]);
    static fromBinary(bytes, options) {
      return new _ProtoSrtpParameters().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _ProtoSrtpParameters().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _ProtoSrtpParameters().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto3.util.equals(_ProtoSrtpParameters, a, b);
    }
  });
  (class _ProtoTransportTuple extends Message {
    /**
     * @generated from field: string localIp = 1;
     */
    localIp = "";
    /**
     * @generated from field: int32 localPort = 2;
     */
    localPort = 0;
    /**
     * @generated from field: string remoteIp = 3;
     */
    remoteIp = "";
    /**
     * @generated from field: int32 remotePort = 4;
     */
    remotePort = 0;
    /**
     * @generated from field: string protocol = 5;
     */
    protocol = "";
    /**
     * @generated from field: string localAddress = 6;
     */
    localAddress = "";
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "ProtoTransportTuple";
    static fields = proto3.util.newFieldList(() => [
      {
        no: 1,
        name: "localIp",
        kind: "scalar",
        T: 9
        /* ScalarType.STRING */
      },
      {
        no: 2,
        name: "localPort",
        kind: "scalar",
        T: 5
        /* ScalarType.INT32 */
      },
      {
        no: 3,
        name: "remoteIp",
        kind: "scalar",
        T: 9
        /* ScalarType.STRING */
      },
      {
        no: 4,
        name: "remotePort",
        kind: "scalar",
        T: 5
        /* ScalarType.INT32 */
      },
      {
        no: 5,
        name: "protocol",
        kind: "scalar",
        T: 9
        /* ScalarType.STRING */
      },
      {
        no: 6,
        name: "localAddress",
        kind: "scalar",
        T: 9
        /* ScalarType.STRING */
      }
    ]);
    static fromBinary(bytes, options) {
      return new _ProtoTransportTuple().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _ProtoTransportTuple().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _ProtoTransportTuple().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto3.util.equals(_ProtoTransportTuple, a, b);
    }
  });

  // ../protoc/dist/client/app_data_pb.js
  var Value = class _Value extends Message {
    /**
     * @generated from oneof Value.value_type
     */
    valueType = { case: void 0 };
    constructor(data) {
      super();
      proto2.util.initPartial(data, this);
    }
    static runtime = proto2;
    static typeName = "Value";
    static fields = proto2.util.newFieldList(() => [
      { no: 1, name: "string_value", kind: "scalar", T: 9, oneof: "value_type" },
      { no: 2, name: "int_value", kind: "scalar", T: 5, oneof: "value_type" },
      { no: 3, name: "float_value", kind: "scalar", T: 2, oneof: "value_type" }
    ]);
    static fromBinary(bytes, options) {
      return new _Value().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _Value().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _Value().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto2.util.equals(_Value, a, b);
    }
  };
  var AppData = class _AppData extends Message {
    /**
     * @generated from field: map<string, Value> appData = 1;
     */
    appData = {};
    constructor(data) {
      super();
      proto2.util.initPartial(data, this);
    }
    static runtime = proto2;
    static typeName = "AppData";
    static fields = proto2.util.newFieldList(() => [
      { no: 1, name: "appData", kind: "map", K: 9, V: { kind: "message", T: Value } }
    ]);
    static fromBinary(bytes, options) {
      return new _AppData().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _AppData().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _AppData().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto2.util.equals(_AppData, a, b);
    }
  };

  // ../protoc/dist/rtc/sctp_stream_parameters_pb.js
  var ProtoSctpStreamParameters = class _ProtoSctpStreamParameters extends Message {
    /**
     * @generated from field: int32 streamId = 1;
     */
    streamId = 0;
    /**
     * @generated from field: bool ordered = 2;
     */
    ordered = false;
    /**
     * @generated from field: int32 maxPacketLifeTime = 3;
     */
    maxPacketLifeTime = 0;
    /**
     * @generated from field: int32 maxRetransmits = 4;
     */
    maxRetransmits = 0;
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "ProtoSctpStreamParameters";
    static fields = proto3.util.newFieldList(() => [
      {
        no: 1,
        name: "streamId",
        kind: "scalar",
        T: 5
        /* ScalarType.INT32 */
      },
      {
        no: 2,
        name: "ordered",
        kind: "scalar",
        T: 8
        /* ScalarType.BOOL */
      },
      {
        no: 3,
        name: "maxPacketLifeTime",
        kind: "scalar",
        T: 5
        /* ScalarType.INT32 */
      },
      {
        no: 4,
        name: "maxRetransmits",
        kind: "scalar",
        T: 5
        /* ScalarType.INT32 */
      }
    ]);
    static fromBinary(bytes, options) {
      return new _ProtoSctpStreamParameters().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _ProtoSctpStreamParameters().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _ProtoSctpStreamParameters().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto3.util.equals(_ProtoSctpStreamParameters, a, b);
    }
  };

  // ../protoc/dist/client/room_control_pb.js
  var ProduceSources = class _ProduceSources extends Message {
    /**
     * @generated from field: required bool mic = 1;
     */
    mic;
    /**
     * @generated from field: required bool cam = 2;
     */
    cam;
    /**
     * @generated from field: required bool screen = 3;
     */
    screen;
    constructor(data) {
      super();
      proto2.util.initPartial(data, this);
    }
    static runtime = proto2;
    static typeName = "ProduceSources";
    static fields = proto2.util.newFieldList(() => [
      { no: 1, name: "mic", kind: "scalar", T: 8, req: true },
      { no: 2, name: "cam", kind: "scalar", T: 8, req: true },
      { no: 3, name: "screen", kind: "scalar", T: 8, req: true }
    ]);
    static fromBinary(bytes, options) {
      return new _ProduceSources().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _ProduceSources().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _ProduceSources().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto2.util.equals(_ProduceSources, a, b);
    }
  };
  var RoomControlType = class _RoomControlType extends Message {
    /**
     * @generated from field: required string type = 1;
     */
    type;
    /**
     * @generated from field: required bool value = 5;
     */
    value;
    constructor(data) {
      super();
      proto2.util.initPartial(data, this);
    }
    static runtime = proto2;
    static typeName = "RoomControlType";
    static fields = proto2.util.newFieldList(() => [
      { no: 1, name: "type", kind: "scalar", T: 9, req: true },
      { no: 5, name: "value", kind: "scalar", T: 8, req: true }
    ]);
    static fromBinary(bytes, options) {
      return new _RoomControlType().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _RoomControlType().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _RoomControlType().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto2.util.equals(_RoomControlType, a, b);
    }
  };
  var ProduceSourcesControl = class _ProduceSourcesControl extends Message {
    /**
     * @generated from field: required string type = 1;
     */
    type;
    /**
     * @generated from field: required ProduceSources value = 2;
     */
    value;
    constructor(data) {
      super();
      proto2.util.initPartial(data, this);
    }
    static runtime = proto2;
    static typeName = "ProduceSourcesControl";
    static fields = proto2.util.newFieldList(() => [
      { no: 1, name: "type", kind: "scalar", T: 9, req: true },
      { no: 2, name: "value", kind: "message", T: ProduceSources, req: true }
    ]);
    static fromBinary(bytes, options) {
      return new _ProduceSourcesControl().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _ProduceSourcesControl().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _ProduceSourcesControl().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto2.util.equals(_ProduceSourcesControl, a, b);
    }
  };

  // ../protoc/dist/client/permissions_pb.js
  var Permissions = class _Permissions extends Message {
    /**
     * @generated from field: required bool admin = 1;
     */
    admin;
    /**
     * @generated from field: required bool canConsume = 2;
     */
    canConsume;
    /**
     * @generated from field: required bool canProduce = 3;
     */
    canProduce;
    /**
     * @generated from field: required Permissions.ProduceSources canProduceSources = 4;
     */
    canProduceSources;
    /**
     * @generated from field: required bool canSendData = 5;
     */
    canSendData;
    /**
     * @generated from field: required bool canRecvData = 6;
     */
    canRecvData;
    /**
     * @generated from field: required bool canUpdateMetadata = 7;
     */
    canUpdateMetadata;
    constructor(data) {
      super();
      proto2.util.initPartial(data, this);
    }
    static runtime = proto2;
    static typeName = "Permissions";
    static fields = proto2.util.newFieldList(() => [
      { no: 1, name: "admin", kind: "scalar", T: 8, req: true },
      { no: 2, name: "canConsume", kind: "scalar", T: 8, req: true },
      { no: 3, name: "canProduce", kind: "scalar", T: 8, req: true },
      { no: 4, name: "canProduceSources", kind: "message", T: Permissions_ProduceSources, req: true },
      { no: 5, name: "canSendData", kind: "scalar", T: 8, req: true },
      { no: 6, name: "canRecvData", kind: "scalar", T: 8, req: true },
      { no: 7, name: "canUpdateMetadata", kind: "scalar", T: 8, req: true }
    ]);
    static fromBinary(bytes, options) {
      return new _Permissions().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _Permissions().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _Permissions().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto2.util.equals(_Permissions, a, b);
    }
  };
  var Permissions_ProduceSources = class _Permissions_ProduceSources extends Message {
    /**
     * @generated from field: required bool cam = 1;
     */
    cam;
    /**
     * @generated from field: required bool mic = 2;
     */
    mic;
    /**
     * @generated from field: required bool screen = 3;
     */
    screen;
    constructor(data) {
      super();
      proto2.util.initPartial(data, this);
    }
    static runtime = proto2;
    static typeName = "Permissions.ProduceSources";
    static fields = proto2.util.newFieldList(() => [
      { no: 1, name: "cam", kind: "scalar", T: 8, req: true },
      { no: 2, name: "mic", kind: "scalar", T: 8, req: true },
      { no: 3, name: "screen", kind: "scalar", T: 8, req: true }
    ]);
    static fromBinary(bytes, options) {
      return new _Permissions_ProduceSources().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _Permissions_ProduceSources().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _Permissions_ProduceSources().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto2.util.equals(_Permissions_ProduceSources, a, b);
    }
  };

  // ../protoc/dist/client/request_pb.js
  (class _TestEvent extends Message {
    /**
     * @generated from field: required string name = 1;
     */
    name;
    /**
     * @generated from field: required string payload = 2;
     */
    payload;
    /**
     * @generated from field: optional string from = 3;
     */
    from;
    /**
     * @generated from field: optional string to = 4;
     */
    to;
    constructor(data) {
      super();
      proto2.util.initPartial(data, this);
    }
    static runtime = proto2;
    static typeName = "TestEvent";
    static fields = proto2.util.newFieldList(() => [
      { no: 1, name: "name", kind: "scalar", T: 9, req: true },
      { no: 2, name: "payload", kind: "scalar", T: 9, req: true },
      { no: 3, name: "from", kind: "scalar", T: 9, opt: true },
      { no: 4, name: "to", kind: "scalar", T: 9, opt: true }
    ]);
    static fromBinary(bytes, options) {
      return new _TestEvent().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _TestEvent().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _TestEvent().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto2.util.equals(_TestEvent, a, b);
    }
  });
  var ConnectRoom = class _ConnectRoom extends Message {
    /**
     * @generated from field: required string roomId = 1;
     */
    roomId;
    constructor(data) {
      super();
      proto2.util.initPartial(data, this);
    }
    static runtime = proto2;
    static typeName = "ConnectRoom";
    static fields = proto2.util.newFieldList(() => [
      { no: 1, name: "roomId", kind: "scalar", T: 9, req: true }
    ]);
    static fromBinary(bytes, options) {
      return new _ConnectRoom().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _ConnectRoom().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _ConnectRoom().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto2.util.equals(_ConnectRoom, a, b);
    }
  };
  var CreateTransport = class _CreateTransport extends Message {
    /**
     * @generated from field: required ProtoSctpCapabilities sctpCapabilities = 1;
     */
    sctpCapabilities;
    /**
     * @generated from field: required string transportType = 2;
     */
    transportType;
    constructor(data) {
      super();
      proto2.util.initPartial(data, this);
    }
    static runtime = proto2;
    static typeName = "CreateTransport";
    static fields = proto2.util.newFieldList(() => [
      { no: 1, name: "sctpCapabilities", kind: "message", T: ProtoSctpCapabilities, req: true },
      { no: 2, name: "transportType", kind: "scalar", T: 9, req: true }
    ]);
    static fromBinary(bytes, options) {
      return new _CreateTransport().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _CreateTransport().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _CreateTransport().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto2.util.equals(_CreateTransport, a, b);
    }
  };
  var ConnectTransport = class _ConnectTransport extends Message {
    /**
     * @generated from field: required string transportType = 1;
     */
    transportType;
    /**
     * @generated from field: required ProtoDtlsParameters dtlsParameters = 2;
     */
    dtlsParameters;
    constructor(data) {
      super();
      proto2.util.initPartial(data, this);
    }
    static runtime = proto2;
    static typeName = "ConnectTransport";
    static fields = proto2.util.newFieldList(() => [
      { no: 1, name: "transportType", kind: "scalar", T: 9, req: true },
      { no: 2, name: "dtlsParameters", kind: "message", T: ProtoDtlsParameters, req: true }
    ]);
    static fromBinary(bytes, options) {
      return new _ConnectTransport().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _ConnectTransport().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _ConnectTransport().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto2.util.equals(_ConnectTransport, a, b);
    }
  };
  var CreateDataConsumer = class _CreateDataConsumer extends Message {
    /**
     * @generated from field: required string label = 1;
     */
    label;
    constructor(data) {
      super();
      proto2.util.initPartial(data, this);
    }
    static runtime = proto2;
    static typeName = "CreateDataConsumer";
    static fields = proto2.util.newFieldList(() => [
      { no: 1, name: "label", kind: "scalar", T: 9, req: true }
    ]);
    static fromBinary(bytes, options) {
      return new _CreateDataConsumer().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _CreateDataConsumer().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _CreateDataConsumer().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto2.util.equals(_CreateDataConsumer, a, b);
    }
  };
  var Produce = class _Produce extends Message {
    /**
     * @generated from field: required string label = 1;
     */
    label;
    /**
     * @generated from field: required string kind = 2;
     */
    kind;
    /**
     * @generated from field: required ProtoRtpParameters rtpParameters = 3;
     */
    rtpParameters;
    /**
     * @generated from field: required bool paused = 4;
     */
    paused;
    /**
     * @generated from field: optional AppData appData = 5;
     */
    appData;
    constructor(data) {
      super();
      proto2.util.initPartial(data, this);
    }
    static runtime = proto2;
    static typeName = "Produce";
    static fields = proto2.util.newFieldList(() => [
      { no: 1, name: "label", kind: "scalar", T: 9, req: true },
      { no: 2, name: "kind", kind: "scalar", T: 9, req: true },
      { no: 3, name: "rtpParameters", kind: "message", T: ProtoRtpParameters, req: true },
      { no: 4, name: "paused", kind: "scalar", T: 8, req: true },
      { no: 5, name: "appData", kind: "message", T: AppData, opt: true }
    ]);
    static fromBinary(bytes, options) {
      return new _Produce().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _Produce().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _Produce().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto2.util.equals(_Produce, a, b);
    }
  };
  var ProduceData = class _ProduceData extends Message {
    /**
     * @generated from field: required string transportId = 1;
     */
    transportId;
    /**
     * @generated from field: required ProtoSctpStreamParameters sctpStreamParameters = 2;
     */
    sctpStreamParameters;
    /**
     * @generated from field: required string label = 3;
     */
    label;
    /**
     * @generated from field: optional string protocol = 4;
     */
    protocol;
    /**
     * @generated from field: optional AppData appData = 5;
     */
    appData;
    constructor(data) {
      super();
      proto2.util.initPartial(data, this);
    }
    static runtime = proto2;
    static typeName = "ProduceData";
    static fields = proto2.util.newFieldList(() => [
      { no: 1, name: "transportId", kind: "scalar", T: 9, req: true },
      { no: 2, name: "sctpStreamParameters", kind: "message", T: ProtoSctpStreamParameters, req: true },
      { no: 3, name: "label", kind: "scalar", T: 9, req: true },
      { no: 4, name: "protocol", kind: "scalar", T: 9, opt: true },
      { no: 5, name: "appData", kind: "message", T: AppData, opt: true }
    ]);
    static fromBinary(bytes, options) {
      return new _ProduceData().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _ProduceData().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _ProduceData().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto2.util.equals(_ProduceData, a, b);
    }
  };
  var Consume = class _Consume extends Message {
    /**
     * @generated from field: required string producerPeerId = 1;
     */
    producerPeerId;
    /**
     * @generated from field: required string producerId = 2;
     */
    producerId;
    /**
     * @generated from field: optional AppData appData = 3;
     */
    appData;
    constructor(data) {
      super();
      proto2.util.initPartial(data, this);
    }
    static runtime = proto2;
    static typeName = "Consume";
    static fields = proto2.util.newFieldList(() => [
      { no: 1, name: "producerPeerId", kind: "scalar", T: 9, req: true },
      { no: 2, name: "producerId", kind: "scalar", T: 9, req: true },
      { no: 3, name: "appData", kind: "message", T: AppData, opt: true }
    ]);
    static fromBinary(bytes, options) {
      return new _Consume().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _Consume().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _Consume().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto2.util.equals(_Consume, a, b);
    }
  };
  var CloseProducer = class _CloseProducer extends Message {
    /**
     * @generated from field: required string producerId = 1;
     */
    producerId;
    constructor(data) {
      super();
      proto2.util.initPartial(data, this);
    }
    static runtime = proto2;
    static typeName = "CloseProducer";
    static fields = proto2.util.newFieldList(() => [
      { no: 1, name: "producerId", kind: "scalar", T: 9, req: true }
    ]);
    static fromBinary(bytes, options) {
      return new _CloseProducer().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _CloseProducer().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _CloseProducer().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto2.util.equals(_CloseProducer, a, b);
    }
  };
  var PauseProducer = class _PauseProducer extends Message {
    /**
     * @generated from field: required string producerId = 1;
     */
    producerId;
    constructor(data) {
      super();
      proto2.util.initPartial(data, this);
    }
    static runtime = proto2;
    static typeName = "PauseProducer";
    static fields = proto2.util.newFieldList(() => [
      { no: 1, name: "producerId", kind: "scalar", T: 9, req: true }
    ]);
    static fromBinary(bytes, options) {
      return new _PauseProducer().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _PauseProducer().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _PauseProducer().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto2.util.equals(_PauseProducer, a, b);
    }
  };
  var ResumeProducer = class _ResumeProducer extends Message {
    /**
     * @generated from field: required string producerId = 1;
     */
    producerId;
    constructor(data) {
      super();
      proto2.util.initPartial(data, this);
    }
    static runtime = proto2;
    static typeName = "ResumeProducer";
    static fields = proto2.util.newFieldList(() => [
      { no: 1, name: "producerId", kind: "scalar", T: 9, req: true }
    ]);
    static fromBinary(bytes, options) {
      return new _ResumeProducer().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _ResumeProducer().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _ResumeProducer().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto2.util.equals(_ResumeProducer, a, b);
    }
  };
  var CloseConsumer = class _CloseConsumer extends Message {
    /**
     * @generated from field: required string consumerId = 1;
     */
    consumerId;
    constructor(data) {
      super();
      proto2.util.initPartial(data, this);
    }
    static runtime = proto2;
    static typeName = "CloseConsumer";
    static fields = proto2.util.newFieldList(() => [
      { no: 1, name: "consumerId", kind: "scalar", T: 9, req: true }
    ]);
    static fromBinary(bytes, options) {
      return new _CloseConsumer().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _CloseConsumer().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _CloseConsumer().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto2.util.equals(_CloseConsumer, a, b);
    }
  };
  var ResumeConsumer = class _ResumeConsumer extends Message {
    /**
     * @generated from field: required string consumerId = 1;
     */
    consumerId;
    /**
     * @generated from field: required string producerPeerId = 2;
     */
    producerPeerId;
    constructor(data) {
      super();
      proto2.util.initPartial(data, this);
    }
    static runtime = proto2;
    static typeName = "ResumeConsumer";
    static fields = proto2.util.newFieldList(() => [
      { no: 1, name: "consumerId", kind: "scalar", T: 9, req: true },
      { no: 2, name: "producerPeerId", kind: "scalar", T: 9, req: true }
    ]);
    static fromBinary(bytes, options) {
      return new _ResumeConsumer().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _ResumeConsumer().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _ResumeConsumer().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto2.util.equals(_ResumeConsumer, a, b);
    }
  };
  var SyncMeetingState = class _SyncMeetingState extends Message {
    /**
     * @generated from field: repeated string localProducerIds = 1;
     */
    localProducerIds = [];
    constructor(data) {
      super();
      proto2.util.initPartial(data, this);
    }
    static runtime = proto2;
    static typeName = "SyncMeetingState";
    static fields = proto2.util.newFieldList(() => [
      { no: 1, name: "localProducerIds", kind: "scalar", T: 9, repeated: true }
    ]);
    static fromBinary(bytes, options) {
      return new _SyncMeetingState().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _SyncMeetingState().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _SyncMeetingState().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto2.util.equals(_SyncMeetingState, a, b);
    }
  };
  var RestartTransportIce = class _RestartTransportIce extends Message {
    /**
     * @generated from field: required string transportType = 1;
     */
    transportType;
    /**
     * @generated from field: required string transportId = 2;
     */
    transportId;
    constructor(data) {
      super();
      proto2.util.initPartial(data, this);
    }
    static runtime = proto2;
    static typeName = "RestartTransportIce";
    static fields = proto2.util.newFieldList(() => [
      { no: 1, name: "transportType", kind: "scalar", T: 9, req: true },
      { no: 2, name: "transportId", kind: "scalar", T: 9, req: true }
    ]);
    static fromBinary(bytes, options) {
      return new _RestartTransportIce().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _RestartTransportIce().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _RestartTransportIce().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto2.util.equals(_RestartTransportIce, a, b);
    }
  };
  var SendData = class _SendData extends Message {
    /**
     * @generated from field: repeated string to = 1;
     */
    to = [];
    /**
     * @generated from field: optional string label = 2;
     */
    label;
    /**
     * @generated from field: required string payload = 3;
     */
    payload;
    constructor(data) {
      super();
      proto2.util.initPartial(data, this);
    }
    static runtime = proto2;
    static typeName = "SendData";
    static fields = proto2.util.newFieldList(() => [
      { no: 1, name: "to", kind: "scalar", T: 9, repeated: true },
      { no: 2, name: "label", kind: "scalar", T: 9, opt: true },
      { no: 3, name: "payload", kind: "scalar", T: 9, req: true }
    ]);
    static fromBinary(bytes, options) {
      return new _SendData().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _SendData().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _SendData().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto2.util.equals(_SendData, a, b);
    }
  };
  var UpdateRoomControls = class _UpdateRoomControls extends Message {
    /**
     * @generated from oneof UpdateRoomControls.control
     */
    control = { case: void 0 };
    constructor(data) {
      super();
      proto2.util.initPartial(data, this);
    }
    static runtime = proto2;
    static typeName = "UpdateRoomControls";
    static fields = proto2.util.newFieldList(() => [
      { no: 1, name: "room_control", kind: "message", T: RoomControlType, oneof: "control" },
      { no: 2, name: "produce_sources_control", kind: "message", T: ProduceSourcesControl, oneof: "control" }
    ]);
    static fromBinary(bytes, options) {
      return new _UpdateRoomControls().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _UpdateRoomControls().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _UpdateRoomControls().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto2.util.equals(_UpdateRoomControls, a, b);
    }
  };
  var UpdatePeerPermission = class _UpdatePeerPermission extends Message {
    /**
     * @generated from field: required string peerId = 1;
     */
    peerId;
    /**
     * @generated from field: optional Permissions permissions = 2;
     */
    permissions;
    constructor(data) {
      super();
      proto2.util.initPartial(data, this);
    }
    static runtime = proto2;
    static typeName = "UpdatePeerPermission";
    static fields = proto2.util.newFieldList(() => [
      { no: 1, name: "peerId", kind: "scalar", T: 9, req: true },
      { no: 2, name: "permissions", kind: "message", T: Permissions, opt: true }
    ]);
    static fromBinary(bytes, options) {
      return new _UpdatePeerPermission().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _UpdatePeerPermission().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _UpdatePeerPermission().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto2.util.equals(_UpdatePeerPermission, a, b);
    }
  };
  var ActivateSpeakerNotification = class _ActivateSpeakerNotification extends Message {
    /**
     * @generated from field: optional int32 size = 1;
     */
    size;
    constructor(data) {
      super();
      proto2.util.initPartial(data, this);
    }
    static runtime = proto2;
    static typeName = "ActivateSpeakerNotification";
    static fields = proto2.util.newFieldList(() => [
      { no: 1, name: "size", kind: "scalar", T: 5, opt: true }
    ]);
    static fromBinary(bytes, options) {
      return new _ActivateSpeakerNotification().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _ActivateSpeakerNotification().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _ActivateSpeakerNotification().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto2.util.equals(_ActivateSpeakerNotification, a, b);
    }
  };
  var UpdatePeerRole = class _UpdatePeerRole extends Message {
    /**
     * @generated from field: required string peerId = 1;
     */
    peerId;
    /**
     * @generated from field: required string role = 2;
     */
    role;
    /**
     * @generated from field: optional UpdatePeerRole.Options options = 3;
     */
    options;
    constructor(data) {
      super();
      proto2.util.initPartial(data, this);
    }
    static runtime = proto2;
    static typeName = "UpdatePeerRole";
    static fields = proto2.util.newFieldList(() => [
      { no: 1, name: "peerId", kind: "scalar", T: 9, req: true },
      { no: 2, name: "role", kind: "scalar", T: 9, req: true },
      { no: 3, name: "options", kind: "message", T: UpdatePeerRole_Options, opt: true }
    ]);
    static fromBinary(bytes, options) {
      return new _UpdatePeerRole().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _UpdatePeerRole().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _UpdatePeerRole().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto2.util.equals(_UpdatePeerRole, a, b);
    }
  };
  var UpdatePeerRole_Options = class _UpdatePeerRole_Options extends Message {
    /**
     * @generated from field: optional Permissions custom = 1;
     */
    custom;
    constructor(data) {
      super();
      proto2.util.initPartial(data, this);
    }
    static runtime = proto2;
    static typeName = "UpdatePeerRole.Options";
    static fields = proto2.util.newFieldList(() => [
      { no: 1, name: "custom", kind: "message", T: Permissions, opt: true }
    ]);
    static fromBinary(bytes, options) {
      return new _UpdatePeerRole_Options().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _UpdatePeerRole_Options().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _UpdatePeerRole_Options().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto2.util.equals(_UpdatePeerRole_Options, a, b);
    }
  };
  var UpdatePeerMetadata = class _UpdatePeerMetadata extends Message {
    /**
     * @generated from field: required string peerId = 1;
     */
    peerId;
    /**
     * @generated from field: required string metadata = 2;
     */
    metadata;
    constructor(data) {
      super();
      proto2.util.initPartial(data, this);
    }
    static runtime = proto2;
    static typeName = "UpdatePeerMetadata";
    static fields = proto2.util.newFieldList(() => [
      { no: 1, name: "peerId", kind: "scalar", T: 9, req: true },
      { no: 2, name: "metadata", kind: "scalar", T: 9, req: true }
    ]);
    static fromBinary(bytes, options) {
      return new _UpdatePeerMetadata().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _UpdatePeerMetadata().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _UpdatePeerMetadata().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto2.util.equals(_UpdatePeerMetadata, a, b);
    }
  };
  var UpdateRoomMetadata = class _UpdateRoomMetadata extends Message {
    /**
     * @generated from field: required string metadata = 1;
     */
    metadata;
    constructor(data) {
      super();
      proto2.util.initPartial(data, this);
    }
    static runtime = proto2;
    static typeName = "UpdateRoomMetadata";
    static fields = proto2.util.newFieldList(() => [
      { no: 1, name: "metadata", kind: "scalar", T: 9, req: true }
    ]);
    static fromBinary(bytes, options) {
      return new _UpdateRoomMetadata().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _UpdateRoomMetadata().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _UpdateRoomMetadata().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto2.util.equals(_UpdateRoomMetadata, a, b);
    }
  };
  var CloseStreamOfLabel = class _CloseStreamOfLabel extends Message {
    /**
     * @generated from field: required string label = 1;
     */
    label;
    /**
     * @generated from field: repeated string peerIds = 2;
     */
    peerIds = [];
    constructor(data) {
      super();
      proto2.util.initPartial(data, this);
    }
    static runtime = proto2;
    static typeName = "CloseStreamOfLabel";
    static fields = proto2.util.newFieldList(() => [
      { no: 1, name: "label", kind: "scalar", T: 9, req: true },
      { no: 2, name: "peerIds", kind: "scalar", T: 9, repeated: true }
    ]);
    static fromBinary(bytes, options) {
      return new _CloseStreamOfLabel().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _CloseStreamOfLabel().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _CloseStreamOfLabel().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto2.util.equals(_CloseStreamOfLabel, a, b);
    }
  };
  var AcceptLobbyPeer = class _AcceptLobbyPeer extends Message {
    /**
     * @generated from field: required string peerId = 1;
     */
    peerId;
    constructor(data) {
      super();
      proto2.util.initPartial(data, this);
    }
    static runtime = proto2;
    static typeName = "AcceptLobbyPeer";
    static fields = proto2.util.newFieldList(() => [
      { no: 1, name: "peerId", kind: "scalar", T: 9, req: true }
    ]);
    static fromBinary(bytes, options) {
      return new _AcceptLobbyPeer().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _AcceptLobbyPeer().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _AcceptLobbyPeer().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto2.util.equals(_AcceptLobbyPeer, a, b);
    }
  };
  var DenyLobbyPeer = class _DenyLobbyPeer extends Message {
    /**
     * @generated from field: required string peerId = 1;
     */
    peerId;
    constructor(data) {
      super();
      proto2.util.initPartial(data, this);
    }
    static runtime = proto2;
    static typeName = "DenyLobbyPeer";
    static fields = proto2.util.newFieldList(() => [
      { no: 1, name: "peerId", kind: "scalar", T: 9, req: true }
    ]);
    static fromBinary(bytes, options) {
      return new _DenyLobbyPeer().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _DenyLobbyPeer().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _DenyLobbyPeer().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto2.util.equals(_DenyLobbyPeer, a, b);
    }
  };
  var KickPeer = class _KickPeer extends Message {
    /**
     * @generated from field: required string peerId = 1;
     */
    peerId;
    constructor(data) {
      super();
      proto2.util.initPartial(data, this);
    }
    static runtime = proto2;
    static typeName = "KickPeer";
    static fields = proto2.util.newFieldList(() => [
      { no: 1, name: "peerId", kind: "scalar", T: 9, req: true }
    ]);
    static fromBinary(bytes, options) {
      return new _KickPeer().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _KickPeer().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _KickPeer().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto2.util.equals(_KickPeer, a, b);
    }
  };
  var CloseRoom = class _CloseRoom extends Message {
    constructor(data) {
      super();
      proto2.util.initPartial(data, this);
    }
    static runtime = proto2;
    static typeName = "CloseRoom";
    static fields = proto2.util.newFieldList(() => []);
    static fromBinary(bytes, options) {
      return new _CloseRoom().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _CloseRoom().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _CloseRoom().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto2.util.equals(_CloseRoom, a, b);
    }
  };
  var Request = class _Request extends Message {
    /**
     * @generated from oneof Request.request
     */
    request = { case: void 0 };
    constructor(data) {
      super();
      proto2.util.initPartial(data, this);
    }
    static runtime = proto2;
    static typeName = "Request";
    static fields = proto2.util.newFieldList(() => [
      { no: 2, name: "connect_room", kind: "message", T: ConnectRoom, oneof: "request" },
      { no: 3, name: "create_transport", kind: "message", T: CreateTransport, oneof: "request" },
      { no: 4, name: "connect_transport", kind: "message", T: ConnectTransport, oneof: "request" },
      { no: 25, name: "create_data_consumer", kind: "message", T: CreateDataConsumer, oneof: "request" },
      { no: 5, name: "produce", kind: "message", T: Produce, oneof: "request" },
      { no: 6, name: "produce_data", kind: "message", T: ProduceData, oneof: "request" },
      { no: 7, name: "consume", kind: "message", T: Consume, oneof: "request" },
      { no: 8, name: "close_producer", kind: "message", T: CloseProducer, oneof: "request" },
      { no: 26, name: "pause_producer", kind: "message", T: PauseProducer, oneof: "request" },
      { no: 27, name: "resume_producer", kind: "message", T: ResumeProducer, oneof: "request" },
      { no: 9, name: "close_consumer", kind: "message", T: CloseConsumer, oneof: "request" },
      { no: 10, name: "resume_consumer", kind: "message", T: ResumeConsumer, oneof: "request" },
      { no: 11, name: "sync_meeting_state", kind: "message", T: SyncMeetingState, oneof: "request" },
      { no: 12, name: "restart_transport_ice", kind: "message", T: RestartTransportIce, oneof: "request" },
      { no: 13, name: "send_data", kind: "message", T: SendData, oneof: "request" },
      { no: 14, name: "update_room_controls", kind: "message", T: UpdateRoomControls, oneof: "request" },
      { no: 15, name: "update_peer_permission", kind: "message", T: UpdatePeerPermission, oneof: "request" },
      { no: 16, name: "activate_speaker_notification", kind: "message", T: ActivateSpeakerNotification, oneof: "request" },
      { no: 17, name: "update_peer_role", kind: "message", T: UpdatePeerRole, oneof: "request" },
      { no: 18, name: "update_peer_metadata", kind: "message", T: UpdatePeerMetadata, oneof: "request" },
      { no: 19, name: "update_room_metadata", kind: "message", T: UpdateRoomMetadata, oneof: "request" },
      { no: 20, name: "close_stream_of_label", kind: "message", T: CloseStreamOfLabel, oneof: "request" },
      { no: 21, name: "accept_lobby_peer", kind: "message", T: AcceptLobbyPeer, oneof: "request" },
      { no: 22, name: "deny_lobby_peer", kind: "message", T: DenyLobbyPeer, oneof: "request" },
      { no: 23, name: "kick_peer", kind: "message", T: KickPeer, oneof: "request" },
      { no: 24, name: "close_room", kind: "message", T: CloseRoom, oneof: "request" }
    ]);
    static fromBinary(bytes, options) {
      return new _Request().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _Request().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _Request().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto2.util.equals(_Request, a, b);
    }
  };

  // ../protoc/dist/rtc/rtp_capabilities_pb.js
  var ProtoRtpCodecCapability = class _ProtoRtpCodecCapability extends Message {
    /**
     * @generated from field: string kind = 1;
     */
    kind = "";
    /**
     * @generated from field: string mimeType = 2;
     */
    mimeType = "";
    /**
     * @generated from field: int32 preferredPayloadType = 3;
     */
    preferredPayloadType = 0;
    /**
     * @generated from field: int32 clockRate = 4;
     */
    clockRate = 0;
    /**
     * @generated from field: int32 channels = 5;
     */
    channels = 0;
    /**
     * @generated from field: map<string, string> parameters = 6;
     */
    parameters = {};
    /**
     * @generated from field: repeated ProtoRtpCodecCapability.ProtoRtcpFeedback rtcpFeedback = 7;
     */
    rtcpFeedback = [];
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "ProtoRtpCodecCapability";
    static fields = proto3.util.newFieldList(() => [
      {
        no: 1,
        name: "kind",
        kind: "scalar",
        T: 9
        /* ScalarType.STRING */
      },
      {
        no: 2,
        name: "mimeType",
        kind: "scalar",
        T: 9
        /* ScalarType.STRING */
      },
      {
        no: 3,
        name: "preferredPayloadType",
        kind: "scalar",
        T: 5
        /* ScalarType.INT32 */
      },
      {
        no: 4,
        name: "clockRate",
        kind: "scalar",
        T: 5
        /* ScalarType.INT32 */
      },
      {
        no: 5,
        name: "channels",
        kind: "scalar",
        T: 5
        /* ScalarType.INT32 */
      },
      { no: 6, name: "parameters", kind: "map", K: 9, V: {
        kind: "scalar",
        T: 9
        /* ScalarType.STRING */
      } },
      { no: 7, name: "rtcpFeedback", kind: "message", T: ProtoRtpCodecCapability_ProtoRtcpFeedback, repeated: true }
    ]);
    static fromBinary(bytes, options) {
      return new _ProtoRtpCodecCapability().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _ProtoRtpCodecCapability().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _ProtoRtpCodecCapability().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto3.util.equals(_ProtoRtpCodecCapability, a, b);
    }
  };
  var ProtoRtpCodecCapability_ProtoRtcpFeedback = class _ProtoRtpCodecCapability_ProtoRtcpFeedback extends Message {
    /**
     * @generated from field: string type = 1;
     */
    type = "";
    /**
     * @generated from field: string parameter = 2;
     */
    parameter = "";
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "ProtoRtpCodecCapability.ProtoRtcpFeedback";
    static fields = proto3.util.newFieldList(() => [
      {
        no: 1,
        name: "type",
        kind: "scalar",
        T: 9
        /* ScalarType.STRING */
      },
      {
        no: 2,
        name: "parameter",
        kind: "scalar",
        T: 9
        /* ScalarType.STRING */
      }
    ]);
    static fromBinary(bytes, options) {
      return new _ProtoRtpCodecCapability_ProtoRtcpFeedback().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _ProtoRtpCodecCapability_ProtoRtcpFeedback().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _ProtoRtpCodecCapability_ProtoRtcpFeedback().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto3.util.equals(_ProtoRtpCodecCapability_ProtoRtcpFeedback, a, b);
    }
  };
  var ProtoRtpHeaderExtension = class _ProtoRtpHeaderExtension extends Message {
    /**
     * @generated from field: string kind = 1;
     */
    kind = "";
    /**
     * @generated from field: string uri = 2;
     */
    uri = "";
    /**
     * @generated from field: int32 preferredId = 3;
     */
    preferredId = 0;
    /**
     * @generated from field: bool preferredEncrypt = 4;
     */
    preferredEncrypt = false;
    /**
     * @generated from field: string direction = 5;
     */
    direction = "";
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "ProtoRtpHeaderExtension";
    static fields = proto3.util.newFieldList(() => [
      {
        no: 1,
        name: "kind",
        kind: "scalar",
        T: 9
        /* ScalarType.STRING */
      },
      {
        no: 2,
        name: "uri",
        kind: "scalar",
        T: 9
        /* ScalarType.STRING */
      },
      {
        no: 3,
        name: "preferredId",
        kind: "scalar",
        T: 5
        /* ScalarType.INT32 */
      },
      {
        no: 4,
        name: "preferredEncrypt",
        kind: "scalar",
        T: 8
        /* ScalarType.BOOL */
      },
      {
        no: 5,
        name: "direction",
        kind: "scalar",
        T: 9
        /* ScalarType.STRING */
      }
    ]);
    static fromBinary(bytes, options) {
      return new _ProtoRtpHeaderExtension().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _ProtoRtpHeaderExtension().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _ProtoRtpHeaderExtension().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto3.util.equals(_ProtoRtpHeaderExtension, a, b);
    }
  };
  var ProtoRtpCapabilities = class _ProtoRtpCapabilities extends Message {
    /**
     * @generated from field: repeated ProtoRtpCodecCapability codecs = 1;
     */
    codecs = [];
    /**
     * @generated from field: repeated ProtoRtpHeaderExtension headerExtensions = 2;
     */
    headerExtensions = [];
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "ProtoRtpCapabilities";
    static fields = proto3.util.newFieldList(() => [
      { no: 1, name: "codecs", kind: "message", T: ProtoRtpCodecCapability, repeated: true },
      { no: 2, name: "headerExtensions", kind: "message", T: ProtoRtpHeaderExtension, repeated: true }
    ]);
    static fromBinary(bytes, options) {
      return new _ProtoRtpCapabilities().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _ProtoRtpCapabilities().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _ProtoRtpCapabilities().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto3.util.equals(_ProtoRtpCapabilities, a, b);
    }
  };

  // ../protoc/dist/client/response_pb.js
  var Hello = class _Hello extends Message {
    /**
     * @generated from field: required string peerId = 1;
     */
    peerId;
    /**
     * @generated from field: required string roomId = 2;
     */
    roomId;
    /**
     * @generated from field: required string sessionId = 3;
     */
    sessionId;
    /**
     * @generated from field: required Permissions acl = 4;
     */
    acl;
    /**
     * @generated from field: optional string role = 5;
     */
    role;
    /**
     * @generated from field: optional string metadata = 6;
     */
    metadata;
    constructor(data) {
      super();
      proto2.util.initPartial(data, this);
    }
    static runtime = proto2;
    static typeName = "Hello";
    static fields = proto2.util.newFieldList(() => [
      { no: 1, name: "peerId", kind: "scalar", T: 9, req: true },
      { no: 2, name: "roomId", kind: "scalar", T: 9, req: true },
      { no: 3, name: "sessionId", kind: "scalar", T: 9, req: true },
      { no: 4, name: "acl", kind: "message", T: Permissions, req: true },
      { no: 5, name: "role", kind: "scalar", T: 9, opt: true },
      { no: 6, name: "metadata", kind: "scalar", T: 9, opt: true }
    ]);
    static fromBinary(bytes, options) {
      return new _Hello().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _Hello().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _Hello().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto2.util.equals(_Hello, a, b);
    }
  };
  var RoomControls = class _RoomControls extends Message {
    /**
     * @generated from field: required bool roomLocked = 1;
     */
    roomLocked;
    /**
     * @generated from field: required bool allowProduce = 2;
     */
    allowProduce;
    /**
     * @generated from field: required RoomControls.ProduceSources allowProduceSources = 3;
     */
    allowProduceSources;
    /**
     * @generated from field: required bool allowConsume = 4;
     */
    allowConsume;
    /**
     * @generated from field: required bool allowSendData = 5;
     */
    allowSendData;
    constructor(data) {
      super();
      proto2.util.initPartial(data, this);
    }
    static runtime = proto2;
    static typeName = "RoomControls";
    static fields = proto2.util.newFieldList(() => [
      { no: 1, name: "roomLocked", kind: "scalar", T: 8, req: true },
      { no: 2, name: "allowProduce", kind: "scalar", T: 8, req: true },
      { no: 3, name: "allowProduceSources", kind: "message", T: RoomControls_ProduceSources, req: true },
      { no: 4, name: "allowConsume", kind: "scalar", T: 8, req: true },
      { no: 5, name: "allowSendData", kind: "scalar", T: 8, req: true }
    ]);
    static fromBinary(bytes, options) {
      return new _RoomControls().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _RoomControls().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _RoomControls().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto2.util.equals(_RoomControls, a, b);
    }
  };
  var RoomControls_ProduceSources = class _RoomControls_ProduceSources extends Message {
    /**
     * @generated from field: required bool cam = 1;
     */
    cam;
    /**
     * @generated from field: required bool mic = 2;
     */
    mic;
    /**
     * @generated from field: required bool screen = 3;
     */
    screen;
    constructor(data) {
      super();
      proto2.util.initPartial(data, this);
    }
    static runtime = proto2;
    static typeName = "RoomControls.ProduceSources";
    static fields = proto2.util.newFieldList(() => [
      { no: 1, name: "cam", kind: "scalar", T: 8, req: true },
      { no: 2, name: "mic", kind: "scalar", T: 8, req: true },
      { no: 3, name: "screen", kind: "scalar", T: 8, req: true }
    ]);
    static fromBinary(bytes, options) {
      return new _RoomControls_ProduceSources().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _RoomControls_ProduceSources().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _RoomControls_ProduceSources().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto2.util.equals(_RoomControls_ProduceSources, a, b);
    }
  };
  var PeersInfo = class _PeersInfo extends Message {
    /**
     * @generated from field: required string peerId = 1;
     */
    peerId;
    /**
     * @generated from field: optional string metadata = 3;
     */
    metadata;
    /**
     * @generated from field: optional string role = 5;
     */
    role;
    /**
     * @generated from field: repeated PeersInfo.ProducerInfo producers = 4;
     */
    producers = [];
    constructor(data) {
      super();
      proto2.util.initPartial(data, this);
    }
    static runtime = proto2;
    static typeName = "PeersInfo";
    static fields = proto2.util.newFieldList(() => [
      { no: 1, name: "peerId", kind: "scalar", T: 9, req: true },
      { no: 3, name: "metadata", kind: "scalar", T: 9, opt: true },
      { no: 5, name: "role", kind: "scalar", T: 9, opt: true },
      { no: 4, name: "producers", kind: "message", T: PeersInfo_ProducerInfo, repeated: true }
    ]);
    static fromBinary(bytes, options) {
      return new _PeersInfo().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _PeersInfo().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _PeersInfo().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto2.util.equals(_PeersInfo, a, b);
    }
  };
  var PeersInfo_ProducerInfo = class _PeersInfo_ProducerInfo extends Message {
    /**
     * @generated from field: required string id = 1;
     */
    id;
    /**
     * @generated from field: required string label = 2;
     */
    label;
    /**
     * @generated from field: optional bool paused = 3;
     */
    paused;
    constructor(data) {
      super();
      proto2.util.initPartial(data, this);
    }
    static runtime = proto2;
    static typeName = "PeersInfo.ProducerInfo";
    static fields = proto2.util.newFieldList(() => [
      { no: 1, name: "id", kind: "scalar", T: 9, req: true },
      { no: 2, name: "label", kind: "scalar", T: 9, req: true },
      { no: 3, name: "paused", kind: "scalar", T: 8, opt: true }
    ]);
    static fromBinary(bytes, options) {
      return new _PeersInfo_ProducerInfo().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _PeersInfo_ProducerInfo().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _PeersInfo_ProducerInfo().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto2.util.equals(_PeersInfo_ProducerInfo, a, b);
    }
  };
  var RoomInfo = class _RoomInfo extends Message {
    /**
     * @generated from field: required bool roomLocked = 1;
     */
    roomLocked;
    /**
     * @generated from field: required RoomControls config = 2;
     */
    config;
    /**
     * @generated from field: repeated PeersInfo peers = 3;
     */
    peers = [];
    /**
     * @generated from field: repeated LobbyPeers lobbyPeers = 4;
     */
    lobbyPeers = [];
    /**
     * @generated from field: optional string metadata = 5;
     */
    metadata;
    /**
     * @generated from field: required int64 startTime = 6;
     */
    startTime;
    constructor(data) {
      super();
      proto2.util.initPartial(data, this);
    }
    static runtime = proto2;
    static typeName = "RoomInfo";
    static fields = proto2.util.newFieldList(() => [
      { no: 1, name: "roomLocked", kind: "scalar", T: 8, req: true },
      { no: 2, name: "config", kind: "message", T: RoomControls, req: true },
      { no: 3, name: "peers", kind: "message", T: PeersInfo, repeated: true },
      { no: 4, name: "lobbyPeers", kind: "message", T: LobbyPeers, repeated: true },
      { no: 5, name: "metadata", kind: "scalar", T: 9, opt: true },
      { no: 6, name: "startTime", kind: "scalar", T: 3, req: true }
    ]);
    static fromBinary(bytes, options) {
      return new _RoomInfo().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _RoomInfo().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _RoomInfo().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto2.util.equals(_RoomInfo, a, b);
    }
  };
  var LobbyPeers = class _LobbyPeers extends Message {
    /**
     * @generated from field: required string peerId = 1;
     */
    peerId;
    /**
     * @generated from field: optional string metadata = 3;
     */
    metadata;
    constructor(data) {
      super();
      proto2.util.initPartial(data, this);
    }
    static runtime = proto2;
    static typeName = "LobbyPeers";
    static fields = proto2.util.newFieldList(() => [
      { no: 1, name: "peerId", kind: "scalar", T: 9, req: true },
      { no: 3, name: "metadata", kind: "scalar", T: 9, opt: true }
    ]);
    static fromBinary(bytes, options) {
      return new _LobbyPeers().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _LobbyPeers().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _LobbyPeers().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto2.util.equals(_LobbyPeers, a, b);
    }
  };
  var ConnectRoomResponse = class _ConnectRoomResponse extends Message {
    /**
     * @generated from field: required string roomId = 1;
     */
    roomId;
    /**
     * @generated from field: required RoomInfo roomInfo = 2;
     */
    roomInfo;
    /**
     * @generated from field: required ProtoRtpCapabilities routerRTPCapabilities = 3;
     */
    routerRTPCapabilities;
    /**
     * @generated from field: repeated ConnectRoomResponse.RTCIceServer turnServers = 4;
     */
    turnServers = [];
    constructor(data) {
      super();
      proto2.util.initPartial(data, this);
    }
    static runtime = proto2;
    static typeName = "ConnectRoomResponse";
    static fields = proto2.util.newFieldList(() => [
      { no: 1, name: "roomId", kind: "scalar", T: 9, req: true },
      { no: 2, name: "roomInfo", kind: "message", T: RoomInfo, req: true },
      { no: 3, name: "routerRTPCapabilities", kind: "message", T: ProtoRtpCapabilities, req: true },
      { no: 4, name: "turnServers", kind: "message", T: ConnectRoomResponse_RTCIceServer, repeated: true }
    ]);
    static fromBinary(bytes, options) {
      return new _ConnectRoomResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _ConnectRoomResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _ConnectRoomResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto2.util.equals(_ConnectRoomResponse, a, b);
    }
  };
  var ConnectRoomResponse_RTCIceServer = class _ConnectRoomResponse_RTCIceServer extends Message {
    /**
     * @generated from field: required string urls = 1;
     */
    urls;
    /**
     * @generated from field: optional string username = 2;
     */
    username;
    /**
     * @generated from field: optional string credential = 3;
     */
    credential;
    constructor(data) {
      super();
      proto2.util.initPartial(data, this);
    }
    static runtime = proto2;
    static typeName = "ConnectRoomResponse.RTCIceServer";
    static fields = proto2.util.newFieldList(() => [
      { no: 1, name: "urls", kind: "scalar", T: 9, req: true },
      { no: 2, name: "username", kind: "scalar", T: 9, opt: true },
      { no: 3, name: "credential", kind: "scalar", T: 9, opt: true }
    ]);
    static fromBinary(bytes, options) {
      return new _ConnectRoomResponse_RTCIceServer().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _ConnectRoomResponse_RTCIceServer().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _ConnectRoomResponse_RTCIceServer().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto2.util.equals(_ConnectRoomResponse_RTCIceServer, a, b);
    }
  };
  var CreateTransportOnClient = class _CreateTransportOnClient extends Message {
    /**
     * @generated from field: required string transportType = 1;
     */
    transportType;
    /**
     * @generated from field: required ProtoTransportSDPInfo transportSDPInfo = 2;
     */
    transportSDPInfo;
    constructor(data) {
      super();
      proto2.util.initPartial(data, this);
    }
    static runtime = proto2;
    static typeName = "CreateTransportOnClient";
    static fields = proto2.util.newFieldList(() => [
      { no: 1, name: "transportType", kind: "scalar", T: 9, req: true },
      { no: 2, name: "transportSDPInfo", kind: "message", T: ProtoTransportSDPInfo, req: true }
    ]);
    static fromBinary(bytes, options) {
      return new _CreateTransportOnClient().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _CreateTransportOnClient().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _CreateTransportOnClient().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto2.util.equals(_CreateTransportOnClient, a, b);
    }
  };
  var ConnectTransportResponse = class _ConnectTransportResponse extends Message {
    /**
     * @generated from field: required string transportType = 1;
     */
    transportType;
    /**
     * @generated from field: required string transportId = 2;
     */
    transportId;
    constructor(data) {
      super();
      proto2.util.initPartial(data, this);
    }
    static runtime = proto2;
    static typeName = "ConnectTransportResponse";
    static fields = proto2.util.newFieldList(() => [
      { no: 1, name: "transportType", kind: "scalar", T: 9, req: true },
      { no: 2, name: "transportId", kind: "scalar", T: 9, req: true }
    ]);
    static fromBinary(bytes, options) {
      return new _ConnectTransportResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _ConnectTransportResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _ConnectTransportResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto2.util.equals(_ConnectTransportResponse, a, b);
    }
  };
  var ProduceResponse = class _ProduceResponse extends Message {
    /**
     * @generated from field: required string peerId = 1;
     */
    peerId;
    /**
     * @generated from field: required string producerId = 2;
     */
    producerId;
    /**
     * @generated from field: required string label = 3;
     */
    label;
    /**
     * @generated from field: optional AppData appData = 4;
     */
    appData;
    constructor(data) {
      super();
      proto2.util.initPartial(data, this);
    }
    static runtime = proto2;
    static typeName = "ProduceResponse";
    static fields = proto2.util.newFieldList(() => [
      { no: 1, name: "peerId", kind: "scalar", T: 9, req: true },
      { no: 2, name: "producerId", kind: "scalar", T: 9, req: true },
      { no: 3, name: "label", kind: "scalar", T: 9, req: true },
      { no: 4, name: "appData", kind: "message", T: AppData, opt: true }
    ]);
    static fromBinary(bytes, options) {
      return new _ProduceResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _ProduceResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _ProduceResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto2.util.equals(_ProduceResponse, a, b);
    }
  };
  var ProduceDataResponse = class _ProduceDataResponse extends Message {
    /**
     * @generated from field: required string id = 1;
     */
    id;
    /**
     * @generated from field: required string dataProducerId = 2;
     */
    dataProducerId;
    /**
     * @generated from field: required string label = 3;
     */
    label;
    /**
     * @generated from field: required string peerId = 4;
     */
    peerId;
    /**
     * @generated from field: required string protocol = 5;
     */
    protocol;
    /**
     * @generated from field: required ProtoSctpStreamParameters sctpStreamParameters = 6;
     */
    sctpStreamParameters;
    /**
     * @generated from field: optional AppData appData = 7;
     */
    appData;
    constructor(data) {
      super();
      proto2.util.initPartial(data, this);
    }
    static runtime = proto2;
    static typeName = "ProduceDataResponse";
    static fields = proto2.util.newFieldList(() => [
      { no: 1, name: "id", kind: "scalar", T: 9, req: true },
      { no: 2, name: "dataProducerId", kind: "scalar", T: 9, req: true },
      { no: 3, name: "label", kind: "scalar", T: 9, req: true },
      { no: 4, name: "peerId", kind: "scalar", T: 9, req: true },
      { no: 5, name: "protocol", kind: "scalar", T: 9, req: true },
      { no: 6, name: "sctpStreamParameters", kind: "message", T: ProtoSctpStreamParameters, req: true },
      { no: 7, name: "appData", kind: "message", T: AppData, opt: true }
    ]);
    static fromBinary(bytes, options) {
      return new _ProduceDataResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _ProduceDataResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _ProduceDataResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto2.util.equals(_ProduceDataResponse, a, b);
    }
  };
  var ConsumeDataResponse = class _ConsumeDataResponse extends Message {
    /**
     * @generated from field: required string id = 1;
     */
    id;
    /**
     * @generated from field: required string dataProducerId = 2;
     */
    dataProducerId;
    /**
     * @generated from field: required string label = 3;
     */
    label;
    /**
     * @generated from field: required string peerId = 4;
     */
    peerId;
    /**
     * @generated from field: required string protocol = 5;
     */
    protocol;
    /**
     * @generated from field: required ProtoSctpStreamParameters sctpStreamParameters = 6;
     */
    sctpStreamParameters;
    /**
     * @generated from field: optional AppData appData = 7;
     */
    appData;
    constructor(data) {
      super();
      proto2.util.initPartial(data, this);
    }
    static runtime = proto2;
    static typeName = "ConsumeDataResponse";
    static fields = proto2.util.newFieldList(() => [
      { no: 1, name: "id", kind: "scalar", T: 9, req: true },
      { no: 2, name: "dataProducerId", kind: "scalar", T: 9, req: true },
      { no: 3, name: "label", kind: "scalar", T: 9, req: true },
      { no: 4, name: "peerId", kind: "scalar", T: 9, req: true },
      { no: 5, name: "protocol", kind: "scalar", T: 9, req: true },
      { no: 6, name: "sctpStreamParameters", kind: "message", T: ProtoSctpStreamParameters, req: true },
      { no: 7, name: "appData", kind: "message", T: AppData, opt: true }
    ]);
    static fromBinary(bytes, options) {
      return new _ConsumeDataResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _ConsumeDataResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _ConsumeDataResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto2.util.equals(_ConsumeDataResponse, a, b);
    }
  };
  var SyncMeetingStateResponse = class _SyncMeetingStateResponse extends Message {
    /**
     * @generated from field: required RoomInfo roomInfo = 1;
     */
    roomInfo;
    constructor(data) {
      super();
      proto2.util.initPartial(data, this);
    }
    static runtime = proto2;
    static typeName = "SyncMeetingStateResponse";
    static fields = proto2.util.newFieldList(() => [
      { no: 1, name: "roomInfo", kind: "message", T: RoomInfo, req: true }
    ]);
    static fromBinary(bytes, options) {
      return new _SyncMeetingStateResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _SyncMeetingStateResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _SyncMeetingStateResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto2.util.equals(_SyncMeetingStateResponse, a, b);
    }
  };
  var ConsumeResponse = class _ConsumeResponse extends Message {
    /**
     * @generated from field: required string label = 1;
     */
    label;
    /**
     * @generated from field: required string consumerId = 2;
     */
    consumerId;
    /**
     * @generated from field: required string producerId = 3;
     */
    producerId;
    /**
     * @generated from field: required string kind = 4;
     */
    kind;
    /**
     * @generated from field: required ProtoRtpParameters rtpParameters = 5;
     */
    rtpParameters;
    /**
     * @generated from field: required string producerPeerId = 6;
     */
    producerPeerId;
    /**
     * @generated from field: optional AppData appData = 7;
     */
    appData;
    /**
     * @generated from field: optional bool producerPaused = 8;
     */
    producerPaused;
    constructor(data) {
      super();
      proto2.util.initPartial(data, this);
    }
    static runtime = proto2;
    static typeName = "ConsumeResponse";
    static fields = proto2.util.newFieldList(() => [
      { no: 1, name: "label", kind: "scalar", T: 9, req: true },
      { no: 2, name: "consumerId", kind: "scalar", T: 9, req: true },
      { no: 3, name: "producerId", kind: "scalar", T: 9, req: true },
      { no: 4, name: "kind", kind: "scalar", T: 9, req: true },
      { no: 5, name: "rtpParameters", kind: "message", T: ProtoRtpParameters, req: true },
      { no: 6, name: "producerPeerId", kind: "scalar", T: 9, req: true },
      { no: 7, name: "appData", kind: "message", T: AppData, opt: true },
      { no: 8, name: "producerPaused", kind: "scalar", T: 8, opt: true }
    ]);
    static fromBinary(bytes, options) {
      return new _ConsumeResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _ConsumeResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _ConsumeResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto2.util.equals(_ConsumeResponse, a, b);
    }
  };
  var CloseProducerSuccess = class _CloseProducerSuccess extends Message {
    /**
     * @generated from field: required string peerId = 1;
     */
    peerId;
    /**
     * @generated from field: required string producerId = 2;
     */
    producerId;
    /**
     * @generated from field: required string label = 3;
     */
    label;
    constructor(data) {
      super();
      proto2.util.initPartial(data, this);
    }
    static runtime = proto2;
    static typeName = "CloseProducerSuccess";
    static fields = proto2.util.newFieldList(() => [
      { no: 1, name: "peerId", kind: "scalar", T: 9, req: true },
      { no: 2, name: "producerId", kind: "scalar", T: 9, req: true },
      { no: 3, name: "label", kind: "scalar", T: 9, req: true }
    ]);
    static fromBinary(bytes, options) {
      return new _CloseProducerSuccess().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _CloseProducerSuccess().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _CloseProducerSuccess().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto2.util.equals(_CloseProducerSuccess, a, b);
    }
  };
  var PauseProducerSuccess = class _PauseProducerSuccess extends Message {
    /**
     * @generated from field: required string peerId = 1;
     */
    peerId;
    /**
     * @generated from field: required string producerId = 2;
     */
    producerId;
    /**
     * @generated from field: required string label = 3;
     */
    label;
    constructor(data) {
      super();
      proto2.util.initPartial(data, this);
    }
    static runtime = proto2;
    static typeName = "PauseProducerSuccess";
    static fields = proto2.util.newFieldList(() => [
      { no: 1, name: "peerId", kind: "scalar", T: 9, req: true },
      { no: 2, name: "producerId", kind: "scalar", T: 9, req: true },
      { no: 3, name: "label", kind: "scalar", T: 9, req: true }
    ]);
    static fromBinary(bytes, options) {
      return new _PauseProducerSuccess().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _PauseProducerSuccess().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _PauseProducerSuccess().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto2.util.equals(_PauseProducerSuccess, a, b);
    }
  };
  var ResumeProducerSuccess = class _ResumeProducerSuccess extends Message {
    /**
     * @generated from field: required string peerId = 1;
     */
    peerId;
    /**
     * @generated from field: required string producerId = 2;
     */
    producerId;
    /**
     * @generated from field: required string label = 3;
     */
    label;
    constructor(data) {
      super();
      proto2.util.initPartial(data, this);
    }
    static runtime = proto2;
    static typeName = "ResumeProducerSuccess";
    static fields = proto2.util.newFieldList(() => [
      { no: 1, name: "peerId", kind: "scalar", T: 9, req: true },
      { no: 2, name: "producerId", kind: "scalar", T: 9, req: true },
      { no: 3, name: "label", kind: "scalar", T: 9, req: true }
    ]);
    static fromBinary(bytes, options) {
      return new _ResumeProducerSuccess().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _ResumeProducerSuccess().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _ResumeProducerSuccess().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto2.util.equals(_ResumeProducerSuccess, a, b);
    }
  };
  var CloseConsumerSuccess = class _CloseConsumerSuccess extends Message {
    /**
     * @generated from field: required string peerId = 1;
     */
    peerId;
    /**
     * @generated from field: required string consumerId = 2;
     */
    consumerId;
    constructor(data) {
      super();
      proto2.util.initPartial(data, this);
    }
    static runtime = proto2;
    static typeName = "CloseConsumerSuccess";
    static fields = proto2.util.newFieldList(() => [
      { no: 1, name: "peerId", kind: "scalar", T: 9, req: true },
      { no: 2, name: "consumerId", kind: "scalar", T: 9, req: true }
    ]);
    static fromBinary(bytes, options) {
      return new _CloseConsumerSuccess().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _CloseConsumerSuccess().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _CloseConsumerSuccess().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto2.util.equals(_CloseConsumerSuccess, a, b);
    }
  };
  var RestartTransportIceResponse = class _RestartTransportIceResponse extends Message {
    /**
     * @generated from field: required string transportType = 1;
     */
    transportType;
    /**
     * @generated from field: required ProtoIceParameters iceParameters = 2;
     */
    iceParameters;
    constructor(data) {
      super();
      proto2.util.initPartial(data, this);
    }
    static runtime = proto2;
    static typeName = "RestartTransportIceResponse";
    static fields = proto2.util.newFieldList(() => [
      { no: 1, name: "transportType", kind: "scalar", T: 9, req: true },
      { no: 2, name: "iceParameters", kind: "message", T: ProtoIceParameters, req: true }
    ]);
    static fromBinary(bytes, options) {
      return new _RestartTransportIceResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _RestartTransportIceResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _RestartTransportIceResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto2.util.equals(_RestartTransportIceResponse, a, b);
    }
  };
  var NewPeerJoined = class _NewPeerJoined extends Message {
    /**
     * @generated from field: required string peerId = 1;
     */
    peerId;
    /**
     * @generated from field: optional string metadata = 2;
     */
    metadata;
    /**
     * @generated from field: optional string role = 3;
     */
    role;
    constructor(data) {
      super();
      proto2.util.initPartial(data, this);
    }
    static runtime = proto2;
    static typeName = "NewPeerJoined";
    static fields = proto2.util.newFieldList(() => [
      { no: 1, name: "peerId", kind: "scalar", T: 9, req: true },
      { no: 2, name: "metadata", kind: "scalar", T: 9, opt: true },
      { no: 3, name: "role", kind: "scalar", T: 9, opt: true }
    ]);
    static fromBinary(bytes, options) {
      return new _NewPeerJoined().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _NewPeerJoined().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _NewPeerJoined().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto2.util.equals(_NewPeerJoined, a, b);
    }
  };
  var NewLobbyPeer = class _NewLobbyPeer extends Message {
    /**
     * @generated from field: required string peerId = 1;
     */
    peerId;
    /**
     * @generated from field: optional string metadata = 2;
     */
    metadata;
    constructor(data) {
      super();
      proto2.util.initPartial(data, this);
    }
    static runtime = proto2;
    static typeName = "NewLobbyPeer";
    static fields = proto2.util.newFieldList(() => [
      { no: 1, name: "peerId", kind: "scalar", T: 9, req: true },
      { no: 2, name: "metadata", kind: "scalar", T: 9, opt: true }
    ]);
    static fromBinary(bytes, options) {
      return new _NewLobbyPeer().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _NewLobbyPeer().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _NewLobbyPeer().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto2.util.equals(_NewLobbyPeer, a, b);
    }
  };
  var NewPermissions = class _NewPermissions extends Message {
    /**
     * @generated from field: required Permissions acl = 2;
     */
    acl;
    constructor(data) {
      super();
      proto2.util.initPartial(data, this);
    }
    static runtime = proto2;
    static typeName = "NewPermissions";
    static fields = proto2.util.newFieldList(() => [
      { no: 2, name: "acl", kind: "message", T: Permissions, req: true }
    ]);
    static fromBinary(bytes, options) {
      return new _NewPermissions().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _NewPermissions().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _NewPermissions().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto2.util.equals(_NewPermissions, a, b);
    }
  };
  var NewRoomControls = class _NewRoomControls extends Message {
    /**
     * @generated from field: required RoomControls controls = 1;
     */
    controls;
    constructor(data) {
      super();
      proto2.util.initPartial(data, this);
    }
    static runtime = proto2;
    static typeName = "NewRoomControls";
    static fields = proto2.util.newFieldList(() => [
      { no: 1, name: "controls", kind: "message", T: RoomControls, req: true }
    ]);
    static fromBinary(bytes, options) {
      return new _NewRoomControls().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _NewRoomControls().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _NewRoomControls().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto2.util.equals(_NewRoomControls, a, b);
    }
  };
  var NewPeerRole = class _NewPeerRole extends Message {
    /**
     * @generated from field: required string peerId = 1;
     */
    peerId;
    /**
     * @generated from field: required string role = 2;
     */
    role;
    constructor(data) {
      super();
      proto2.util.initPartial(data, this);
    }
    static runtime = proto2;
    static typeName = "NewPeerRole";
    static fields = proto2.util.newFieldList(() => [
      { no: 1, name: "peerId", kind: "scalar", T: 9, req: true },
      { no: 2, name: "role", kind: "scalar", T: 9, req: true }
    ]);
    static fromBinary(bytes, options) {
      return new _NewPeerRole().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _NewPeerRole().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _NewPeerRole().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto2.util.equals(_NewPeerRole, a, b);
    }
  };
  var ReceiveData = class _ReceiveData extends Message {
    /**
     * @generated from field: required string from = 1;
     */
    from;
    /**
     * @generated from field: required string payload = 2;
     */
    payload;
    /**
     * @generated from field: optional string label = 3;
     */
    label;
    constructor(data) {
      super();
      proto2.util.initPartial(data, this);
    }
    static runtime = proto2;
    static typeName = "ReceiveData";
    static fields = proto2.util.newFieldList(() => [
      { no: 1, name: "from", kind: "scalar", T: 9, req: true },
      { no: 2, name: "payload", kind: "scalar", T: 9, req: true },
      { no: 3, name: "label", kind: "scalar", T: 9, opt: true }
    ]);
    static fromBinary(bytes, options) {
      return new _ReceiveData().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _ReceiveData().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _ReceiveData().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto2.util.equals(_ReceiveData, a, b);
    }
  };
  var PeerMetadataUpdated = class _PeerMetadataUpdated extends Message {
    /**
     * @generated from field: required string peerId = 1;
     */
    peerId;
    /**
     * @generated from field: required string metadata = 2;
     */
    metadata;
    constructor(data) {
      super();
      proto2.util.initPartial(data, this);
    }
    static runtime = proto2;
    static typeName = "PeerMetadataUpdated";
    static fields = proto2.util.newFieldList(() => [
      { no: 1, name: "peerId", kind: "scalar", T: 9, req: true },
      { no: 2, name: "metadata", kind: "scalar", T: 9, req: true }
    ]);
    static fromBinary(bytes, options) {
      return new _PeerMetadataUpdated().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _PeerMetadataUpdated().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _PeerMetadataUpdated().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto2.util.equals(_PeerMetadataUpdated, a, b);
    }
  };
  var RoomMetadataUpdated = class _RoomMetadataUpdated extends Message {
    /**
     * @generated from field: required string metadata = 1;
     */
    metadata;
    constructor(data) {
      super();
      proto2.util.initPartial(data, this);
    }
    static runtime = proto2;
    static typeName = "RoomMetadataUpdated";
    static fields = proto2.util.newFieldList(() => [
      { no: 1, name: "metadata", kind: "scalar", T: 9, req: true }
    ]);
    static fromBinary(bytes, options) {
      return new _RoomMetadataUpdated().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _RoomMetadataUpdated().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _RoomMetadataUpdated().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto2.util.equals(_RoomMetadataUpdated, a, b);
    }
  };
  var RoomClosedProducers = class _RoomClosedProducers extends Message {
    /**
     * @generated from field: repeated RoomClosedProducers.CloseProducerInfo producers = 1;
     */
    producers = [];
    /**
     * @generated from field: required RoomClosedProducers.CloseProducerReason reason = 2;
     */
    reason;
    constructor(data) {
      super();
      proto2.util.initPartial(data, this);
    }
    static runtime = proto2;
    static typeName = "RoomClosedProducers";
    static fields = proto2.util.newFieldList(() => [
      { no: 1, name: "producers", kind: "message", T: RoomClosedProducers_CloseProducerInfo, repeated: true },
      { no: 2, name: "reason", kind: "message", T: RoomClosedProducers_CloseProducerReason, req: true }
    ]);
    static fromBinary(bytes, options) {
      return new _RoomClosedProducers().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _RoomClosedProducers().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _RoomClosedProducers().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto2.util.equals(_RoomClosedProducers, a, b);
    }
  };
  var RoomClosedProducers_CloseProducerInfo = class _RoomClosedProducers_CloseProducerInfo extends Message {
    /**
     * @generated from field: required string peerId = 1;
     */
    peerId;
    /**
     * @generated from field: required string producerId = 2;
     */
    producerId;
    /**
     * @generated from field: required string label = 3;
     */
    label;
    constructor(data) {
      super();
      proto2.util.initPartial(data, this);
    }
    static runtime = proto2;
    static typeName = "RoomClosedProducers.CloseProducerInfo";
    static fields = proto2.util.newFieldList(() => [
      { no: 1, name: "peerId", kind: "scalar", T: 9, req: true },
      { no: 2, name: "producerId", kind: "scalar", T: 9, req: true },
      { no: 3, name: "label", kind: "scalar", T: 9, req: true }
    ]);
    static fromBinary(bytes, options) {
      return new _RoomClosedProducers_CloseProducerInfo().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _RoomClosedProducers_CloseProducerInfo().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _RoomClosedProducers_CloseProducerInfo().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto2.util.equals(_RoomClosedProducers_CloseProducerInfo, a, b);
    }
  };
  var RoomClosedProducers_CloseProducerReason = class _RoomClosedProducers_CloseProducerReason extends Message {
    /**
     * @generated from field: required int32 code = 1;
     */
    code;
    /**
     * @generated from field: required string tag = 2;
     */
    tag;
    /**
     * @generated from field: required string message = 3;
     */
    message;
    constructor(data) {
      super();
      proto2.util.initPartial(data, this);
    }
    static runtime = proto2;
    static typeName = "RoomClosedProducers.CloseProducerReason";
    static fields = proto2.util.newFieldList(() => [
      { no: 1, name: "code", kind: "scalar", T: 5, req: true },
      { no: 2, name: "tag", kind: "scalar", T: 9, req: true },
      { no: 3, name: "message", kind: "scalar", T: 9, req: true }
    ]);
    static fromBinary(bytes, options) {
      return new _RoomClosedProducers_CloseProducerReason().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _RoomClosedProducers_CloseProducerReason().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _RoomClosedProducers_CloseProducerReason().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto2.util.equals(_RoomClosedProducers_CloseProducerReason, a, b);
    }
  };
  var PeerLeft = class _PeerLeft extends Message {
    /**
     * @generated from field: required string peerId = 1;
     */
    peerId;
    constructor(data) {
      super();
      proto2.util.initPartial(data, this);
    }
    static runtime = proto2;
    static typeName = "PeerLeft";
    static fields = proto2.util.newFieldList(() => [
      { no: 1, name: "peerId", kind: "scalar", T: 9, req: true }
    ]);
    static fromBinary(bytes, options) {
      return new _PeerLeft().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _PeerLeft().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _PeerLeft().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto2.util.equals(_PeerLeft, a, b);
    }
  };
  var LobbyPeerLeft = class _LobbyPeerLeft extends Message {
    /**
     * @generated from field: required string peerId = 1;
     */
    peerId;
    /**
     * @generated from field: required string status = 2;
     */
    status;
    /**
     * @generated from field: optional string message = 3;
     */
    message;
    constructor(data) {
      super();
      proto2.util.initPartial(data, this);
    }
    static runtime = proto2;
    static typeName = "LobbyPeerLeft";
    static fields = proto2.util.newFieldList(() => [
      { no: 1, name: "peerId", kind: "scalar", T: 9, req: true },
      { no: 2, name: "status", kind: "scalar", T: 9, req: true },
      { no: 3, name: "message", kind: "scalar", T: 9, opt: true }
    ]);
    static fromBinary(bytes, options) {
      return new _LobbyPeerLeft().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _LobbyPeerLeft().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _LobbyPeerLeft().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto2.util.equals(_LobbyPeerLeft, a, b);
    }
  };
  var WaitingRoom = class _WaitingRoom extends Message {
    /**
     * @generated from field: required string reason = 1;
     */
    reason;
    /**
     * @generated from field: optional string metadata = 2;
     */
    metadata;
    constructor(data) {
      super();
      proto2.util.initPartial(data, this);
    }
    static runtime = proto2;
    static typeName = "WaitingRoom";
    static fields = proto2.util.newFieldList(() => [
      { no: 1, name: "reason", kind: "scalar", T: 9, req: true },
      { no: 2, name: "metadata", kind: "scalar", T: 9, opt: true }
    ]);
    static fromBinary(bytes, options) {
      return new _WaitingRoom().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _WaitingRoom().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _WaitingRoom().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto2.util.equals(_WaitingRoom, a, b);
    }
  };
  var Error2 = class _Error extends Message {
    /**
     * @generated from field: required string event = 1;
     */
    event;
    /**
     * @generated from field: required string error = 2;
     */
    error;
    constructor(data) {
      super();
      proto2.util.initPartial(data, this);
    }
    static runtime = proto2;
    static typeName = "Error";
    static fields = proto2.util.newFieldList(() => [
      { no: 1, name: "event", kind: "scalar", T: 9, req: true },
      { no: 2, name: "error", kind: "scalar", T: 9, req: true }
    ]);
    static fromBinary(bytes, options) {
      return new _Error().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _Error().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _Error().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto2.util.equals(_Error, a, b);
    }
  };
  var Response = class _Response extends Message {
    /**
     * @generated from oneof Response.Response
     */
    Response = { case: void 0 };
    constructor(data) {
      super();
      proto2.util.initPartial(data, this);
    }
    static runtime = proto2;
    static typeName = "Response";
    static fields = proto2.util.newFieldList(() => [
      { no: 1, name: "hello", kind: "message", T: Hello, oneof: "Response" },
      { no: 2, name: "connectRoomResponse", kind: "message", T: ConnectRoomResponse, oneof: "Response" },
      { no: 3, name: "createTransportOnClient", kind: "message", T: CreateTransportOnClient, oneof: "Response" },
      { no: 4, name: "produceResponse", kind: "message", T: ProduceResponse, oneof: "Response" },
      { no: 25, name: "consumeDataResponse", kind: "message", T: ConsumeDataResponse, oneof: "Response" },
      { no: 5, name: "produceDataResponse", kind: "message", T: ProduceDataResponse, oneof: "Response" },
      { no: 6, name: "syncMeetingStateResponse", kind: "message", T: SyncMeetingStateResponse, oneof: "Response" },
      { no: 7, name: "consumeResponse", kind: "message", T: ConsumeResponse, oneof: "Response" },
      { no: 8, name: "closeProducerSuccess", kind: "message", T: CloseProducerSuccess, oneof: "Response" },
      { no: 26, name: "pauseProducerSuccess", kind: "message", T: PauseProducerSuccess, oneof: "Response" },
      { no: 27, name: "resumeProducerSuccess", kind: "message", T: ResumeProducerSuccess, oneof: "Response" },
      { no: 9, name: "closeConsumerSuccess", kind: "message", T: CloseConsumerSuccess, oneof: "Response" },
      { no: 10, name: "connectTransportResponse", kind: "message", T: ConnectTransportResponse, oneof: "Response" },
      { no: 11, name: "restartTransportIceResponse", kind: "message", T: RestartTransportIceResponse, oneof: "Response" },
      { no: 12, name: "newPeerJoined", kind: "message", T: NewPeerJoined, oneof: "Response" },
      { no: 13, name: "newLobbyPeer", kind: "message", T: NewLobbyPeer, oneof: "Response" },
      { no: 14, name: "newPermissions", kind: "message", T: NewPermissions, oneof: "Response" },
      { no: 15, name: "newRoomControls", kind: "message", T: NewRoomControls, oneof: "Response" },
      { no: 16, name: "newPeerRole", kind: "message", T: NewPeerRole, oneof: "Response" },
      { no: 17, name: "receiveData", kind: "message", T: ReceiveData, oneof: "Response" },
      { no: 18, name: "peerMetadataUpdated", kind: "message", T: PeerMetadataUpdated, oneof: "Response" },
      { no: 19, name: "roomMetadataUpdated", kind: "message", T: RoomMetadataUpdated, oneof: "Response" },
      { no: 20, name: "roomClosedProducers", kind: "message", T: RoomClosedProducers, oneof: "Response" },
      { no: 21, name: "peerLeft", kind: "message", T: PeerLeft, oneof: "Response" },
      { no: 22, name: "lobbyPeerLeft", kind: "message", T: LobbyPeerLeft, oneof: "Response" },
      { no: 23, name: "waitingRoom", kind: "message", T: WaitingRoom, oneof: "Response" },
      { no: 24, name: "error", kind: "message", T: Error2, oneof: "Response" }
    ]);
    static fromBinary(bytes, options) {
      return new _Response().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _Response().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _Response().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto2.util.equals(_Response, a, b);
    }
  };

  // src/request.events.ts
  var ProtoRequestEvent = {
    acceptLobbyPeer: AcceptLobbyPeer,
    activateSpeakerNotification: ActivateSpeakerNotification,
    createDataConsumer: CreateDataConsumer,
    closeConsumer: CloseConsumer,
    pauseProducer: PauseProducer,
    resumeProducer: ResumeProducer,
    closeProducer: CloseProducer,
    closeRoom: CloseRoom,
    connectRoom: ConnectRoom,
    closeStreamOfLabel: CloseStreamOfLabel,
    connectTransport: ConnectTransport,
    consume: Consume,
    createTransport: CreateTransport,
    denyLobbyPeer: DenyLobbyPeer,
    kickPeer: KickPeer,
    produce: Produce,
    produceData: ProduceData,
    restartTransportIce: RestartTransportIce,
    resumeConsumer: ResumeConsumer,
    sendData: SendData,
    syncMeetingState: SyncMeetingState,
    updatePeerMetadata: UpdatePeerMetadata,
    updatePeerPermission: UpdatePeerPermission,
    updatePeerRole: UpdatePeerRole,
    updateRoomControls: UpdateRoomControls,
    updateRoomMetadata: UpdateRoomMetadata
  };

  // src/helpers/apiUtils.ts
  var logger2 = mainLogger.createSubLogger("apiUtils");
  var defaultRetryConfig = {
    maxRetries: 3,
    initialDelay: 1e3,
    factor: 2,
    jitter: true
  };
  var RetryAbortError = class extends Error {
    constructor(message) {
      super(message);
      this.name = "RetryAbortError";
    }
  };
  async function apiCallWithRetry(apiCall, config = {}, abortSignal) {
    const retryConfig = {
      ...defaultRetryConfig,
      ...config
    };
    let delay = retryConfig.initialDelay ?? defaultRetryConfig.initialDelay;
    for (let attempt = 0; attempt <= retryConfig.maxRetries; attempt++) {
      try {
        if (abortSignal?.aborted) ;
        return await apiCall();
      } catch (error) {
        if (error instanceof RetryAbortError) {
          logger2.warn("API call aborted", error);
          throw error;
        }
        if (attempt === retryConfig.maxRetries) {
          logger2.error(
            `API call failed after ${retryConfig.maxRetries} retries`,
            error
          );
          throw error;
        }
        logger2.warn(`API call attempt ${attempt + 1} failed. Retrying...`, error);
        const factor = retryConfig.factor ?? defaultRetryConfig.factor;
        if (retryConfig.jitter) {
          delay = Math.random() * delay * (factor ?? 2);
        } else {
          delay *= factor;
        }
        await new Promise((resolve, reject) => {
          setTimeout(resolve, delay);
        });
      }
    }
    throw new Error("Unexpected error: all retries exhausted");
  }

  // package.json
  var package_default = {
    name: "@huddle01/web-core",
    version: "2.2.4",
    description: "The Huddle01 Javascript SDK offers a comprehensive suite of methods and event listeners that allow for seamless real-time audio and video communication with minimal coding required.",
    type: "module",
    main: "dist/index.js",
    types: "dist/index.d.ts",
    files: ["dist", "types.d.ts"],
    scripts: {
      build: "rimraf dist && tsup --format esm,cjs",
      "build:umd": "rimraf dist && tsup",
      watch: "tsup --watch",
      pub: "bun run build && npm publish --access public",
      "pub:umd": "bun run build:umd && npm publish --access public --tag umd",
      "pub:dev": "bun run build && npm publish --access public --tag dev",
      "pub:alpha": "bun run build && npm publish --access public --tag alpha",
      "pub:beta": "bun run build && npm publish --access public --tag beta",
      test: "vitest",
      "test:types": "vitest typecheck"
    },
    exports: {
      ".": {
        import: "./dist/index.js",
        types: "./dist/index.d.ts"
      },
      "./types": {
        import: "./dist/types/index.js",
        types: "./dist/types/index.d.ts"
      }
    },
    keywords: ["huddle01", "web-core", "RTC", "web3"],
    author: "a4748g",
    license: "ISC",
    devDependencies: {
      "@vitest/browser": "^2.1.2",
      esbuild: "^0.24.0",
      jsdom: "^25.0.1",
      protoc: "workspace:*",
      tsconfig: "workspace:*",
      tsup: "^8.3.0",
      types: "workspace:*",
      typescript: "5.6.2",
      vitest: "^2.1.2",
      webdriverio: "^9.1.3"
    },
    dependencies: {
      "mediasoup-client": "3.7.16",
      zod: "^3.23.8"
    }
  };

  // src/Socket.ts
  var logger3 = mainLogger.createSubLogger("Socket.ts");
  var Socket = class _Socket extends EnhancedEventEmitter {
    /**
     * Socket Instance, Singleton class
     */
    static __instance = null;
    /**
     * Retry count for the socket connection, if the connection is closed abnormally, we try to reconnect 5 times
     */
    __retryCount = 0;
    /**
     * Current connection state of the socket connection
     */
    __connectionState = "uninitialized";
    /**
     * websocket polyfill
     */
    __wsPolyfill;
    /**
     * Underlying WebSocket connection, until we dont call Socket.connect(); this will be null
     */
    __ws = null;
    /**
     * Map of all the subscribed events/topics for the socket connection
     */
    __subscribedMap = /* @__PURE__ */ new Map();
    /**
     * Geo data of the current socket connection, specific to the Local Peer who joined the meeting
     */
    __geoData = null;
    /**
     * Endpoint of the socket server, this is fetched from the API server
     */
    __ENDPOINT = null;
    /**
     * Flag to enable local development
     */
    isLocalDev = false;
    /**
     * Token of the current socket connection, specific to the Local Peer who joined the meeting
     */
    token = null;
    /**
     * Returns the underlying WebSocket connection, throws an error if the connection is not initialized
     * @throws `Error` if the connection is not initialized
     */
    get ws() {
      if (!this.__ws) {
        throw new Error("\u{1F534} Socket Not Initialised");
      }
      return this.__ws;
    }
    /**
     * Getter for the region of the current socket connection
     */
    get region() {
      return this.__geoData?.region;
    }
    /**
     * Getter for the geo data of the current socket connection
     */
    get geoData() {
      return this.__geoData;
    }
    /**
     * Returns the current connection state of the socket connection
     */
    get connectionState() {
      return this.__connectionState;
    }
    /**
     * Returns true if the socket connection is connected
     */
    get connected() {
      return this.__ws?.OPEN === 1 && this.connectionState === "connected";
    }
    /**
     * Returns true if the socket connection is connecting
     */
    get connecting() {
      return this.__ws?.CONNECTING === 0 && this.connectionState === "connecting";
    }
    /**
     * Returns true if the socket connection is closed
     */
    get closed() {
      return this.__ws?.CLOSED === 3 || this.__ws?.CLOSING === 2;
    }
    /**
     * Sets the current connection state of the socket connection
     */
    set connectionState(state) {
      logger3.info(`\u{1F50C} WebSocket state changed to ${state}`);
      this.__connectionState = state;
    }
    /**
     * Update the token for this socket
     * @throws `Error` if the token is already set
     */
    setToken(token) {
      if (this.token) {
        throw new Error("\u{1F534} Token Already Set");
      }
      this.token = token;
      this.emit("token-updated", token);
    }
    /**
     * Set a new region for the socket connection
     */
    setRegion(region) {
      if (this.geoData) {
        this.geoData.region = region;
      } else {
        this.__geoData = {
          country: "IN",
          region
        };
      }
      this.emit("region-updated", region);
    }
    /**
     * @protected - For Internal Use Only
     */
    enableLocalDev = () => {
      this.isLocalDev = true;
    };
    /**
     * Creates the socket and returns the instance of the socket if already initialized
     * you need to call connect method to connect to the server
     * @param data
     * @returns
     */
    static create(wsPolyfill) {
      if (!_Socket.__instance) {
        _Socket.__instance = new _Socket(wsPolyfill);
      }
      return _Socket.__instance;
    }
    /**
     * Returns the instance of the socket connection, throws an error if the connection is not initialized
     * @throws `Error` if the connection is not initialized
     */
    static getInstance() {
      if (!_Socket.__instance) {
        throw new Error(
          "\u{1F534} Socket Instance Not Initialised, You are trying to do something which is not possible"
        );
      }
      return _Socket.__instance;
    }
    constructor(wsPolyfill) {
      super();
      this.__wsPolyfill = wsPolyfill || null;
    }
    /**
     *
     */
    __getGeoData = async () => {
      const fn = async () => {
        const resp = await fetch(
          "https://shinigami.huddle01.com/api/get-geolocation"
        );
        const data = await resp?.json();
        const geolocationdata = GeolocationSchema.safeParse(data);
        if (!geolocationdata.success) {
          throw new Error("\u{1F534} Error While Finding the Region to connect to");
        }
        return {
          region: geolocationdata.data.globalRegion,
          country: geolocationdata.data.country
        };
      };
      return apiCallWithRetry(fn);
    };
    /**
     * Connect to the socket server using the token, this will establish the connection with the server
     *
     * Every `token` is unique for each New Peer Trying to connect. Reusing the token will result in an repeated connection error, until the connection is closed.
     * @param data - `{ token: string }`
     * @throws `Error` if the socket connection cannot be established
     */
    connect = async (data) => {
      if (!_Socket.__instance) {
        throw new Error("\u{1F534} Socket Instance Not Initialised");
      }
      if (!this.token) {
        this.setToken(data.token);
      }
      if (this.connectionState === "connected") {
        logger3.error("\u{1F534} Socket Already Connected");
        return _Socket.__instance;
      }
      if (this.connectionState === "connecting") {
        logger3.error("\u{1F534} Socket Already Connecting");
        return _Socket.__instance;
      }
      if (this.__ws) {
        logger3.error("\u{1F534} Socket Already Initialized");
        return _Socket.__instance;
      }
      logger3.info("\u{1F50C} Connecting to the socket server");
      if (!this.__geoData) {
        const geoData = await this.__getGeoData();
        this.__geoData = geoData;
      }
      const url = await this.__getConfigUrl(
        data.token,
        this.__geoData.region,
        this.__geoData.country
      );
      this.connectionState = "connecting";
      this.emit("connecting");
      if (this.__wsPolyfill) this.__ws = new this.__wsPolyfill(url);
      else this.__ws = new WebSocket(url);
      this.__ws.binaryType = "arraybuffer";
      this.__ws.onmessage = this.__handleIncomingMessage;
      this.__registerSocketEvents(this.ws);
      const socketConnectionPromise = new Promise((resolve, reject) => {
        const handleSuccess = () => {
          logger3.info("\u2705 WebSocket Connection Established Promise Resolved");
          handleRemoveListeners();
          resolve();
        };
        const handleClose = () => {
          logger3.error(
            "\u{1F534} Error Connecting WebSocket, Closing the Connection, Try Again."
          );
          handleRemoveListeners();
          reject(
            new Error(
              "\u274C Error Connecting WebSocket, Closing the Connection, Try Again."
            )
          );
        };
        const handleRemoveListeners = () => {
          this.off("connected", handleSuccess);
          this.off("closed", handleClose);
        };
        this.once("connected", handleSuccess);
        this.once("closed", handleClose);
      });
      await socketConnectionPromise;
      return _Socket.__instance;
    };
    /**
     * Closes the underlying socket connection, and clears all the event listeners and subscriptions to events as well as
     * any other information related to the connection.
     * @param code `{ ESocketCloseCode }`
     */
    close = (code, reconnect = false) => {
      if (this.__ws) {
        this.__ws.onmessage = null;
      }
      const reason = SocketCloseReason[code];
      if (code >= 3e3 && code <= 4999 || code === 1e3) {
        logger3.info(`\u{1F534} Closing the WebSocket Connection, ${code} ${reason}`);
        this.__ws?.close(code, reason);
        this.__ws = null;
        this.token = null;
        this.__ENDPOINT = null;
        this.__retryCount = 0;
        this.emit("token-updated", null);
        this.connectionState = "closed";
        this.emit("closed", code);
        logger3.info("\u{1F50C} WebSocket Connection closed");
        return;
      }
      this.__ws?.close();
      if (this.__ws) {
        this.__unregisterSocketEvents(this.ws);
      }
      this.__ws = null;
      if (code === ESocketCloseCode.ABNORMAL_CLOSURE || reconnect) {
        logger3.info(
          "\u{1F50C} Socket Connection closed abnormally, Trying to Reconnect",
          {
            code,
            reason
          }
        );
        if (this.__retryCount < 7) {
          const delay = 2 ** this.__retryCount * 1e3;
          setTimeout(
            () => {
              if (this.token) {
                try {
                  logger3.info(
                    "\u{1F514} Trying to reconnect, Attempt:",
                    this.__retryCount
                  );
                  this.connectionState = "reconnecting";
                  this.emit("reconnecting");
                  this.connect({ token: this.token }).then(() => {
                    if (this.__retryCount > 0) {
                      this.emit("reconnected");
                    }
                    this.__retryCount = 0;
                  }).catch(() => {
                    if (this.__retryCount === 7) {
                      logger3.error("All Reconnection Attempt failed");
                    }
                  });
                } catch (err) {
                  logger3.error(
                    `Reconnection Attempt ${this.__retryCount} failed`
                  );
                }
              }
            },
            Math.min(delay, 2e4)
          );
          this.__retryCount++;
        } else {
          logger3.error(
            "\u{1F534} Socket connection closed abnormally, reconnecting failed"
          );
          this.close(ESocketCloseCode.CONNECTION_EXPIRED);
        }
      } else {
        logger3.info("\u{1F50C} Socket Connection closed", code, reason);
        this.connectionState = "closed";
        this.emit("closed", code);
      }
    };
    /**
     * Publish a message to the server using the socket connection based on some events/topics
     */
    publish = (event, data) => {
      try {
        const message = new Request({
          // @ts-ignore - TS doesn't understand that the value of event is a key of ClientToSushiEvents
          request: {
            case: event,
            value: new ProtoRequestEvent[event](data)
          }
        });
        const binaryData = message.toBinary();
        this.ws.send(binaryData);
      } catch (error) {
        logger3.error("\u{1F534} Error While Sending the Message", error);
      }
    };
    /**
     * Subscribe to a specific event/topic from the server
     */
    subscribe = (event, fn) => {
      if (this.__subscribedMap.has(event)) {
        logger3.warn("\u26A0\uFE0F Overriding existing event handler");
      }
      this.__subscribedMap.set(event, fn);
    };
    /**
     * Get the config url for the socket connection based on the token and region
     * @param token Local Peer specific meeting token
     * @param region Local Peer specific region
     * @returns
     */
    async __getConfigUrl(token, region, country) {
      if (this.__ENDPOINT) {
        return this.__ENDPOINT;
      }
      const fn = async () => {
        const apiServerUrl = this.isLocalDev ? "http://localhost:8000/api/v1" : "https://apira.huddle01.media/api/v1";
        const res = await fetch(`${apiServerUrl}/getSushiUrl`, {
          method: "GET",
          headers: {
            "Content-Type": "application/json",
            authorization: `Bearer ${token}`
          }
        });
        if (!res.ok) {
          throw new Error("\u{1F534} Error While Fetching the Url");
        }
        const { url } = await res.json();
        this.__ENDPOINT = url.replace("https://", "wss://").replace("http://", "ws://");
        const wssAddress = `${this.__ENDPOINT}/ws`;
        const wsAddress = `${wssAddress}?${[
        `token=${token}`,
        `version=${package_default.version}`,
        `region=${region}`,
        `country=${country}`
      ].join("&")}`;
        this.__ENDPOINT = wsAddress;
        return wsAddress;
      };
      return apiCallWithRetry(fn);
    }
    /**
     * !Important
     * Handle the incoming message from the server based on the events received from the server and call the subscribed event handler
     */
    __handleIncomingMessage = (event) => {
      try {
        const eventData = new Uint8Array(event.data);
        const msg = Response.fromBinary(eventData).Response;
        logger3.debug("\u{1F4E8} Incoming message", msg);
        const eventName = msg.case;
        if (eventName === void 0) {
          throw new Error("\u{1F534} Can't find the event name, Found: { undefined }");
        }
        const data = JSON.parse(JSON.stringify(msg.value));
        logger3.info("\u{1F4E8} Incoming message event name: ", eventName);
        const fn = this.__subscribedMap.get(eventName);
        if (fn) {
          fn(data);
        }
      } catch (error) {
        logger3.error("\u{1F534} Error: Handling Incoming Message", error);
      }
    };
    __handleSocketError = (ev) => {
      logger3.error("\u274C Socket connection error", ev);
    };
    /**
     * @description Handle the socket close event which is sent by the server
     * @param ev CloseEvent
     */
    __handleSocketClose = (ev) => {
      logger3.info("\u{1F514} Socket connection closed emitted", ev);
      const code = ev.code;
      const reason = ev.reason;
      const isCloudflareClose = reason?.toLowerCase().includes("cloudflare");
      const isReactNativeStreamEnd = isReactNative() && reason?.toLowerCase().includes("stream end encountered");
      this.close(code, isCloudflareClose || isReactNativeStreamEnd);
    };
    /**
     * @description Handle the socket open event which is sent after the connection is established with the server
     * @param ev Event
     */
    __handleSocketOpen = (ev) => {
      logger3.debug("WebSocket Connection Open", ev);
      this.connectionState = "connected";
      this.emit("connected");
    };
    /**
     * @description Register the socket events
     * @param ws WebSocket
     */
    __registerSocketEvents = (ws) => {
      ws.onerror = this.__handleSocketError;
      ws.onclose = this.__handleSocketClose;
      ws.onopen = this.__handleSocketOpen;
    };
    /**
     * @description Unregister the socket events
     * @param ws WebSocket
     */
    __unregisterSocketEvents = (ws) => {
      ws.onerror = null;
      ws.onclose = null;
      ws.onopen = null;
    };
  };
  var Socket_default = Socket;

  // src/Permissions.ts
  var logger4 = mainLogger.createSubLogger("Permissions");
  var Permissions2 = class _Permissions extends EnhancedEventEmitter {
    /**
     * Get the Singleton Instance of the Permissions Class.
     */
    static __instance;
    /**
     * Admin Access of the Room.
     */
    __admin = false;
    /**
     * Can Consume Media Stream of the Room from RemotePeers;
     */
    __canConsume = false;
    /**
     * Can Produce Media Stream to the Room
     */
    __canProduce = true;
    /**
     * Allowed Sources to Produce Media Stream to the Room
     */
    __canProduceSources = {
      cam: true,
      mic: true,
      screen: true
    };
    /**
     * Can Send Data to the Room, e.g. Chat Messages, update of avatar, name etc. to the room
     */
    __canSendData = false;
    /**
     * Can Receive Data from the Room, e.g. Chat Messages, update of avatar, name etc. from other Remote Peers.
     */
    __canRecvData = false;
    /**
     * Can Update Metadata of the Room, e.g. DisplayName, Avatar, etc.
     */
    __canUpdateMetadata = false;
    /**
     * Custom Role of the Peer in the Room.
     */
    __role = null;
    /**
     * Getter for the role of the peer.
     */
    get role() {
      return this.__role;
    }
    set role(role) {
      this.__role = role;
    }
    /**
     * Get the Access Control List ( acl ) of the Local Peer in the Room.
     */
    get acl() {
      return {
        admin: this.__admin,
        canConsume: this.__canConsume,
        canProduce: this.__canProduce,
        canProduceSources: this.__canProduceSources,
        canSendData: this.__canSendData,
        canRecvData: this.__canRecvData,
        canUpdateMetadata: this.__canUpdateMetadata
      };
    }
    /**
     * Update the Permissions of the Local Peer in the Room. This will emit an event `updated` with the updated permissions.
     *
     * `NOTE: If the Peer is not an admin, then the permissions will not be updated on the server`
     */
    updatePermissions(permissions) {
      logger4.info("\u{1F514} Updating Permissions", permissions);
      this.__admin = permissions.admin ?? this.__admin;
      this.__canConsume = permissions.canConsume ?? this.__canConsume;
      this.__canProduce = permissions.canProduce ?? this.__canProduce;
      this.__canProduceSources = permissions.canProduceSources ?? this.__canProduceSources;
      this.__canSendData = permissions.canSendData ?? this.__canSendData;
      this.__canRecvData = permissions.canRecvData ?? this.__canRecvData;
      this.__canUpdateMetadata = permissions.canUpdateMetadata ?? this.__canUpdateMetadata;
    }
    static createInstance() {
      if (_Permissions.__instance) return _Permissions.__instance;
      _Permissions.__instance = new _Permissions();
      return _Permissions.__instance;
    }
    static getInstance() {
      if (!_Permissions.__instance) {
        throw new Error("Permissions Instance not created yet.");
      }
      return _Permissions.__instance;
    }
    constructor() {
      super();
    }
    reset() {
      this.__admin = false;
      this.__canConsume = false;
      this.__canProduce = true;
      this.__canProduceSources = {
        cam: true,
        mic: true,
        screen: true
      };
      this.__canSendData = false;
      this.__canRecvData = false;
      this.__canUpdateMetadata = false;
      this.__role = null;
    }
  };
  var checkPermissions = (permission) => {
    return {
      validate: (fn) => {
        return (...args) => {
          return new Promise((resolve, reject) => {
            try {
              const peerPermission = Permissions2.getInstance().acl;
              if (permission?.admin && !peerPermission.admin) {
                throw new Error("Admin Access Required.");
              }
              if (permission?.canConsume && !peerPermission.canConsume) {
                throw new Error("Can Consume Access Required.");
              }
              if (permission?.canProduce && !peerPermission.canProduce) {
                throw new Error("Can Produce Access Required.");
              }
              if (permission?.canProduceSources?.cam && !peerPermission.canProduceSources.cam) {
                throw new Error("Produce Sources Access Required. for 'cam'");
              }
              if (permission?.canProduceSources?.mic && !peerPermission.canProduceSources.mic) {
                throw new Error("Produce Sources Access Required. for 'mic'");
              }
              if (permission?.canProduceSources?.screen && !peerPermission.canProduceSources.screen) {
                throw new Error("Produce Sources Access Required. for 'screen'");
              }
              if (permission?.canSendData && !peerPermission.canSendData) {
                throw new Error("Can Send Data Access Required.");
              }
              if (permission?.canRecvData && !peerPermission.canRecvData) {
                throw new Error("Can Recv Data Access Required.");
              }
              fn(...args).then((data) => {
                resolve(data);
              }).catch((error) => {
                reject(error);
              });
            } catch (error) {
              logger4.error("CheckPermissions Failed, Access Required", error);
              reject(error);
            }
          });
        };
      }
    };
  };
  var checkProducePermissions = (label) => {
    const permissions = Permissions2.getInstance().acl;
    let error = false;
    if (!permissions.canProduce) {
      error = true;
    }
    if (label === "video" && !permissions.canProduceSources.cam) {
      error = true;
    } else if (label === "audio" && !permissions.canProduceSources.mic) {
      error = true;
    } else if (label.startsWith("screen-share") && !permissions.canProduceSources.screen) {
      error = true;
    }
    return error;
  };
  var Permissions_default = Permissions2;

  // src/Room.ts
  var logger5 = mainLogger.createSubLogger("Room.ts");
  var Room = class _Room extends EnhancedEventEmitter {
    /**
     * Room Instance, Singleton class
     */
    static __instance = null;
    /**
     * Socket Instance, Singleton class
     */
    __socket = Socket_default.getInstance();
    /**
     * Returns the instance of the socket connection
     */
    get socket() {
      return this.__socket;
    }
    /**
     * Room Id of the current room
     */
    __roomId = null;
    /**
     * session id
     */
    __sessionId = null;
    /**
     * Lobby PeerIds
     */
    __lobbyPeers = /* @__PURE__ */ new Map();
    /**
     * Removed Lobby PeerId from the lobby
     * @param peerId - PeerId of the peer who joined the room
     */
    removeLobbyPeer = (peerId) => {
      this.__lobbyPeers.delete(peerId);
      this.emit("lobby-peers-updated", this.lobbyPeerIds);
    };
    /**
     * Room Config Object
     * - `allowProduce`: Allow non-admin Peers in the Room to produce Media Streams
     * - `allowConsume`: Allow non-admin Peers in the Room to consume Media Streams
     * - `allowSendData`: Allow non-admin Peers in the Room to send data message
     * - `roomLocked`: If the room is locked
     */
    __config = {
      roomLocked: false,
      allowProduce: true,
      allowProduceSources: {
        cam: true,
        mic: true,
        screen: true
      },
      allowConsume: true,
      allowSendData: true
    };
    /**
     * Auto consume flag, if set to true, Peers Joining the Room will automatically consume the media streams of the remote peers
     *
     * @default true
     *
     * @remarks - This flag is used by the `useRoom` hook to automatically consume the media streams of the remote peers,
     * - if set to false, the user will have to manually consume the media streams of the remote peers
     * using the `consume` method of the `LocalPeer` instance `localPeer.consume({ peerId, label: "video", appData: {} });`
     */
    autoConsume = true;
    /**
     * Default Active Speaker Size, if not provided in the room config object
     * @default 0
     * @remarks - To update the active speaker size, you can use function `room.activeSpeakers.updateSize(size: number)`
     */
    __defaultActiveSpeakerSize = 0;
    /**
     * Get the default active speaker size which can be updated using option `activeSpeaker` when initializing the HuddleClient.
     * @remarks - To update the active speaker while inside the meeting, use the function `room.activeSpeakers.updateSize(size: number)`
     */
    get defaultActiveSpeakerSize() {
      return this.__defaultActiveSpeakerSize;
    }
    /**
     * Handler for the ActiveSpeaker
     */
    __activeSpeakers = null;
    /**
     * Get the active speakers instance
     */
    get activeSpeakers() {
      return this.__activeSpeakers;
    }
    set activeSpeakers(activeSpeakers) {
      if (this.__activeSpeakers) {
        logger5.warn(
          "Active Speakers is already set, Ignoring the new active speakers, end this room and create a new room"
        );
      }
      this.__activeSpeakers = activeSpeakers;
    }
    /**
     * Bot Instance, which is used to manage Volatile Messages inside the SDK.
     */
    __bot = null;
    get bot() {
      return this.__bot;
    }
    set bot(bot) {
      if (this.__bot) {
        logger5.warn(
          "Bot is already set, Ignoring the new bot, end this room and create a new room"
        );
      }
      this.__bot = bot;
      this.__bot.on("received-volatile-data", (data) => {
        this.emit("received-volatile-data", data);
      });
    }
    /**
     * State of the Room
     */
    __state = "idle";
    /**
     * Room Stats
     */
    __stats = {
      startTime: 0
    };
    /**
     * Set the state of the room
     */
    set state(newState) {
      if (this.state !== newState) {
        this.__state = newState;
      }
    }
    /**
     * State of the room
     */
    get state() {
      return this.__state;
    }
    /**
     * Get the lobby peers in the form of map
     * @returns - Map of Lobby PeerIds, with the metadata, {peerId ==> {peerId, metadata}}
     * @example
     * ```ts
     * const lobbyPeers = room.lobbyPeersMap;
     *
     * for (const [peerId, metadata] of lobbyPeers) {}
     *
     * ```
     */
    get lobbyPeersMap() {
      return this.__lobbyPeers;
    }
    /**
     * Get lobby peers in the form of array
     */
    get lobbyPeerIds() {
      return Array.from(this.__lobbyPeers.keys());
    }
    /**
     * Get lobby peers in the form of array
     * @returns - Array of Lobby PeerIds
     */
    get lobbyPeers() {
      return this.__lobbyPeers;
    }
    /**
     * Set lobby peers in the form of map
     * `NOTE: This function is an internal function of the SDK, Used to emit evnts based on changes`
     */
    set lobbyPeersMap(peers) {
      this.__lobbyPeers = peers;
      this.emit("lobby-peers-updated", this.lobbyPeerIds);
    }
    /**
     * Get Room Stats
     */
    get stats() {
      return this.__stats;
    }
    /**
     * Set Room Stats
     */
    set stats(stats) {
      this.__stats = stats;
    }
    /**
     * Get
     * @returns
     */
    getLobbyPeerMetadata = (peerId) => {
      const lobbyPeer = this.lobbyPeers.get(peerId);
      let metadata = {};
      if (lobbyPeer?.metadata) {
        metadata = JSON.parse(lobbyPeer.metadata);
      }
      return {
        peerId,
        metadata
      };
    };
    /**
     * Set lobby peers in the form of array
     */
    set newlobbyPeers(peers) {
      for (const peer of peers) {
        this.__lobbyPeers.set(peer.peerId, peer);
        this.emit("new-lobby-peer", peer);
      }
      this.emit("lobby-peers-updated", this.lobbyPeerIds);
    }
    /**
     * Room Config Object
     * - `allowProduce`: Allow non-admin Peers in the Room to produce Media Streams
     * - `allowConsume`: Allow non-admin Peers in the Room to consume Media Streams
     * - `allowSendData`: Allow non-admin Peers in the Room to send data message
     * - `roomLocked`: If the room is locked
     */
    get config() {
      return this.__config;
    }
    set config(config) {
      this.__config = config;
    }
    /**
     * Remote Peers Map, Stores all the remote peers
     */
    remotePeers = /* @__PURE__ */ new Map();
    /**
     * Metadata of the room.
     */
    __metadata = "{}";
    /**
     * Setter function for the metadata of the room
     * `Note: This will not update the metadata of the room, this is just a setter function for the metadata`
     * `To notify everyone in the room about the metadata change, use the updateMetadata function`
     */
    set metadata(metadata) {
      this.__metadata = metadata;
      const parse = JSON.parse(metadata);
      this.emit("metadata-updated", parse);
    }
    /**
     * Get the metadata of the room
     */
    getMetadata = () => {
      const data = JSON.parse(this.__metadata || "{}");
      return data;
    };
    /**
     * Update Metadata of the room
     * @throws { Error } If Request Failed to Update Metadata
     */
    updateMetadata = checkPermissions({ admin: true }).validate(
      async (data) => {
        try {
          if (this.state === "closed" || this.state === "failed" || this.state === "left") {
            logger5.error(
              "\u274C Cannot Update Metadata, You have not joined the room yet"
            );
            return;
          }
          const metadata = JSON.stringify(data);
          this.metadata = metadata;
          this.socket.publish("updateRoomMetadata", {
            metadata
          });
        } catch (error) {
          logger5.error("\u274C Error Updating Metadata");
          logger5.error(error);
        }
      }
    );
    /**
     * Create a new Room Instance if not created, else return the existing Room Instance
     *
     * @returns - Room Instance
     */
    static create(data) {
      if (_Room.__instance) {
        return _Room.__instance;
      }
      _Room.__instance = new _Room(data);
      return _Room.__instance;
    }
    /**
     * Get the Room Instance if its not initialized it will throw an error
     * @returns - Room Instance
     * @throws { Error } If the Room Instance is not initialized
     */
    static getInstance = () => {
      if (!_Room.__instance) {
        throw new Error("\u274C Room Instance Not Initialized");
      }
      return _Room.__instance;
    };
    /**
     * RoomId of the currently joined room.
     */
    get roomId() {
      return this.__roomId;
    }
    /**
     *
     */
    get sessionId() {
      return this.__sessionId;
    }
    set roomId(roomId) {
      if (this.__roomId) {
        logger5.warn(
          "RoomId is already set, Ignoring the new roomId, end this room and create a new room"
        );
        return;
      }
      this.__roomId = roomId;
    }
    set sessionId(sessionId) {
      if (this.__sessionId) {
        logger5.warn(
          "sessionId is already set, Ignoring the new sessionId, end this room and create a new room"
        );
        return;
      }
      this.__sessionId = sessionId;
    }
    /**
     * Returns the PeerIds of the remote peers
     */
    get peerIds() {
      return Array.from(this.remotePeers.keys());
    }
    /**
     * @description Update room control booleans - roomLocked, allowProduce, allowConsume, allowSendData
     * @param data: TNewRoomControls
     * @throws { Error } If the Peer Calling this Functions is not an admin, then the permissions will not be updated
     */
    updateRoomControls = checkPermissions({
      admin: true
    }).validate(async (data) => {
      logger5.info("\u{1F514} Updating Room Controls", data);
      this.config[data.type] = data.value;
      this.emit("room-controls-updated");
      if (data.type === "allowProduceSources") {
        this.socket.publish("updateRoomControls", {
          control: {
            case: "produceSourcesControl",
            value: data
          }
        });
      } else {
        this.socket.publish("updateRoomControls", {
          control: {
            case: "roomControl",
            value: data
          }
        });
      }
    });
    /**
     * Close a particular stream of remote peers
     *  @param data: { label: string; peerIds?: string[] }
     *  @param label: Label of the stream
     *  @param peerIds: PeerIds of the remote peers, if not provided, it will close the stream of all the remote peers
     * @throws { Error } If the Peer Calling this Function is not an admin, then the permissions will not be updated
     */
    closeStreamOfLabel = checkPermissions({ admin: true }).validate(
      async (data) => {
        logger5.info("\u{1F514} Closing Stream of Label", data);
        this.socket.publish("closeStreamOfLabel", data);
      }
    );
    /**
     * Mute everyone in the room. This will close the audio stream of all the remote peers who dont have admin permissions
     *
     * `NOTE: This will target all the audio stream in the room with the label "audio"`
     *
     * @throws { Error } If the Peer Calling this Function is not an admin, then the permissions will not be updated
     */
    muteEveryone = checkPermissions({ admin: true }).validate(async () => {
      logger5.info("\u{1F514} Muting Everyone");
      this.socket.publish("closeStreamOfLabel", {
        label: "audio"
      });
    });
    /**
     * Returns the Remote Peer with the given peerId is present in the room. Returns null if the peer is not present in the room.
     *
     * @param peerId - PeerId of the remote peer
     * @returns - RemotePeer Instance
     * @return - null if the peer is not present in the room
     */
    remotePeerExists = (peerId) => {
      const peer = this.remotePeers.get(peerId);
      if (!peer) {
        return null;
      }
      return peer;
    };
    /**
     * Returns the Remote Peer if present in room.
     * @param peerId - PeerId of the remote peer
     * @returns - RemotePeer Instance
     * @throws { Error } If the Remote Peer is not found
     */
    getRemotePeerById(peerId) {
      const peer = this.remotePeers.get(peerId);
      if (!peer) {
        throw new Error(`Remote Peer Not Found, peerId: ${peerId}`);
      }
      return peer;
    }
    constructor(data) {
      super();
      if (data?.autoConsume !== void 0) {
        this.autoConsume = data.autoConsume;
      }
      if (data?.activeSpeakers && data.activeSpeakers.size !== this.__defaultActiveSpeakerSize) {
        this.__defaultActiveSpeakerSize = data.activeSpeakers.size;
      }
    }
    /**
     * Connects to the room and returns the instance of the room,
     *
     * @param data - roomId to connect to, make sure the roomId matches the roomId in the token used to connect the socket, else it will throw an error
     * @throws { Error } If the socket connection is not connected, or if the socket connection is connecting
     */
    connect = (data) => {
      if (_Room.__instance === null) {
        throw new Error("Room Instance Not Initialized");
      }
      if (!data.roomId) {
        throw new Error("Room Id is required to connect to the room");
      }
      this.__roomId = data.roomId;
      if (!this.socket.connected) {
        throw new Error("Socket is Not Connected");
      }
      if (this.socket.connecting) {
        throw new Error("Socket is Connecting, Wait for it to be connected");
      }
      logger5.info("\u{1F514} Connecting to the room");
      this.socket.publish("connectRoom", { roomId: data.roomId });
      this.__state = "connecting";
      this.emit("room-connecting");
      return _Room.__instance;
    };
    /**
     * Admit a Peer to the room who is in the lobby
     *
     * @throws {Error} If the Peer Calling this Function is not an admin, then the permissions will not be updated
     */
    admitPeer = checkPermissions({ admin: true }).validate(
      async (peerId) => {
        try {
          this.removeLobbyPeer(peerId);
          this.socket.publish("acceptLobbyPeer", { peerId });
        } catch (error) {
          logger5.error("\u{1F534} Error admitting peer", error);
        }
      }
    );
    /**
     * Denies the peer from joining the room, who is in the lobby
     */
    denyPeer = checkPermissions({ admin: true }).validate(
      async (peerId) => {
        try {
          this.removeLobbyPeer(peerId);
          this.socket.publish("denyLobbyPeer", { peerId });
        } catch (error) {
          logger5.error("\u{1F534} Error denying peer", error);
        }
      }
    );
    /**
     * kick peer from room with respective peerId
     * @throws { Error } If the Peer Calling this Function is not an admin, then the permissions will not be updated
     */
    kickPeer = checkPermissions({ admin: true }).validate(
      async (peerId) => {
        try {
          this.socket.publish("kickPeer", { peerId });
        } catch (error) {
          logger5.error("\u{1F534} Error denying peer", error);
        }
      }
    );
    /**
     * closing the room for the current user, room will keep on running for the remote users
     */
    close = (reason) => {
      try {
        logger5.info("\u{1F534} Leaving the room");
        this.__roomId = null;
        this.__sessionId = null;
        this.remotePeers.clear();
        this.lobbyPeers.clear();
        this.metadata = "{}";
        if (this.__activeSpeakers) {
          this.__activeSpeakers.close();
        }
        this.__activeSpeakers = null;
        this.__defaultActiveSpeakerSize = 8;
        this.__bot?.close();
        this.__bot = null;
        this.state = "left";
        this.emit("room-closed", { reason: reason || "LEFT" });
      } catch (error) {
        logger5.error("Error: Leaving the Room");
      }
    };
  };
  var Room_default = Room;

  // src/RemotePeer.ts
  var logger6 = mainLogger.createSubLogger("RemotePeer");
  var RemotePeer = class extends EnhancedEventEmitter {
    /**
     * peerId of the remote peer, this is unique for each peer
     */
    peerId;
    /**
     * Stores the Metadata for the Remote Peer.
     */
    __metadata = "{}";
    /**
     * Stores the Role of the Remote Peer.
     */
    __role = null;
    /**
     * Labels are the unique identifier for the media stream that the remote peer is producing
     */
    __labelsToProducerId = /* @__PURE__ */ new Map();
    /**
     * Returns the list of labels that the remote peer is producing
     */
    get labels() {
      return Array.from(this.__labelsToProducerId.keys());
    }
    get producerIds() {
      return Array.from(this.__labelsToProducerId.values()).map(
        (labelData) => labelData.producerId
      );
    }
    /**
     * Role of the Peer.
     * @returns The Role of the Peer which if passed in the options when creating the token
     */
    get role() {
      if (!this.__role) return null;
      return this.__role;
    }
    set role(role) {
      this.__role = role;
      this.emit("role-updated", {
        role
      });
    }
    /**
     * Checks if the remote peer is producing the label
     * @param label - Label to check if the remote peer is producing
     * @returns - Returns true if the remote peer is producing the label
     */
    hasLabel(label) {
      return this.__labelsToProducerId.has(label);
    }
    /**
     * Returns the data associated to the label, this is the producerId
     *
     * @returns
     * producerId - Unique identifier for the producer
     */
    getLabelData(label) {
      return this.__labelsToProducerId.get(label);
    }
    /**
     * Get the associated consumer for the label
     * @param label - Unique identifier for the consumer e.g. `video` | `audio` | `screen-share-video` | string
     * @returns Consumer | null
     */
    getConsumer(label) {
      try {
        const localPeer = LocalPeer_default.getInstance();
        const consumer = localPeer.recvTransport.getConsumer({
          label,
          peerId: this.peerId
        });
        return consumer;
      } catch (error) {
        return null;
      }
    }
    /**
     * Returns the metadata associated to the RemotePeer
     */
    getMetadata() {
      return this.__metadata;
    }
    /**
     * Setter function to update the Remote Peer Metadata
     *
     * `NOTE: This will NOT notify other Remote Peers of the update`
     */
    set metadata(data) {
      this.__metadata = data;
      this.emit("metadata-updated", {
        metadata: data
      });
    }
    /**
     * Update the Permissions of the Remote Peer in the Room. This will emit an event `updated` with the updated permissions.
     */
    updatePermissions = checkPermissions({
      admin: true
    }).validate(async (data) => {
      try {
        logger6.info("\u{1F514} Updating Permissions", data);
        const localPeer = LocalPeer_default.getInstance();
        const socket = localPeer.socket;
        socket.publish("updatePeerPermission", {
          peerId: this.peerId,
          permissions: data
        });
      } catch (error) {
        logger6.error("\u{1F514} Error Updating Permissions");
        logger6.error(error);
      }
    });
    /**
     * Update the role of the Remote Peer in the Room, this will emit an event `updated` with the updated role.
     * @throws { Error } If the Peer Calling this function is not an `admin` then it will throw an error.
     */
    updateRole = checkPermissions({
      admin: true
    }).validate(
      async (data) => {
        try {
          logger6.info("\u{1F514} Updating Peer Role", data);
          if (data.role === this.__role) {
            logger6.warn("\u{1F514} Role is already set to", data.role);
            return;
          }
          const localPeer = LocalPeer_default.getInstance();
          const socket = localPeer.socket;
          socket.publish("updatePeerRole", {
            peerId: this.peerId,
            role: data.role,
            options: data.options
          });
        } catch (error) {
          logger6.error("\u{1F514} Error Updating Role", data);
          logger6.error(error);
        }
      }
    );
    /**
     * Removes all the states of the remote peer and clears memory;
     *
     * `NOTE`: You need to close consumers using the `recvTransport.closeConsumer` of the local peer
     */
    close = () => {
      logger6.info("Closing Remote Peer");
      this.removeAllListeners();
    };
    constructor(data) {
      super();
      this.peerId = data.peerId;
      if (data.metadata) {
        this.metadata = JSON.parse(data.metadata);
      }
      if (data.role) {
        this.__role = data.role;
      }
    }
    /**
     * @protected
     * Add a New Label to the Remote Peer and associate it with the ProducerId
     *
     * `NOTE: This is used internally by the Peer`
     *
     * @param data - Data to add the new label `label` and the `producerId` to associate it with
     */
    _addLabelData = async (data) => {
      const { label, producerId } = data;
      this.__labelsToProducerId.set(label, { producerId });
      try {
        const autoConsume = Room_default.getInstance().autoConsume;
        const localPeer = LocalPeer_default.getInstance();
        if (autoConsume) {
          await localPeer.consume({
            appData: {},
            label,
            peerId: this.peerId
          });
        } else {
          this.emit("stream-available", {
            label,
            labelData: {
              producerId
            }
          });
        }
      } catch (error) {
        logger6.error("\u274C Error While Consuming", {
          label,
          peerId: this.peerId
        });
        logger6.error(error);
        this.emit("stream-available", {
          label,
          labelData: {
            producerId
          }
        });
      }
    };
    /**
     * @protected
     * Remove a Label from the Remote Peer and emit a `stream-closed` event
     *
     * `NOTE: This is used internally by the Peer`
     *
     * @param data - Data to remove the label from the Remote Peer
     */
    _removeLabelData = (label, reason) => {
      this.__labelsToProducerId.delete(label);
      this.emit("stream-closed", {
        label,
        reason
      });
    };
  };
  var RemotePeer_default = RemotePeer;

  // src/Consumer.ts
  var logger7 = mainLogger.createSubLogger("Consumer");
  var Consumer = class _Consumer extends EnhancedEventEmitter {
    /**
     * ProducerId of the Consumer, this is the id of the Media Entity which is responsible for producing the media in the room.
     */
    producerId;
    /**
     * PeerId of the Producer, this is the peerId of the Peer which is responsible for producing the media in the room.
     */
    producerPeerId;
    /**
     * Label of the Consumer, this is the label of the Media Entity which is responsible for producing the media in the room.
     */
    label;
    /**
     * Flag to check if the Producer which is being consumed by the Consumer is paused.
     * @remarks If the Producer is paused, the Consumer will not be able to consume the media.
     * @default false
     */
    __producerPaused = false;
    /**
     * Flag to check if the Consumer is consuming a media, if `true` then the Consumer is consuming a media.
     * Consuming Means the incoming media stream is being consumed by the Remote Peer if the Remote Peer is Producing any media.
     * @default false
     */
    __consuming = false;
    /**
     * Flag to check if the Consumer is consuming a media, if `true` then the Consumer is consuming a media.
     *
     * @default false
     *
     * @remarks
     * There are two ways a Peer can Consume any media produced in the room.
     * - Automatically consume the media streams of the remote peers by setting the `autoConsume` flag to `true` in the `Room`.
     * - Using the `consume` function inside the `LocalPeer` instance. `localPeer.consume({ peerId, label: "video", appData: {} });`
     */
    get consuming() {
      return this.__consuming;
    }
    /**
     * Flag to check if the Producer which is being consumed by the Consumer is paused.
     * @remarks If the Producer is paused, the Consumer will not be able to consume the media.
     * @default false
     */
    get producerPaused() {
      return this.__producerPaused;
    }
    /**
     * mediasoupConsumer instance, this is the instance of the mediasoupConsumer which is responsible for consuming the media in the room.
     * @remarks This is a private property and should not be accessed directly.
     *
     * Every Consumer is created without a mediasoupConsumer, when the peer starts to consume the media, the mediasoupConsumer is set.
     */
    #mediasoupConsumer = null;
    /**
     * Getter for the id for the mediaSoupConsumer, which is also the id of the Consumer for the RemotePeer.
     */
    get id() {
      return this.#mediasoupConsumer?.id;
    }
    /**
     *
     * @param consumer Sets the mediasoupConsumer for the Consumer
     */
    setMediaSoupConsumer(consumer) {
      if (this.consuming) {
        throw new Error("Consumer is already consuming");
      }
      if (this.#mediasoupConsumer) {
        throw new Error("Consumer already has a mediasoupConsumer");
      }
      this.#mediasoupConsumer = consumer;
    }
    /**
     * Getter for the mediasoupConsumer id, which is also the id of the Consumer for the RemotePeer. it is only available when the Consumer is consuming a media.
     *
     * @remarks
     * There are two ways a Peer can Consume any media produced in the room.
     * - Automatically consume the media streams of the remote peers by setting the `autoConsume` flag to `true` in the `Room`.
     * - Using the `consume` function inside the `LocalPeer` instance. `localPeer.consume({ peerId, label: "video", appData: {} });`
     */
    get consumerId() {
      return this.#mediasoupConsumer?.id;
    }
    /**
     * Get the Track of the Consumer, it is only available when the Consumer is consuming a media.
     *
     * @remarks
     * There are two ways a Peer can Consume any media produced in the room.
     * - Automatically consume the media streams of the remote peers by setting the `autoConsume` flag to `true` in the `Room`.
     * - Using the `consume` function inside the `LocalPeer` instance. `localPeer.consume({ peerId, label: "video", appData: {} });`
     */
    get track() {
      return this.#mediasoupConsumer?.track;
    }
    /**
     * Get the kind of the Consumer, it is only available when the Consumer is consuming a media.
     *
     * @remarks
     * There are two ways a Peer can Consume any media produced in the room.
     * - Automatically consume the media streams of the remote peers by setting the `autoConsume` flag to `true` in the `Room`.
     * - Using the `consume` function inside the `LocalPeer` instance. `localPeer.consume({ peerId, label: "video", appData: {} });`
     */
    get kind() {
      return this.#mediasoupConsumer?.kind;
    }
    /**
     * If the Consumer is paused, it is only available when the Consumer is consuming a media.
     *
     * if paused the user is not consuming any media for the given producerId.
     */
    get paused() {
      return this.#mediasoupConsumer?.paused;
    }
    /**
     * AppData of the Consumer, it is only available when the Consumer is consuming a media.
     */
    get appData() {
      return this.#mediasoupConsumer?.appData;
    }
    /**
     * State of a Consumer is defined by the following:
     * - `playable` - The Consumer is ready to play the media.
     * - `unavailable` - The Consumer is not available to play the media. This can happen when the Consumer is closed or paused.
     * - `paused` - The Consumer is paused and is not playing the media.
     * - `available` - The Consumer is available to play the media. Peer can consume the media by using `localPeer.consume({ peerId, label: "video", appData: {} });` after which the state will change to `playable`.
     */
    get state() {
      if (this?.consuming) return "playable";
      if (this?.paused) return "paused";
      return "available";
    }
    /**
     * Get the stats of the Consumer, it is only available when the Consumer is consuming a media.
     * It generates the stats for the Consumer using the `getStats` method of the mediasoupConsumer.
     * @returns - RTCStatsReport | null
     */
    getStats = async () => {
      const stats = await this.#mediasoupConsumer?.getStats();
      return stats;
    };
    /**
     * Resume the consumer, if the state of the consumer is `paused`.
     * @returns - Returns `true` if the consumer is resumed, `false` if the consumer is not resumed.
     */
    resume = () => {
      this.#mediasoupConsumer?.resume();
      this.__consuming = true;
      return true;
    };
    /**
     * Pause the consumer, if the state of the consumer is `playable`.
     *
     * @returns - Returns `true` if the consumer is paused, `false` if the consumer is not paused.
     */
    pause = () => {
      this.#mediasoupConsumer?.pause();
      this.__consuming = false;
      return true;
    };
    /**
     * Removes all the eventListeners attached to the Consumer.
     */
    removeListeners = () => {
      this.removeAllListeners();
    };
    /**
     * Creates a Consumer instance. This is a static method and should be called using `Consumer.create({ producerPeerId, producerId, label })`.
     */
    static create = (data) => {
      try {
        const consumer = new _Consumer(data);
        return consumer;
      } catch (error) {
        logger7.error(error);
        throw new Error("\u274C Error creating Consumer");
      }
    };
    close = () => {
      try {
        this.#mediasoupConsumer?.close();
        this.__consuming = false;
        this.emit("closed");
        this.removeAllListeners();
      } catch (error) {
        logger7.error("\u274C Error Closing Consumer");
        logger7.error({
          consumerId: this.consumerId,
          producerId: this.producerId
        });
      }
    };
    constructor(data) {
      super();
      this.producerPeerId = data.producerPeerId;
      this.producerId = data.producerId;
      this.label = data.label;
      this.__producerPaused = data.producerPaused ?? false;
    }
  };
  var Consumer_default = Consumer;

  // src/common-js/EnhancedMap.ts
  var defaultCompareFn = (a, b) => {
    if (a < b) {
      return false;
    }
    if (a > b) {
      return true;
    }
    return false;
  };
  var EnhancedMap = class {
    map;
    compareFn;
    getKey = (a, b) => {
      const key = this.compareFn(a, b) ? `${a}_${b}` : `${b}_${a}`;
      return key;
    };
    get size() {
      return this.map.size;
    }
    get data() {
      return this.map;
    }
    get = (a, b) => {
      const key = this.getKey(a, b);
      const value = this.map.get(key);
      return value;
    };
    values = () => {
      return this.map.values();
    };
    set = (a, b, value) => {
      const key = this.getKey(a, b);
      this.map.set(key, value);
      return value;
    };
    delete = (a, b) => {
      const key = this.getKey(a, b);
      return this.map.delete(key);
    };
    has = (a, b) => {
      const key = this.getKey(a, b);
      return this.map.has(key);
    };
    clear = () => {
      this.map.clear();
    };
    constructor(data) {
      this.map = /* @__PURE__ */ new Map();
      if (data.compareFn) this.compareFn = data.compareFn;
      else this.compareFn = defaultCompareFn;
    }
  };

  // src/helpers/ProtooParsing.ts
  var parseRouterRtpCapabilities = (rtpCapabilities) => {
    const parsedRouterRtpCapabilites = rtpCapabilities;
    if (parsedRouterRtpCapabilites.codecs)
      for (const codec of parsedRouterRtpCapabilites.codecs) {
        if (codec.parameters) {
          const keys = Object.keys(codec.parameters);
          for (const key of keys) {
            if (key === "apt") {
              codec.parameters[key] = Number(codec.parameters[key]);
            }
            if (key === "level-asymmetry-allowed") {
              codec.parameters[key] = Number(codec.parameters[key]);
            }
            if (key === "packetization-mode") {
              codec.parameters[key] = Number(codec.parameters[key]);
            }
            if (key === "x-google-start-bitrate") {
              codec.parameters[key] = Number(codec.parameters[key]);
            }
            if (key === "profile-id") {
              codec.parameters[key] = Number(codec.parameters[key]);
            }
          }
        }
      }
    return parsedRouterRtpCapabilites;
  };
  var parseRtpParameters = (rtpParameters) => {
    const parsedRtpParameters = rtpParameters;
    for (const codec of parsedRtpParameters.codecs) {
      if (codec.parameters) {
        const keys = Object.keys(codec.parameters);
        for (const key of keys) {
          if (key === "apt") {
            codec.parameters[key] = Number(codec.parameters[key]);
          }
          if (key === "level-asymmetry-allowed") {
            codec.parameters[key] = Number(codec.parameters[key]);
          }
          if (key === "packetization-mode") {
            codec.parameters[key] = Number(codec.parameters[key]);
          }
          if (key === "x-google-start-bitrate") {
            codec.parameters[key] = Number(codec.parameters[key]);
          }
          if (key === "profile-id") {
            codec.parameters[key] = Number(codec.parameters[key]);
          }
        }
      }
    }
    if (parsedRtpParameters.encodings) {
      for (const encoding of parsedRtpParameters.encodings) {
        encoding.dtx = false;
        encoding.ssrc = Number(encoding.ssrc);
        if (Number.isNaN(encoding.ssrc)) {
          encoding.ssrc = void 0;
        }
        if (encoding.rtx?.ssrc !== void 0) {
          if (Number(encoding.rtx.ssrc) === 0) {
            encoding.rtx = void 0;
          } else {
            encoding.rtx.ssrc = Number(encoding.rtx.ssrc);
          }
        } else {
          encoding.rtx = void 0;
        }
      }
    }
    const headerExtensions = parsedRtpParameters.headerExtensions;
    if (headerExtensions) {
      headerExtensions.map((headerExtension) => {
        headerExtension.encrypt = false;
        headerExtension.parameters = {};
      });
    }
    return parsedRtpParameters;
  };
  var parseToProtoRtpParameters = (rtpParameters) => {
    const codecs = rtpParameters.codecs;
    for (const codec of codecs) {
      if (codec.parameters) {
        const keys = Object.keys(codec.parameters);
        for (const key of keys) {
          if (key === "apt") {
            codec.parameters[key] = String(codec.parameters[key]);
          }
          if (key === "level-asymmetry-allowed") {
            codec.parameters[key] = String(codec.parameters[key]);
          }
          if (key === "packetization-mode") {
            codec.parameters[key] = String(codec.parameters[key]);
          }
          if (key === "x-google-start-bitrate") {
            codec.parameters[key] = String(codec.parameters[key]);
          }
          if (key === "profile-id") {
            codec.parameters[key] = String(codec.parameters[key]);
          }
        }
      }
    }
    const encodings = rtpParameters.encodings;
    if (encodings) {
      for (const encoding of encodings) {
        if (Number.isNaN(encoding.ssrc)) {
          encoding.ssrc = void 0;
        }
        new ProtoEncodings({
          ssrc: encoding.ssrc ? BigInt(encoding.ssrc) : void 0,
          rid: encoding.rid,
          codecPayloadType: encoding.codecPayloadType,
          rtx: {
            ssrc: encoding.rtx?.ssrc ? BigInt(encoding.rtx.ssrc) : void 0
          },
          dtx: encoding.dtx,
          scalabilityMode: encoding.scalabilityMode,
          scaleResolutionDownBy: encoding.scaleResolutionDownBy,
          maxBitrate: encoding.maxBitrate
        });
      }
    }
    return rtpParameters;
  };

  // src/Transport.ts
  var logger8 = mainLogger.createSubLogger("Transport");
  var Transport = class _Transport extends EnhancedEventEmitter {
    /**
     * Peer Id, which handles the peer id.
     */
    peerId;
    /**
     *  MediaSoup Device Instance, which handles the browsers or mobile device init.
     */
    __device;
    /**
     * MediaSoup Transport Instance, which handles the media transport.
     */
    __mediasoupTransport;
    /**
     * Socket Instance, which handles the socket connection.
     */
    __socket;
    /**
     * Map of Producers, which handles the producers. ( Sending out Media Streams )
     *
     * `Mapped with {producerId => Producer}`
     */
    __producers = /* @__PURE__ */ new Map();
    /**
     * Map of DataProducers, which handles the dataProducers. ( Sending out Data )
     *
     * `Mapped with {label => DataProducer}`
     */
    __dataProducers = /* @__PURE__ */ new Map();
    /**
     * Map of DataConsumers, which handles the dataConsumers. ( Receiving Media Streams )
     *
     * `Mapped with {label:label => DataConsumer}`
     */
    __dataConsumers = /* @__PURE__ */ new Map();
    /**
     * Map of Consumers, which handles the consumers. ( Receiving Media Streams )
     *
     * `Mapped with {label:RemotePeerId => Consumer}`
     */
    __consumers = new EnhancedMap({});
    /**
     * Map of Identifiers to Producer Ids, which handles the mapping of identifiers to producer ids.
     *
     * `identifiers` are the unique identifiers for the stream, which is used to identify the stream.
     */
    labelToProducerId = /* @__PURE__ */ new Map();
    /**
     * Transport Type, which handles the transport type. ( `send | recv` )
     */
    transportType;
    /**
     * Pending Producer Tasks, which handles the pending producer tasks.
     * callback function is necessary to be called when the producer is created
     * on the server as well as on the client side.
     */
    __pendingProducerTasks = /* @__PURE__ */ new Map();
    /**
     * Debounce to handle concurrent request to restart Ice. Waits for some time before sending
     * more requests to restart ice.
     */
    __iceRestartDebounce = false;
    /**
     * WebRTC Device whose APIs for Connection Creation is used.
     */
    get device() {
      return this.__device;
    }
    /**
     * WebRTC Connection, Which handles the producing and consuming of media.
     */
    get mediasoupTransport() {
      return this.__mediasoupTransport;
    }
    /**
     * WebRTC Connection State.
     */
    get connectionState() {
      return this.__mediasoupTransport.connectionState;
    }
    /**
     * Returns the Map of Producers, which handles the producers. ( Sending out Media Streams )
     */
    get producers() {
      return this.__producers;
    }
    /**
     * Returns the ids of the producers, which handles the producers. ( Sending out Media Streams )
     */
    get producerIds() {
      const producerIds = Array.from(this.__producers.keys());
      return producerIds;
    }
    /**
     * Type of data which is supposed to be produced in the room. ( ArrayBuffer )
     */
    get dataProducers() {
      return this.__dataProducers;
    }
    /**
     * Type of data which is supposed to be consumed from the room. ( ArrayBuffer )
     */
    get dataConsumers() {
      return this.__dataConsumers;
    }
    /**
     * Entity which is supposed to consume the media stream. ( MediaStreamTrack )
     */
    get consumers() {
      return this.__consumers;
    }
    /**
     * Get a producer by its id ( ProducerId is generated by the Media Node )
     * @param producerId - Producer Id of the producer to be fetched.
     * @returns - Producer
     * @throws - Throws an error if the producer is not found.
     */
    getProducerById(producerId) {
      const producer = this.__producers.get(producerId);
      if (!producer) throw new Error("Producer not found");
      return producer;
    }
    /**
     * Get the consumer by label and peerId
     * @param data
     * @returns Consumer | null; Returns null if consumer is not found
     */
    getConsumer = (data) => {
      const consumer = this.__consumers.get(data.label, data.peerId);
      if (!consumer) {
        return null;
      }
      return consumer;
    };
    /**
     * Getter for the transport instance.
     */
    get transport() {
      const transport = this.__mediasoupTransport;
      if (!transport) throw new Error("Transport Not Initialized");
      return transport;
    }
    /**
     * Every time a producer is created, it is added to the pending producer tasks.
     * Upon ack from the Media Node the producer is resolved and removed from the pending producer tasks. ( Using resolvePendingProducerTask )
     * This is done to handle concurrency in the producer creation.
     * @param data - { label?: string, peerId: string, callback: ({ id }) => void }
     * @returns - void
     */
    addPendingProducerTask = (data) => {
      const key = `${data.peerId}-${data?.label}`;
      logger8.info("\u{1F514} Adding Pending Producer Task, key", key);
      if (this.__pendingProducerTasks.has(key)) {
        logger8.debug("\u{1F534} Producer Creation is Pending for key: ", key);
        return;
      }
      this.__pendingProducerTasks.set(key, data.callback);
    };
    /**
     * Every time a producer is created, it is added to the pending producer tasks.
     * Upon ack from the Media Node the producer is resolved and removed from the pending producer tasks.
     * This is done to handle concurrency in the producer creation.
     * @param data - { label: string, peerId: string, id: string }
     * @returns - void
     */
    resolvePendingProducerTask = (data) => {
      const key = `${data.peerId}-${data.label}`;
      logger8.info("\u{1F514} Resolving Pending Producer Task, key", key);
      const callback = this.__pendingProducerTasks.get(key);
      if (!callback) {
        logger8.error("\u{1F534} Producer Creation is not Pending for key: ", key);
        return;
      }
      callback({ id: data.id });
      this.__pendingProducerTasks.delete(key);
    };
    /**
     * Creates a new Transport Instance, Transports are used to send and receive media streams or data.
     * Transport for the SDK mean a WebRTC Connection.
     * @param data
     * @returns
     */
    static create = (data) => {
      try {
        logger8.info(
          `\u{1F514} Creating Client Side Transport, type: ${data.transportType}`
        );
        const { transportType, device } = data;
        const payload = {
          id: data.sdpInfo.id,
          iceParameters: data.sdpInfo.iceParameters,
          iceCandidates: data.sdpInfo.iceCandidates,
          iceServers: data.iceServers,
          dtlsParameters: data.sdpInfo.dtlsParameters,
          sctpParameters: data.sdpInfo.sctpParameters,
          proprietaryConstraints: {},
          appData: {}
        };
        const mediasoupTransport = transportType === "send" ? device.createSendTransport(payload) : device.createRecvTransport(payload);
        const transport = new _Transport({
          peerId: data.peerId,
          device: data.device,
          transportType: data.transportType,
          mediasoupTransport
        });
        return transport;
      } catch (error) {
        logger8.error(`\u274C Transport.create(), type: ${data.transportType}`);
        logger8.error(error);
        throw error;
      }
    };
    constructor(data) {
      super();
      this.__socket = Socket_default.getInstance();
      this.__device = data.device;
      this.transportType = data.transportType;
      this.__mediasoupTransport = data.mediasoupTransport;
      this.__mediasoupTransport.on("connectionstatechange", (state) => {
        this.__connectionStateChangeHandler(state);
      });
      this.peerId = data.peerId;
      this.__listenTransportConnect();
      this.__listenTransportProduce();
      if (this.transportType === "send") this.__listenTransportDataProduce();
      logger8.info(`\u2705 ${data.transportType} Transport Initialized`);
    }
    /**
     * Function to handle the event when transport is supposed to be connected. ( WebRTC )
     */
    __listenTransportConnect = () => {
      this.__mediasoupTransport.on(
        "connect",
        ({ dtlsParameters }, callback, errback) => {
          logger8.info("\u{1F514} Transport Connect Event Called");
          try {
            this.once("connectTransportResponse", () => {
              callback();
            });
            this.__socket.publish("connectTransport", {
              dtlsParameters,
              transportType: this.transportType
            });
          } catch (error) {
            logger8.error("\u274C Error Transport Connect Event");
            logger8.error(error);
            errback(error);
          }
        }
      );
    };
    /**
     * Function to handle the event when media is supposed produced over a Transport ( WebRTC )
     */
    __listenTransportProduce = () => {
      this.__mediasoupTransport.on(
        "produce",
        async ({ kind, rtpParameters, appData }, callback, errback) => {
          logger8.info(`\u{1F514} ${this.transportType} Produce Event Called`);
          try {
            const label = appData?.label;
            if (!label) throw new Error("\u{1F534} Stream Identifier Not Found");
            const parsedProtoRtpParameters = parseToProtoRtpParameters(rtpParameters);
            this.__socket.publish("produce", {
              rtpParameters: parsedProtoRtpParameters,
              kind,
              label,
              appData,
              paused: false
            });
            this.addPendingProducerTask({
              peerId: this.peerId,
              label,
              callback
            });
          } catch (error) {
            logger8.error("\u274C Error Transport Produce Event");
            logger8.error(error);
            errback(error);
          }
        }
      );
    };
    /**
     * Function to handle the event when data is supposed produced over a Transport ( WebRTC DataChannel )
     */
    __listenTransportDataProduce = () => {
      logger8.info(`\u{1F514} producedata: ${this.transportType} `);
      this.__mediasoupTransport.on(
        "producedata",
        async ({ label, appData, sctpStreamParameters, protocol }, callback, errback) => {
          logger8.info(`\u{1F514} ${this.transportType} Produce Data Event Called`);
          try {
            this.__socket.publish("produceData", {
              transportId: this.__mediasoupTransport.id,
              sctpStreamParameters,
              label,
              protocol,
              appData
            });
            this.addPendingProducerTask({
              peerId: this.peerId,
              label,
              callback
            });
          } catch (error) {
            logger8.error("\u274C Error Transport Produce Data Event");
            logger8.error(error);
            errback(error);
          }
        }
      );
    };
    /**
     * Function to handle the producing of a media stream to the room.
     * @param data - { stream: MediaStream, label: string, stopTrackOnClose: boolean, appData?: AppData }
     * @returns - Producer
     * NOTE: PrefferedCodec is optional, if not provided, H264 is used as the default codec.
     * is device does not support the passed codec, an error is thrown.
     */
    produce = async (data) => {
      const kind = getMediaStreamKind(data.stream);
      const track = getMediaTrack({ stream: data.stream, kind });
      logger8.info(`\u{1F514} Produce Called for kind: ${kind}, label: ${data.label}`);
      try {
        if (!this.__device.loaded) {
          throw new Error("Device Not Loaded");
        }
        if (!this.__device.rtpCapabilities.codecs) {
          throw new Error("No Codecs Found");
        }
        if (!this.__device.canProduce(kind)) {
          throw new Error(`Device Cannot produce ${kind}`);
        }
        if (this.transportType !== "send") {
          throw new Error(`Cannot produce on ${this.transportType} transport`);
        }
        const codecs = this.__device.rtpCapabilities?.codecs;
        if (!codecs) {
          throw new Error("\u274C Device RTP Capabilities not found");
        }
        const videoCodecMimeType = data.prefferedCodec ?? "video/h264";
        const videoCodec = codecs.find(
          (codec) => codec.mimeType.toLowerCase() === videoCodecMimeType
        );
        if (!videoCodec) {
          throw new Error(
            `\u274C Preffered codec: ${data.prefferedCodec} not found on the device`
          );
        }
        const codecViaMediaType = {
          video: videoCodec,
          "screen-share-video": videoCodec,
          audio: void 0
        };
        const mediaType = data.label === "screen-share-video" ? "screen-share-video" : kind;
        const mediasoupProducer = await this.__mediasoupTransport.produce({
          track,
          encodings: encodingViaMediaType[mediaType],
          codecOptions: codecOptionsViaKind[kind],
          codec: codecViaMediaType[mediaType],
          stopTracks: data.stopTrackOnClose,
          zeroRtpOnPause: true,
          disableTrackOnPause: true,
          appData: {
            ...data.appData,
            producerPeerId: this.peerId
          }
        });
        mediasoupProducer.on("@close", () => {
          logger8.info("\u{1F514} Closing Producer", {
            label: data.label,
            producerId: mediasoupProducer.id
          });
          this.__producers.delete(mediasoupProducer.id);
          this.labelToProducerId.delete(data.label);
        });
        this.__producers.set(mediasoupProducer.id, mediasoupProducer);
        this.labelToProducerId.set(data.label, mediasoupProducer.id);
        logger8.info(
          `\u{1F514} Client Side Producer Created sucessfully with label : ${data.label}`
        );
        return mediasoupProducer;
      } catch (error) {
        logger8.error("\u274C Error Transport Produce Event");
        logger8.error(error);
        throw error;
      }
    };
    /**
     * Function to handle the producing of a data stream to the room.
     * @param data - { label: string, ordered?: boolean, maxRetransmits?: number, maxPacketLifeTime?: number }
     * - `label` is the unique identifier for the data stream, Cannot use `bot` which is reserved.
     * - `ordered` is the boolean value to determine if the data should be ordered or not, or reliably.
     * - `maxRetransmits` When ordered is false indicates the maximum number of times a packet will be retransmitted.
     * - `maxPacketLifeTime` When ordered is false indicates the time (in milliseconds) after which a SCTP packet will stop being retransmitted.
     * @returns - DataProducer
     */
    produceData = async (options) => {
      logger8.info(`\u{1F514} Produce Data Called for label: ${options.label}`);
      try {
        if (this.transportType !== "send") {
          throw new Error(
            `Cannot produceData on ${this.transportType} transport`
          );
        }
        const label = this.dataProducers.get(options.label);
        if (label) {
          throw new Error(
            `DataProducer with label ${options.label} already exists, please close it before creating a new one`
          );
        }
        if (!this.__device.loaded) {
          throw new Error("Device Not Loaded");
        }
        if (!this.__device.sctpCapabilities) {
          throw new Error("No SCTP Capabilities Found");
        }
        const dataProducer = await this.__mediasoupTransport.produceData({
          label: options.label,
          ordered: options.ordered ?? false,
          maxPacketLifeTime: options.maxPacketLifeTime,
          maxRetransmits: options.maxRetransmits
        });
        dataProducer.on("open", () => {
          logger8.info("\u2705 DataProducer opened", options);
        });
        dataProducer.on("@close", () => {
          logger8.info("\u{1F514} Closing DataProducer", {
            label: options.label,
            dataProducerId: dataProducer.id
          });
          this.__dataProducers.delete(dataProducer.label);
        });
        dataProducer.on("transportclose", () => {
          this.__dataProducers.delete(dataProducer.label);
        });
        this.__dataProducers.set(dataProducer.label, dataProducer);
        logger8.info(
          `\u{1F514} Client Side DataProducer Created sucessfully with label : ${options.label}`
        );
        return dataProducer;
      } catch (error) {
        logger8.error("\u274C Error Transport Produce Data Event", error);
        throw error;
      }
    };
    /**
     * @description - Close the data producer by label
     * @param label - Label of the data producer to be closed
     */
    closeDataProducer = (label) => {
      const dataProducer = this.__dataProducers.get(label);
      dataProducer?.close();
      this.__dataProducers.delete(label);
      logger8.info(`\u{1F514} DataProducer with label ${label} closed`);
    };
    /**
     * Consume means to receive the media stream from the room. ( MediaStreamTrack )
     * Using WebRTC Connection to receive the media stream.
     * @param data - { producerPeerId: string, kind: string, rtpParameters: any, appData?: AppData }
     * @returns - { consumer: Consumer, mediaSoupConsumer: mediasoup.types.Consumer }
     */
    consume = async (data) => {
      const { label, producerPeerId, kind } = data;
      logger8.info(
        `\u{1F514} Consume Called for ${kind} from remote peer ${producerPeerId}`
      );
      try {
        if (this.transportType !== "recv") {
          throw new Error(`Cannot consume on ${this.transportType} transport`);
        }
        if (!this.__device.loaded) {
          throw new Error("Device Not Loaded");
        }
        if (!this.__device.rtpCapabilities.codecs) {
          throw new Error("No Codecs Found");
        }
        const parsedRtpParameters = parseRtpParameters(data.rtpParameters);
        const consumer = Consumer_default.create({
          producerId: data.producerId,
          producerPaused: data.producerPaused ?? false,
          producerPeerId,
          label
        });
        const mediaSoupConsumer = await this.__mediasoupTransport.consume({
          id: data.consumerId,
          rtpParameters: parsedRtpParameters,
          kind: data.kind,
          producerId: data.producerId,
          appData: data.appData
        });
        mediaSoupConsumer.on("@close", () => {
          this.__consumers.delete(label, producerPeerId);
        });
        mediaSoupConsumer.on("transportclose", () => {
          this.closeConsumer({ label, peerId: producerPeerId });
        });
        mediaSoupConsumer.on("trackended", () => {
          this.closeConsumer({ label, peerId: producerPeerId });
        });
        this.__consumers.set(consumer.label, consumer.producerPeerId, consumer);
        consumer.setMediaSoupConsumer(mediaSoupConsumer);
        return { consumer, mediaSoupConsumer };
      } catch (error) {
        logger8.error(error);
        throw new Error("\u274C Error calling consume()");
      }
    };
    /**
     * Consume means to receive the data stream from the room. ( ArrayBuffer )
     * Using WebRTC Connection to receive the data stream.
     * @param data - { label: string, appData?: AppData, dataProducerId: string, protocol: string, id: string, peerId: string, sctpStreamParameters: any }
     * @returns - DataConsumer
     */
    consumeData = async (data) => {
      const {
        label,
        appData,
        dataProducerId,
        protocol,
        id,
        peerId,
        sctpStreamParameters
      } = data;
      logger8.info(
        `\u{1F514} ConsumeData from producer ${peerId} consumerIdFromServer:${id}`
      );
      try {
        if (this.transportType !== "recv") {
          throw new Error(`Cannot consume on ${this.transportType} transport`);
        }
        if (!this.__device.loaded) {
          throw new Error("Device Not Loaded");
        }
        if (!this.__device.rtpCapabilities.codecs) {
          throw new Error("No Codecs Found");
        }
        const dataConsumer = await this.transport.consumeData({
          id,
          dataProducerId,
          sctpStreamParameters: {
            ...sctpStreamParameters,
            maxPacketLifeTime: sctpStreamParameters.maxPacketLifeTime === 0 ? void 0 : sctpStreamParameters.maxPacketLifeTime,
            maxRetransmits: sctpStreamParameters.maxRetransmits === 0 ? void 0 : sctpStreamParameters.maxRetransmits
          },
          label,
          protocol,
          appData
        });
        dataConsumer.on("open", () => {
          logger8.info(`\u2705 DataConsumer with ${label} opened`);
        });
        dataConsumer.on("close", () => {
          logger8.warn(`\u2705 DataConsumer with ${label} closed`);
          dataConsumer.close();
          dataConsumer.removeAllListeners();
          this.__dataConsumers.delete(label);
        });
        dataConsumer.on("transportclose", () => {
          console.info(`\u2705 DataConsumer with ${label} closed`);
          dataConsumer.close();
          dataConsumer.removeAllListeners();
          this.__dataConsumers.delete(label);
        });
        dataConsumer.on("error", (error) => {
          logger8.error(`\u2705 DataConsumer "error": ${error} closed`);
          dataConsumer.close();
          dataConsumer.removeAllListeners();
          this.__dataConsumers.delete(label);
        });
        this.__dataConsumers.set(label, dataConsumer);
        return dataConsumer;
      } catch (error) {
        logger8.error(error);
        throw new Error("\u274C Error calling consumeData()");
      }
    };
    /**
     * Close the consumer by label and peerId
     * @param data - { label: string, peerId: string }
     */
    closeConsumer = (data) => {
      const consumer = this.getConsumer(data);
      consumer?.close();
      this.__consumers.delete(data.label, data.peerId);
    };
    /**
     * Close the underlying transport
     * @param data - { retries: number }
     * @returns - void
     */
    close = async (data) => {
      try {
        if (data.retries <= 0) {
          logger8.error("\u274C Error closing transport, max retries exceeded");
          return;
        }
        logger8.info(`\u{1F514} Closing ${this.transportType} transport`);
        this.__mediasoupTransport.close();
        this.__producers.clear();
        this.__consumers.clear();
        this.__dataProducers.clear();
        this.__dataConsumers.clear();
        logger8.info(`\u2705 ${this.transportType} transport closed`);
      } catch (error) {
        logger8.error("\u274C Error closing transport");
        logger8.error(error);
        logger8.error("Retrying...");
        this.close({ retries: data.retries - 1 });
      }
    };
    /**
     * WebRTC Connection is prone to connection state changes, as its a peer to peer connection.
     * This function handles the connection state changes. and re establishes the connection if it is lost.
     * @param state - ConnectionState
     */
    __connectionStateChangeHandler = (state) => {
      try {
        logger8.debug(
          `\u{1F514} ${this.transportType} Transport Connection State Changed, state: ${state}`
        );
        const transportType = this.transportType;
        const handler = {
          connected: () => {
            logger8.debug(`\u{1F514} ${this.transportType} Transport Connected`);
          },
          disconnected: () => {
            if (this.__iceRestartDebounce) return;
            this.__iceRestartDebounce = true;
            this.__socket.publish("restartTransportIce", {
              transportId: this.__mediasoupTransport.id,
              transportType
            });
            setTimeout(() => {
              this.__iceRestartDebounce = false;
            }, 3e3);
            logger8.debug(`\u{1F514} ${transportType} Transport Disconnected`);
          },
          failed: () => {
            logger8.debug(`\u{1F514} ${transportType} Transport Failed`);
          },
          connecting: () => {
            logger8.debug(`\u{1F514} ${transportType} Transport Connecting`);
          },
          closed: () => {
            logger8.debug(`\u{1F514} ${transportType} Transport closed`);
          },
          new: () => {
            logger8.debug(`\u{1F514} ${transportType} Transport new`);
          }
        };
        handler[state]();
      } catch (err) {
        logger8.error("\u274C Error in connectionStateChangeHandler");
        logger8.error(err);
      }
    };
  };
  var Transport_default = Transport;

  // src/ActiveSpeakers.ts
  var logger9 = mainLogger.createSubLogger("ActiveSpeakers");
  var ActiveSpeakers = class extends EnhancedEventEmitter {
    /**
     * Room instance.
     */
    __room = Room_default.getInstance();
    /**
     * Bot instance which has the data producer connected directly to the room bot.
     * This is used to handle all the states of the room and its functionality.
     */
    __bot;
    /**
     * Is the notification active.
     */
    __active;
    /**
     * Is the notification active.
     */
    get active() {
      return this.__active;
    }
    /**
     * Maximum number of entries in the list.
     */
    MAX_SIZE = 20;
    /**
     * Size by which the active speakers list will be notified.
     * `note: default size is 8`
     */
    __size;
    /**
     * Size by which the active speakers list will be notified.
     */
    get size() {
      return this.__size;
    }
    /**
     * Array of ActiveSpeakers ordered by volume.
     */
    __activePeerIds = [];
    get activePeerIds() {
      return this.__activePeerIds;
    }
    /**
     * Update the number of peerIds to notify.
     * @param size
     */
    updateSize = (size) => {
      logger9.info("\u{1F514} Updating Active Speaker Size to", size);
      if (size > this.MAX_SIZE) {
        logger9.error(
          "\u{1F514} Active Speaker Size cannot be greater than",
          this.MAX_SIZE
        );
        return;
      }
      this.__size = size;
    };
    /**
     * Handle all the events emitted by the bot.
     */
    __handleBotEvents = () => {
      this.__bot.on("active-speakers-change", this.__handleActiveSpeakerChange);
    };
    /**
     * Emit the active speakers change event.
     * @param data - Data containing the peerIds of the active speakers.
     */
    __handleActiveSpeakerChange = (data) => {
      try {
        const { peerIds } = data;
        this.__activePeerIds = peerIds;
        const slicedPeerData = peerIds.slice(0, this.__size);
        this.__room.emit("active-speakers-change", {
          peerIds: slicedPeerData ?? [],
          dominantSpeaker: peerIds?.[0] ?? ""
        });
      } catch (error) {
        logger9.error("Error: Handling New Active Speakers Notification", error);
        logger9.error(error);
      }
    };
    constructor(data) {
      super();
      this.__bot = data.bot;
      this.__size = data?.size ?? 8;
      this.__active = true;
      this.__handleBotEvents();
    }
    /**
     * Close the active speakers instance.
     */
    close = () => {
      this.__active = false;
      this.__bot.off("active-speakers-change", this.__handleActiveSpeakerChange);
    };
  };
  var ActiveSpeakers_default = ActiveSpeakers;

  // src/Bot.ts
  var logger10 = mainLogger.createSubLogger("Bot");
  var Bot = class extends EnhancedEventEmitter {
    /**
     * Bot Data Consumer
     */
    __botDataConsumer;
    /**
     * Bot Data Producer
     */
    __botDataProducer;
    constructor(data) {
      super();
      this.__botDataConsumer = data.dataConsumer;
      this.__botDataProducer = data.dataProducer;
      this.__registerBotDataConsumerEvent();
      if (this.__botDataProducer) {
        this.__registerBotDataProducerEvent(this.__botDataProducer);
      }
    }
    /**
     * Register the bot data consumer event.
     */
    __registerBotDataConsumerEvent = () => {
      logger10.info("\u{1F514} Setting a new data consumer");
      try {
        this.__botDataConsumer.on("message", (message) => {
          try {
            logger10.debug("\u{1F514} Bot Data Message", message);
            const parsedJsonData = JSON.parse(message);
            if (parsedJsonData.label === "lastN") {
              this.emit("active-speakers-change", {
                peerIds: parsedJsonData?.payload?.activeSpeakers ?? []
              });
              return;
            }
            this.emit("received-volatile-data", parsedJsonData);
          } catch (error) {
            logger10.error("\u274C Error in bot data consumer message", error);
          }
        });
        this.__botDataConsumer.on("error", (err) => {
          logger10.error("\u274C Bot Data Consumer Error", err);
        });
        this.__botDataConsumer.on("open", () => {
          logger10.info("\u{1F514} Bot Data Consumer Opened");
        });
        this.__botDataConsumer.on("@close", () => {
          logger10.info("\u{1F514} Bot Data Consumer Closed");
        });
      } catch (error) {
        logger10.error("Error in setting data consumer", error);
      }
    };
    /**
     * Register the bot data producer event.
     */
    __registerBotDataProducerEvent = (dataProducer) => {
      logger10.info("\u{1F514} Setting a new data producer");
      try {
        dataProducer.on("error", (err) => {
          logger10.error("\u274C Bot Data Producer Error", err);
        });
        dataProducer.on("open", () => {
          logger10.info("\u{1F514} Bot Data Producer Opened");
        });
        dataProducer.on("@close", () => {
          logger10.info("\u{1F514} Bot Data Producer Closed");
        });
        dataProducer.on("bufferedamountlow", () => {
          logger10.info("\u{1F514} Bot Data Producer bufferedamountlow");
        });
      } catch (error) {
        logger10.error("Error in setting data producer", error);
      }
    };
    /**
     * @description Send data to the bot data producer, if available
     * @param data - Data to send {string}
     * @returns {boolean} - Returns true if data is sent, cannot guarantee if data is received as its over UDP.
     */
    sendData = (data) => {
      try {
        if (!this.__botDataProducer) {
          throw new Error("Bot Data Producer is not available");
        }
        const payload = JSON.stringify(data);
        logger10.info("\u{1F514} Sending data to bot's producer", payload);
        this.__botDataProducer.send(payload);
        return true;
      } catch (error) {
        logger10.error("\u274C Error in sending buffer", error);
        return false;
      }
    };
    close = () => {
      try {
        logger10.info("\u{1F514} Closing Bot");
        this.__botDataConsumer.close();
        if (this.__botDataProducer) {
          this.__botDataProducer.close();
        }
        this.removeAllListeners();
      } catch (error) {
        logger10.error("\u274C Error in closing bot", error);
      }
    };
  };
  var Bot_default = Bot;

  // src/LocalPeer.ts
  var logger11 = mainLogger.createSubLogger("LocalPeer");
  var MAX_DATA_MESSAGE_SIZE = 1 * 1024;
  var LocalPeer = class _LocalPeer extends EnhancedEventEmitter {
    /**
     * LocalPeer Instance, Singleton class, only one instance of this class can be created
     */
    static __instance = null;
    /**
     * PeerId of the current client, specific to the Local Peer who joined the meeting
     *
     * `NOTE: Until you dont join the room, this will be *null*`
     */
    peerId = null;
    /**
     * Current Devices of the current client
     * e.g. Chrome, Firefox, Safari, ReactNative
     */
    __device = null;
    /**
     * custom handler factory for device, required when using aiortc client or something custom
     */
    __handlerFactory;
    /**
     * SendTransport handles the sending of media from the client to the server
     */
    __sendTransport = null;
    /**
     * RecvTransport handles the receiving of media from the server to the client
     */
    __recvTransport = null;
    /**
     * Returns the room instance, throws an error if the room is not created
     *
     * @throws { Error } If the room is not created, Call createRoom() method before you can access the room in the LocalPeer
     */
    get room() {
      const room = Room_default.getInstance();
      if (!room) throw new Error("\u274C Room Not Initialized");
      return room;
    }
    /**
     * Returns the underlying socket connection
     * @throws { Error } If the socket connection is not initialized
     */
    get socket() {
      const socket = Socket_default.getInstance();
      if (!socket) throw new Error("\u274C Socket Not Initialized");
      return socket;
    }
    /**
     * Remote Peers Map, Stores all the remote peers
     */
    get __remotePeers() {
      return this.room.remotePeers;
    }
    /**
     * Turn Server used for this client
     */
    __turn = [
      {
        username: "test-turn",
        urls: "turn:turn.huddle01.com:443?transport=udp",
        credential: "test-turn"
      },
      {
        username: "test-turn",
        urls: "turn:turn.huddle01.com:443?transport=tcp",
        credential: "test-turn"
      }
    ];
    /**
     * Get the current device ( chrome, firefox, safari, reactnative ) for this client
     *
     * @throws { Error } If the device is not initialized
     */
    get device() {
      if (!this.__device) throw new Error("Device Not Initialized");
      const loaded = this.__device.loaded;
      if (!loaded) throw new Error("Device Not Loaded");
      return this.__device;
    }
    // !important
    // Consumer creation tasks awaiting to be processed.
    // Stores the lables of the pending consumers { producerId: string ==> Promise<Consumer> }
    __pendingConsumerTasks = /* @__PURE__ */ new Map();
    // !important
    // Producer creation tasks awaiting to be processed.
    // Stores the lables of the pending producers { label: string }
    // Used to handle transport callbacks most important;
    __pendingProducerTasks = /* @__PURE__ */ new Map();
    // !important
    // Map to store pending tasks, Stores the label and the promise of the task
    __pendingTasks = /* @__PURE__ */ new Map();
    /**
     * Pending Transport Tasks, Stores the transportType and the promise of the transport
     *
     * `NOTE: Useful to check if the transport is already being created and pause all producing
     * and consuming until the transport is created`
     */
    __pendingTransportTasks = /* @__PURE__ */ new Map();
    /**
     * Stores all the pending fetching stream tasks which are awaiting to be processed
     * If fetching called multiple times at once, it will handle the concurrency issues
     */
    __pendingFetchingStream = /* @__PURE__ */ new Map();
    /**
     * Stores all the pending produce tasks which are awaiting to be processed
     * Mostly used when the room is not joined and produce functionality needs to be handled
     *
     * Cases such as socket experiencing a reconnect and produce is called.
     * Or in the cases where room is not joined and enableVideo or enableAudio is called
     */
    __waitingToProduce = /* @__PURE__ */ new Map();
    /**
     * Stores all the pending consume tasks which are waiting for recv transport to be re-connected
     */
    __waitingToConsume = [];
    /**
     * DeviceHandler Instance, Handles the media devices for this client
     * e.g. Camera, Microphone
     */
    deviceHandler = new DeviceHandler_default();
    /**
     * ActiveStream Map holds MediaStream as Value and Key as Label
     */
    __activeStreams = /* @__PURE__ */ new Map();
    /**
     * Handle the Client Side Permission for the Local Peer.
     */
    __permissions = Permissions_default.createInstance();
    /**
     * Stores the Metadata for the Local Peer.
     */
    __metadata = null;
    /**
     * Variable to check if the user has joined the room
     */
    joined = false;
    /**
     * Variable to know if Volatile Messaging is enabled for the LocalPeer,
     * when using Volatile Messaging, the messages are sent over UDP using WebRTC
     * which makes the messages faster but not reliable and have much higher rate limit
     * and lower Latency.
     */
    __volatileMessaging = false;
    /**
     * Return the labels of the Media Stream that the Local Peer is producing to the room
     */
    get labels() {
      const sendTransport = this.__sendTransport;
      if (sendTransport) {
        const labels = Array.from(sendTransport.labelToProducerId.keys());
        return labels;
      }
      return [];
    }
    /**
     * Get the Permissions of the Local Peer. (e.g canProduce, canConsume, canSendData, canRecvData etc)
     */
    get permissions() {
      const acl = this.__permissions.acl;
      return acl;
    }
    /**
     * Get the Role of the Local Peer.
     */
    get role() {
      return this.__permissions.role;
    }
    /**
     * Returns the token of the current socket connection, specific to the Local Peer who joined the meeting
     */
    get token() {
      return this.socket.token;
    }
    /**
     * Returns the roomId of the current joined room.
     */
    get roomId() {
      return this.room.roomId;
    }
    /**
     * Returns the SendTransport
     * @returns { Transport } SendTransport
     * @throws { Error } If the SendTransport is not initialized
     */
    get sendTransport() {
      if (!this.__sendTransport)
        throw new Error("Send Transport Not Initialized");
      return this.__sendTransport;
    }
    /**
     * Returns the recvTransport
     * @returns { Transport } recvTransport
     * @throws { Error } If the recvTransport is not initialized
     */
    get recvTransport() {
      if (!this.__recvTransport)
        throw new Error("Recv Transport Not Initialized");
      return this.__recvTransport;
    }
    /**
     * Returns the metadata associated to the LocalPeer
     */
    getMetadata() {
      const data = JSON.parse(this.__metadata || "{}");
      return data;
    }
    /**
     * getStream returns the stream with the given label
     */
    getStream = (data) => {
      const stream = this.__activeStreams.get(data.label);
      if (stream === void 0) {
        return null;
      }
      return stream;
    };
    /**
     * Updates the metadata associated to the LocalPeer, Triggers the `metadata-updated` event
     * @param metadata
     */
    __updateMetadata = (metadata) => {
      this.__metadata = metadata;
      const parse = JSON.parse(metadata);
      this.emit("metadata-updated", {
        metadata: parse
      });
    };
    /**
     * Returns the producer with the given label
     * @param label - Identifier of the producer
     * @returns { Producer } Producer
     * @returns { null } If the producer is not found
     */
    getProducerWithLabel = (label) => {
      try {
        const producerId = this.__sendTransport?.labelToProducerId.get(label);
        if (!producerId) {
          throw new Error("\u274C Producer Not Found");
        }
        const producer = this.sendTransport.getProducerById(producerId);
        return producer;
      } catch (error) {
        logger11.error("\u274C Cannot Find Producer With Identifier: ", label);
        logger11.error(error);
        return null;
      }
    };
    /**
     * Registers the event handlers for the socket connection
     * @param socket - Socket Instance
     */
    __registerHandlerEvents = (socket) => {
      const keys = Object.keys(this.__handler);
      for (const key of keys) {
        try {
          const fn = this.__handler[key];
          if (fn) socket.subscribe(key, fn);
        } catch (error) {
          logger11.error(`\u274C Error Registered For Event: ${key}`);
          logger11.error(error);
        }
      }
      logger11.info("\u2705 LocalPeerEventHandler Registered");
    };
    /**
     * Can be used to check which `direction` of webRTC connection is currently active for the peer.
     *
     * **NOTE: Peers with role as Bot will not have `recv` transport;**
     * @param transportType
     */
    transportExists = (transportType) => {
      if (transportType === "recv") {
        return this.__recvTransport;
      }
      return this.__sendTransport;
    };
    static create(options) {
      if (_LocalPeer.__instance) {
        return _LocalPeer.__instance;
      }
      _LocalPeer.__instance = new _LocalPeer(options);
      return _LocalPeer.__instance;
    }
    static getInstance() {
      if (!_LocalPeer.__instance) {
        throw new Error("LocalPeer not initialized");
      }
      return _LocalPeer.__instance;
    }
    constructor(options) {
      super();
      this.__registerHandlerEvents(this.socket);
      if (options.handlerFactory) {
        this.__handlerFactory = options?.handlerFactory;
      }
      this.__volatileMessaging = options.volatileMessages ?? false;
      this.__registerInternalListeners();
    }
    /**
     * Destroy the current peer, closes all the transports, producers and consumers
     *
     * @param code - Close Code
     */
    close = () => {
      this.__device = null;
      this.joined = false;
      if (typeof navigator !== "undefined" && navigator.mediaDevices) {
        navigator.mediaDevices.ondevicechange = null;
      }
      this.__pendingConsumerTasks.clear();
      this.__pendingProducerTasks.clear();
      this.__pendingTransportTasks.clear();
      this.__pendingFetchingStream.clear();
      this.__waitingToProduce.clear();
      for (const stream of this.__activeStreams.values()) {
        for (const track of stream.getTracks()) track.stop();
      }
      this.deviceHandler.destroy();
      if (this.__sendTransport) {
        this.__sendTransport.close({ retries: 3 });
      }
      if (this.__recvTransport) {
        this.__recvTransport.close({ retries: 3 });
      }
      this.__sendTransport = null;
      this.__recvTransport = null;
      this.__permissions.reset();
      this.emit("permissions-updated", {
        permissions: this.permissions,
        role: this.role ?? ""
      });
    };
    /**
     * Produce a stream with a given label and appData to all the Remote Peers
     *
     * `canProduce must be true to produce a stream`
     *
     * `NOTE: This will notify all the RemotePeers that this producer has started producing and they should start consuming it if they want to`
     *
     * @param data - Data to produce a stream
     *  - `label` - Unique Identifier for the stream ( string )
     *  - `stream` - MediaStream to produce ( MediaStream )
     *  - `stopTrackOnClose` - If true, it will stop the track when the producer is closed using stopProducing ( boolean )
     *  - `appData` - Application level custom data which can be added to the producer for the LocalPeer, this data will be available in the producer object and can be used only by the LocalPeer. ( Unknown Object )
     *  - `prefferedCodec` - Preferred Codec to be used for the stream ( SupportedCodecs ), make sure the codec is supported by the device ( 'Browser' or 'ReactNative' )
     *
     * @summary This function is used to produce a stream with a given label and appData to all the Remote Peers if the send transport is not initialised
     * it will create a send transport and then produce the stream with the given label and appData to all the Remote Peers
     *
     * Send Transport is a secure channel which is used to send media from LocalPeer to all the RemotePeers in the room
     *
     * `localPeer.on('new-producer', ({label: string; producer: Producer}) => {})`
     *
     *  @throws { Error } If Failed to produce, Reason will be in the error message,
     * @throws { Error } if `prefferedCodec` is not supported by the Device ( 'Browser' or 'ReactNative' )
     */
    produce = checkPermissions({
      canProduce: true
    }).validate(
      async (data) => {
        try {
          const error = checkProducePermissions(data.label);
          if (error) {
            throw new Error("Access Denied: Cannot Produce");
          }
          const track = data.stream.getTracks()[0];
          if (track) {
            track.addEventListener("ended", () => {
              this.stopProducing({ label: data.label });
              if (data.label === "screen-share-audio") {
                this.stopProducing({ label: "screen-share-video" });
              }
            });
          }
          if (!this.joined || this.__sendTransport && this.__sendTransport?.connectionState !== "connected" && this.__sendTransport?.connectionState !== "new") {
            return new Promise((resolve) => {
              const fn = async () => {
                const producer2 = await this.produce(data).then((data2) => {
                  resolve(data2);
                  return data2;
                }).finally(() => {
                  this.__pendingProducerTasks.delete(data.label);
                });
                return producer2;
              };
              this.__waitingToProduce.set(data.label, fn);
            });
          }
          const { stream } = data;
          const producerPromise = this.__pendingProducerTasks.get(data.label);
          if (producerPromise) {
            logger11.info(
              "\u{1F514} Producer Task Already Pending for this label ",
              data.label
            );
            const producer2 = await producerPromise;
            return producer2;
          }
          if (!this.__sendTransport) {
            await this.__createTransportOnServer({
              transportType: "send"
            });
          }
          const ongoingPromise = this.__pendingProducerTasks.get(data.label);
          if (ongoingPromise) {
            const producer2 = await ongoingPromise;
            return producer2;
          }
          const promise = this.__createProducer({
            stream,
            label: data.label,
            appData: { ...data.appData, label: data.label },
            prefferedCodec: data.prefferedCodec,
            stopTrackOnClose: data.stopTrackOnClose
          });
          this.__pendingProducerTasks.set(data.label, promise);
          const producer = await promise.catch(() => {
            logger11.error("\u274C Error Create Producer Failed");
            throw new Error("\u274C Error Create Producer Failed");
          }).finally(() => {
            this.__pendingProducerTasks.delete(data.label);
          });
          return producer;
        } catch (error) {
          this.stopProducing({ label: data.label });
          throw new Error("\u274C Error Producing Stream, Can't Produce");
        }
      }
    );
    /**
     * Enables the local web cam and starts producing the stream with the label `video`
     * @param customVideoStream (Optional) Custom Video Stream to produce, if not provided it will fetch the stream from the device
     * @param prefferedCodec (Optional) Preferred Codec to be used for the stream ( SupportedCodecs ), make sure the codec is supported by the device ( 'Browser' or 'ReactNative' )
     *
     * @summary This functions handle the producing of media streams to all the remote peers in the room.
     * it enables the local web cam fetches the stream opens you web cam indicator light on the device
     * upon successfull fetching of the stream it produces the stream with the label `video` and `stopTrackOnClose: true` to all the remote peers in the room.
     * when closing using disableVideo it will stop the local track and close the producer which will notify all the RemotePeers that this producer has stopped producing
     * and they should stop consuming it.
     *
     * `NOTE: You can only produce to a room when you have joined the room, if you try to produce before joining the room it will throw an error`
     *
     * @throws { Error } If the stream is not found
     * @throws { Error } If Preffered Codec is not supported by the Device ( 'Browser' or 'ReactNative' )
     * @throws { Error } If Failed to produce, Reason will be in the error message
     */
    enableVideo = checkPermissions({
      canProduce: true,
      canProduceSources: { cam: true }
    }).validate(
      async (data) => {
        try {
          const existingStream = this.__activeStreams.get("video");
          if (existingStream) {
            logger11.warn("\u{1F514} Cam Stream Already Enabled");
            return;
          }
          let stream;
          if (data?.customVideoStream) {
            stream = data?.customVideoStream;
          } else {
            const ongoingStreamPromise = this.__pendingFetchingStream.get("cam");
            if (ongoingStreamPromise) {
              await ongoingStreamPromise;
            } else {
              const streamPromise = this.deviceHandler.fetchStream({
                mediaDeviceKind: "cam"
              });
              this.__pendingFetchingStream.set("cam", streamPromise);
            }
            const pendingPromise = this.__pendingFetchingStream.get("cam");
            if (!pendingPromise) {
              logger11.info("\u{1F514} Pending Promise Not Found");
              return;
            }
            const { stream: fetchedStream, error } = await pendingPromise;
            if (error) {
              logger11.error("\u274C Error Fetching Stream From Device");
              logger11.error(error);
              throw new Error("\u274C Error Fetching Stream From Device");
            }
            if (!fetchedStream) {
              logger11.error("\u274C Stream Not Found, cannot do enableVideo");
              throw new Error("\u274C Stream Not Found");
            }
            stream = fetchedStream;
          }
          this.__activeStreams.set("video", stream);
          this.emit("stream-fetched", {
            mediaKind: "cam",
            label: "video",
            stream
          });
          this.produce({
            label: "video",
            stream,
            appData: {
              producerPeerId: this.peerId
            },
            stopTrackOnClose: true,
            prefferedCodec: "video/vp9"
          }).then(() => {
            this.__pendingProducerTasks.delete("video");
          }).catch((error) => {
            logger11.error("\u274C Error Producing Video");
            this.deviceHandler.stopStream(this.__activeStreams.get("video"));
            this.__activeStreams.delete("video");
            this.__pendingFetchingStream.delete("cam");
            logger11.error(error);
          });
          this.__pendingFetchingStream.delete("cam");
          return stream;
        } catch (error) {
          logger11.error("\u274C Error Enabling Video", error);
          this.deviceHandler.stopStream(this.__activeStreams.get("video"));
          this.__activeStreams.delete("video");
          this.__pendingFetchingStream.delete("cam");
          throw error;
        }
      }
    );
    /**
     * Enables the local screen share  and starts producing the screen sharing stream
     *
     * @param prefferedCodec (Optional) Preferred Codec to be used for the stream ( SupportedCodecs ), make sure the codec is supported by the device ( 'Browser' or 'ReactNative' )
     *
     *`NOTE: You can only produce to a room when you have joined the room, if you try to produce before joining the room it will fetch the stream and start producing when you join the room`
     *
     * @summary This functions handle the producing of media streams to all the remote peers in the room.
     * it enables the local mic fetches the stream opens you mic active indicator light on the device
     * upon successfull fetching of the stream it produces the stream with the label `audio` and `stopTrackOnClose: true` to all the remote peers in the room.
     * when closing using `disableAudio` it will stop the local audio track and close the producer which will notify all the RemotePeers that this producer has stopped producing
     * and they should stop consuming it.
     *
     * @throws { Error } If Preffered Codec is not supported by the Device ( 'Browser' or 'ReactNative' )
     * @throws { Error } If Failed to produce, Reason will be in the error message
     */
    startScreenShare = checkPermissions({
      canProduce: true,
      canProduceSources: { screen: true }
    }).validate(async (data) => {
      try {
        const existingStream = this.__activeStreams.get("screen-share");
        if (existingStream) {
          logger11.warn("\u{1F514} Screen Stream Already Enabled");
          return;
        }
        const onGoingStreamPromise = this.__pendingFetchingStream.get("screen-share");
        if (onGoingStreamPromise) {
          await onGoingStreamPromise;
        } else {
          const streamPromise = this.deviceHandler.fetchScreen();
          this.__pendingFetchingStream.set("screen-share", streamPromise);
        }
        const pendingPromise = this.__pendingFetchingStream.get("screen-share");
        if (!pendingPromise) {
          logger11.info("\u{1F514} Pending Screen Share Promise Not Found");
          return;
        }
        const { stream, error } = await pendingPromise;
        if (error) {
          logger11.error("\u274C Error Fetching Screen Share Stream From Device");
          logger11.error(error);
          throw new Error("\u274C Error Fetching Screen ShareStream From Device");
        }
        if (!stream) {
          logger11.error("\u274C Stream Not Found, cannot do startScreenShare");
          throw new Error("\u274C Stream Not Found, cannot do startScreenShare");
        }
        this.__activeStreams.set("screen-share", stream);
        this.emit("stream-fetched", {
          mediaKind: "screen",
          label: "screen-share",
          stream
        });
        const videoTrack = stream.getVideoTracks()?.[0];
        const audioTrack = stream.getAudioTracks()?.[0];
        const videoProduce = async () => {
          return this.produce({
            label: "screen-share-video",
            stream: new MediaStream([videoTrack]),
            appData: {
              producerPeerId: this.peerId
            },
            stopTrackOnClose: true,
            prefferedCodec: data?.prefferedCodec
          });
        };
        const audioProduce = async () => {
          return this.produce({
            label: "screen-share-audio",
            stream: new MediaStream([audioTrack]),
            appData: {
              producerPeerId: this.peerId
            },
            stopTrackOnClose: true
          });
        };
        if (videoTrack) {
          videoProduce().then(() => {
            this.__pendingProducerTasks.delete("screen-share-video");
          }).catch((error2) => {
            logger11.error("\u274C Error Producing Screen Share Video");
            this.deviceHandler.stopStream(
              this.__activeStreams.get("screen-share")
            );
            this.__activeStreams.delete("screen-share");
            logger11.error(error2);
          });
        }
        if (audioTrack) {
          audioProduce().then(() => {
            this.__pendingProducerTasks.delete("screen-share-audio");
          }).catch((error2) => {
            logger11.error("\u274C Error Producing Audio");
            this.deviceHandler.stopStream(
              this.__activeStreams.get("screen-share")
            );
            this.__activeStreams.delete("screen-share");
            logger11.error(error2);
          });
        }
        this.__pendingFetchingStream.delete("screen-share");
        return stream;
      } catch (error) {
        logger11.error("\u274C Error Enabling Screen Share");
        logger11.error(error);
        this.deviceHandler.stopStream(this.__activeStreams.get("screen-share"));
        this.__activeStreams.delete("screen-share");
        this.__pendingFetchingStream.delete("screen-share");
        throw error;
      }
    });
    /**
     * Enables the local mic and starts producing the stream with the label `audio`
     * @param customVideoStream (Optional) Custom Video Stream to produce, if not provided it will fetch the stream from the device
     * @param prefferedCodec (Optional) Preferred Codec to be used for the stream ( SupportedCodecs ), make sure the codec is supported by the device ( 'Browser' or 'ReactNative' )
     *
     * @summary This functions handle the producing of media streams to all the remote peers in the room.
     * it enables the local mic fetches the stream opens you mic active indicator light on the device
     * upon successfull fetching of the stream it produces the stream with the label `audio` and `stopTrackOnClose: true` to all the remote peers in the room.
     * when closing using `disableAudio` it will stop the local audio track and close the producer which will notify all the RemotePeers that this producer has stopped producing
     * and they should stop consuming it.
     *
     * `NOTE: You can only produce to a room when you have joined the room, if you try to produce before joining the room it will fetch the stream and start producing when you join the room`
     *
     * @throws { Error } If the stream is not found
     * @throws { Error } If Preffered Codec is not supported by the Device ( 'Browser' or 'ReactNative' )
     * @throws { Error } If Failed to produce, Reason will be in the error message
     */
    enableAudio = checkPermissions({
      canProduce: true,
      canProduceSources: { mic: true }
    }).validate(
      async (data) => {
        try {
          const existingStream = this.__activeStreams.get("audio");
          if (existingStream) {
            logger11.warn("\u{1F514} Mic Stream Already Enabled");
            return;
          }
          let stream;
          if (data?.customAudioStream) {
            stream = data?.customAudioStream;
          } else {
            const ongoingStreamPromise = this.__pendingFetchingStream.get("mic");
            if (ongoingStreamPromise) {
              await ongoingStreamPromise;
            } else {
              const streamPromise = this.deviceHandler.fetchStream({
                mediaDeviceKind: "mic"
              });
              this.__pendingFetchingStream.set("mic", streamPromise);
            }
            const pendingPromise = this.__pendingFetchingStream.get("mic");
            if (!pendingPromise) {
              logger11.info("\u{1F514} Pending Mic Promise Not Found");
              return;
            }
            const { stream: fetchedStream, error } = await pendingPromise;
            if (error) {
              logger11.error("\u274C Error Fetching Stream From Device");
              logger11.error(error);
              throw new Error("\u274C Error Fetching Stream From Device");
            }
            if (!fetchedStream) {
              logger11.error("\u274C Stream Not Found, cannot do enableAudio");
              throw new Error("\u274C Stream Not Found");
            }
            stream = fetchedStream;
          }
          this.__activeStreams.set("audio", stream);
          this.emit("stream-fetched", {
            mediaKind: "mic",
            stream,
            label: "audio"
          });
          this.produce({
            label: "audio",
            stream,
            appData: {
              producerPeerId: this.peerId
            },
            stopTrackOnClose: true,
            prefferedCodec: data?.prefferedCodec
          }).then(() => {
            this.__pendingProducerTasks.delete("audio");
          }).catch((error) => {
            logger11.error("\u274C Error Producing Audio");
            this.deviceHandler.stopStream(this.__activeStreams.get("audio"));
            this.__activeStreams.delete("audio");
            logger11.error(error);
          });
          this.__pendingFetchingStream.delete("mic");
          return stream;
        } catch (error) {
          logger11.error("\u274C Error Enabling Audio");
          logger11.error(error);
          this.deviceHandler.stopStream(this.__activeStreams.get("audio"));
          this.__activeStreams.delete("audio");
          this.__pendingFetchingStream.delete("mic");
          throw error;
        }
      }
    );
    /**
     * Stops the underlying producing of a stream for a particular label
     *
     * `NOTE: This will notify all the RemotePeers that this producer has stopped producing and they should stop consuming it.`
     *
     * @param data Data to stop producing { label: string }
     */
    stopProducing = (data) => {
      this.__waitingToProduce.delete(data.label);
      this.__pendingProducerTasks.delete(data.label);
      let closedStream = false;
      const producer = this.getProducerWithLabel(data.label);
      if (producer) {
        if (!producer.closed) producer.close();
        closedStream = true;
        this.socket.publish("closeProducer", {
          producerId: producer.id
        });
      }
      const closedStreamLabel = data.label.startsWith("screen-share") ? "screen-share" : data.label;
      const stream = this.__activeStreams.get(closedStreamLabel);
      if (stream) {
        this.deviceHandler.stopStream(stream);
        this.__activeStreams.delete(closedStreamLabel);
        closedStream = true;
      }
      if (closedStream) {
        this.emit("stream-closed", {
          label: data.label,
          reason: {
            code: 1200,
            tag: "STREAM_CLOSED",
            message: "Stopped Streaming"
          }
        });
      }
    };
    /**
     * Stops the underlying producing of a camera stream, stops the local track and closes the producer
     *
     * `NOTE: This will notify all the RemotePeers that this producer has stopped producing and they should stop consuming it. if you have joined the room, else it will just close the stream`
     *
     * @param data Data to stop producing { label: string }
     */
    disableVideo = async () => {
      this.stopProducing({
        label: "video"
      });
    };
    /**
     * Replaces the current video stream with the new stream
     *
     * if you have produced a stream with label `video` or used the default function `enableVideo` and you want to replace it with a new stream
     * @param stream - New Video Stream
     */
    replaceVideoStream = async (stream) => {
      await this.replaceStream({
        label: "video",
        newStream: stream
      });
    };
    /**
     * Changes the Video source to the given deviceId, sets the preferred cam device as the given deviceId
     * @param deviceId
     */
    changeVideoSource = async (deviceId) => {
      this.deviceHandler.setPreferredDevice({
        deviceId,
        deviceKind: "cam"
      });
      const stream = this.__activeStreams.get("video");
      if (!stream) {
        return;
      }
      const { stream: newStream } = await this.deviceHandler.fetchStream({
        mediaDeviceKind: "cam"
      });
      if (!newStream) return;
      await this.replaceVideoStream(newStream);
    };
    /**
     * Replaces the current audio stream with the new stream
     * if you have produced a stream with label `audio` or used the default function `enableAudio` and you want to replace it with a new stream
     * @param stream - New Audio Stream
     *
     */
    replaceAudioStream = async (stream) => {
      await this.replaceStream({
        label: "audio",
        newStream: stream
      });
    };
    /**
     * Replace the current stream with the new stream based on the label used to produce the stream
     *
     * @example
     * For Video
     * await localPeer.replaceStream({
     *  label: 'video',
     *  newStream: newStream
     * })
     *
     * If any custom label used
     * await localPeer.replaceStream({
     *  label: 'custom',
     *  newStream: newStream
     * })
     *
     * @param data - { label: string, newStream: MediaStream }
     * @throws { Error } - If replace Stream failed
     */
    replaceStream = async (data) => {
      logger11.info(`\u{1F514} Replacing ${data.label} Stream `);
      const producer = this.getProducerWithLabel(data.label);
      const track = data.newStream.getTracks()[0];
      if (track) {
        track.addEventListener("ended", () => {
          this.stopProducing({ label: data.label });
        });
      }
      if (producer) {
        if (producer.paused) {
          track.enabled = false;
        }
        await producer.replaceTrack({ track });
      }
      const closedStreamLabel = data.label.startsWith("screen-share") ? "screen-share" : data.label;
      const prevStream = this.__activeStreams.get(closedStreamLabel);
      if (prevStream && !this.__waitingToProduce.has(closedStreamLabel)) {
        this.deviceHandler.stopStream(prevStream);
        this.__activeStreams.delete(closedStreamLabel);
        this.__activeStreams.set(closedStreamLabel, data.newStream);
      } else if (prevStream && this.__waitingToProduce.has(closedStreamLabel)) {
        for (const track2 of prevStream.getTracks()) {
          prevStream.removeTrack(track2);
          track2.stop();
        }
        for (const track2 of data.newStream.getTracks()) {
          prevStream.addTrack(track2);
        }
      }
      const mediaDeviceKind = getMediaDeviceKind(track);
      this.emit("stream-fetched", {
        label: data.label,
        stream: data.newStream,
        mediaKind: mediaDeviceKind
      });
    };
    /**
     * Changes the Audio source to the given deviceId, sets the preferred mic device as the given deviceId
     * @param deviceId
     */
    changeAudioSource = async (deviceId) => {
      this.deviceHandler.setPreferredDevice({
        deviceId,
        deviceKind: "mic"
      });
      const stream = this.__activeStreams.get("audio");
      if (!stream) {
        return;
      }
      const { stream: newStream } = await this.deviceHandler.fetchStream({
        mediaDeviceKind: "mic"
      });
      if (!newStream) return;
      await this.replaceAudioStream(newStream);
    };
    /**
     * Stops the underlying producing of a microphone stream, stops the local track and closes the producer
     *
     * `NOTE: This will notify all the RemotePeers that this producer has stopped producing and they should stop consuming it.`
     */
    disableAudio = async () => {
      this.stopProducing({
        label: "audio"
      });
    };
    /**
     * Pauses the audio stream, pauses the underlying producer but does not stop the local track - useful when user has joined the room and wants to pause the audio stream which is faster than disabling the audio stream
     *
     * `NOTE: Only use this function when peer has joined the room else use disableAudio, The LocalPeer will not be producing any audio stream but the local track will still be active, you can resume the audio stream using resumeAudio or stop the audio stream using disableAudio`
     *
     * @throws Error - If Pausing Audio Failed, it will disable the audio stream, and throw an error
     */
    pauseAudio = async () => {
      try {
        logger11.debug("\u{1F514} Pausing Audio Stream");
        const audioStream = this.__activeStreams.get("audio");
        if (!audioStream) {
          logger11.error(
            "\u274C No Audio Stream Found, use enableAudio to enable audio first before pausing"
          );
          return;
        }
        const track = audioStream.getAudioTracks()[0];
        if (!track) {
          logger11.error(
            "\u274C No Audio Track Found, use enableAudio to enable audio first before pausing"
          );
          return;
        }
        const producer = this.getProducerWithLabel("audio");
        if (!producer) {
          throw new Error("\u274C Cannot Pause Audio, Producer not found");
        }
        producer.pause();
        this.socket.publish("pauseProducer", {
          producerId: producer.id
        });
        this.emit("stream-paused", {
          label: "audio",
          mediaKind: "mic"
        });
      } catch (error) {
        logger11.error("Error Pausing Audio", error);
        await this.disableAudio();
        throw error;
      }
    };
    /**
     * Resumes the audio stream, resumes the underlying producer and starts producing the audio stream - useful when user has `joined the room` and wants to resume the audio stream
     *
     * `Note: Works only if the audio stream is paused using pauseAudio`
     *
     * @throws Error - If Resuming Audio Failed, it will disable the audio stream, and throw an error
     */
    resumeAudio = async () => {
      try {
        logger11.debug("\u{1F514} Resuming Audio Stream");
        const audioStream = this.__activeStreams.get("audio");
        if (!audioStream) {
          logger11.error(
            "\u274C No Audio Stream Found, use enableAudio to enable audio first before resuming"
          );
          return;
        }
        const track = audioStream.getAudioTracks()[0];
        if (!track) {
          logger11.error(
            "\u274C No Audio Track Found, use enableAudio to enable audio first before resuming"
          );
          return;
        }
        const producer = this.getProducerWithLabel("audio");
        if (!producer) {
          throw new Error("\u274C Cannot Resume Audio, Producer not found");
        }
        producer.resume();
        this.socket.publish("resumeProducer", {
          producerId: producer.id
        });
        this.emit("stream-playable", {
          label: "audio",
          producer
        });
      } catch (error) {
        logger11.error("Error Resuming Audio", error);
        await this.disableAudio();
        throw error;
      }
    };
    /**
     * Stops the underlying producing of a screen-share stream, stops the local track and closes the producer
     *
     * `NOTE: This will notify all the RemotePeers that this producer has stopped producing and they should stop consuming it. if you have joined the room, else it will just close the stream`
     */
    stopScreenShare = async () => {
      try {
        this.stopProducing({
          label: "screen-share-video"
        });
        this.stopProducing({
          label: "screen-share-audio"
        });
      } catch (error) {
        logger11.error("Error Disabling Screen Share", error);
      }
    };
    /**
     * Consumes a stream with the producerId and peerId of the RemotePeer, appData is application level custom data which
     * can be added to the consumer for the LocalPeer, this data will be available in the consumer object and can be used only by the LocalPeer.
     *
     * `NOTE: This will not notify the RemotePeers that you are consuming a stream, you have to notify them manually`
     * @summary Every time a RemotePeer is producing a Media in the Room, LocalPeer will be notified about it and it will be able to consume it.
     * Consuming is a process where the media is received from the RemotePeer and the stream can be played on the LocalPeers device.
     *
     * To get the consumer back you can use
     *
     * const remotePeer = this.room.getRemotePeerById(data.peerId);
     *
     * `remotePeer.on('stream-playable', ({ label: string; consumer: Consumer }) => {})`
     *
     * @param data - {peerId: string, label: string, appData: Record<string, unknown>}
     * @throws { Error } - If Consuming Stream Failed
     */
    consume = checkPermissions({
      canConsume: true
    }).validate(
      async (data) => {
        const remotePeer = this.__remotePeers.get(data.peerId);
        if (!remotePeer) {
          throw new Error(`Remote Peer Not Found with PeerId ${data.peerId}`);
        }
        const labelData = remotePeer.getLabelData(data.label);
        if (!labelData) {
          throw new Error(
            `Remote Peer is not producing with Label ${data.label}`
          );
        }
        const consumerExists = remotePeer.getConsumer(data.label);
        if (consumerExists?.consuming) {
          logger11.warn("\u{1F514} Consumer Already Exists with label ", data.label);
          return consumerExists;
        }
        const pendingPromise = this.__pendingConsumerTasks.get(
          labelData?.producerId
        );
        if (pendingPromise) {
          logger11.warn(
            `\u{1F514} Consumer Task Pending to be Consumed with label ${data.label}, Returning`
          );
          const consumer2 = await pendingPromise;
          return consumer2;
        }
        logger11.info("\u{1F514} Consuming Stream with label ", data.label);
        if (!this.__recvTransport) {
          logger11.info(
            "\u{1F514} Recv Transport Not Initialized, Creaitng RecvTransport"
          );
          await this.__createTransportOnServer({
            transportType: "recv"
          });
        }
        const consumerPromise = new Promise((resolve, reject) => {
          const resolveConsumer = (streamData) => {
            if (streamData.label === data.label) {
              remotePeer.off("stream-playable", resolveConsumer);
              remotePeer.off("stream-available", resolveConsumer);
              const consumer2 = remotePeer.getConsumer(data.label);
              if (!consumer2) {
                reject(new Error("\u274C Consumer Not Found"));
              } else {
                if (consumer2.paused) {
                  remotePeer.emit("stream-paused", {
                    label: data.label,
                    peerId: consumer2.producerPeerId,
                    producerId: consumer2.producerId
                  });
                }
                resolve(consumer2);
              }
            }
          };
          remotePeer.once("stream-playable", resolveConsumer);
          remotePeer.once("stream-available", resolveConsumer);
          this.socket.publish("consume", {
            appData: data.appData,
            producerId: labelData.producerId,
            producerPeerId: data.peerId
          });
        });
        this.__pendingConsumerTasks.set(labelData.producerId, consumerPromise);
        const consumer = await consumerPromise.catch((error) => {
          logger11.error("\u274C Error Consuming Stream");
          logger11.error(error);
          throw error;
        }).finally(() => {
          this.__pendingConsumerTasks.delete(labelData.producerId);
        });
        return consumer;
      }
    );
    /**
     * Stops the underlying consuming of a stream for a particular label
     *
     * `NOTE: This does not notify the remote peers that you are not consuming a stream`
     *
     * @param data
     */
    stopConsuming = (data) => {
      const remotePeer = this.room.getRemotePeerById(data.peerId);
      if (!remotePeer.hasLabel(data.label)) {
        logger11.error(
          `\u274C Remote Peer is not producing anything with label: ${data.label}`
        );
        return;
      }
      const consumer = this.recvTransport.getConsumer(data);
      if (!consumer) {
        logger11.error("\u274C Consumer Not Found", data);
        return;
      }
      if (!consumer.consuming) {
        logger11.error("\u274C You are not Consuming any Stream, Consumer Not Found");
        return;
      }
      const consumerId = consumer.id;
      if (!consumerId) {
        logger11.error("\u274C ConsumerId Not Found");
        return;
      }
      this.socket.publish("closeConsumer", {
        consumerId: consumer.id
      });
      remotePeer.emit("stream-closed", {
        label: data.label
      });
      this.recvTransport.closeConsumer(data);
    };
    /**
     * Activate Sending and Receving Volatile Messages, which uses WebRTC DataChannels over UDP
     * to send messages to the RemotePeers in the Room, this is faster than sending messages over WebSockets and has much lower Rate Limiting
     * Prefer using this for sending burst messages to the RemotePeers in the Room
     * @returns { ok: boolean, error?: Error } - error will be present if failed to activate volatile messaging
     */
    __activateVolatileMessaging = async () => {
      try {
        logger11.info("\u{1F514} Activating Volatile Messages");
        const ongoingTask = this.__pendingTasks.get("volatileMessaging");
        if (ongoingTask) {
          logger11.debug("\u{1F514} Already Activating Volatile Message");
          await ongoingTask;
          return {
            ok: true
          };
        }
        const botDataConsumer = this.__sendTransport?.dataConsumers.get("bot");
        if (botDataConsumer) {
          logger11.debug("\u{1F514} Bot Data Consumer Already Exists");
          return {
            ok: true
          };
        }
        const ongoingActiveSpeakerPromise = this.__pendingTasks.get("volatileMessaging");
        if (ongoingActiveSpeakerPromise) {
          logger11.debug("\u{1F514} Bot Data Consumer Task Pending");
          await ongoingActiveSpeakerPromise;
          return {
            ok: true
          };
        }
        const fn = async () => {
          if (!this.__recvTransport) {
            await this.__createTransportOnServer({
              transportType: "recv"
            });
          }
          if (!this.__sendTransport) {
            await this.__createTransportOnServer({
              transportType: "send"
            });
          }
          await this.__createDataProducer({
            label: "bot",
            maxRetransmits: 3,
            ordered: false
          });
        };
        const promise = fn();
        this.__pendingTasks.set("volatileMessaging", promise);
        await promise;
        return {
          ok: true
        };
      } catch (error) {
        logger11.error(
          "\u274C Error Activating Speakers Notification Functionality",
          error
        );
        return {
          ok: false,
          error: new Error(
            `Error: Activating Speakers Notification Functionality, ${error}`
          )
        };
      }
    };
    /**
     * Send Data Gives the functionality to send data to other remote peers or the whole room,
     * NOTE: This will be sent over WebSockets which are over TCP which will be slower and can be rate limited.
     * @returns { success: boolean, error?: string } - error will be present if failed to send data
     */
    sendData = checkPermissions({
      canSendData: true
    }).validate(
      async (data) => {
        try {
          if (estimateSize(data.payload) > MAX_DATA_MESSAGE_SIZE) {
            logger11.error("\u274C Data message exceeds 1kb in size");
            return {
              success: false,
              error: "Data message exceeds 1kb in size"
            };
          }
          const parsedTo = data.to === "*" ? ["*"] : data.to;
          this.socket.publish("sendData", {
            to: parsedTo,
            payload: data.payload,
            label: data.label
          });
          return {
            success: true
          };
        } catch (error) {
          logger11.error("\u274C Error Sending Data");
          logger11.error(error);
          return {
            success: false,
            error: "Error Sending Data"
          };
        }
      }
    );
    /**
     * Send Volatile Data Gives the functionality to send data to other remote peers or the whole room,
     * NOTE: This will be sent over WebRTC DataChannels which are over UDP which will be faster and can be rate limited.
     * @returns { ok: boolean } - if the volatile data was sent, cannot guarantee if the data was received as its over UDP
     */
    sendVolatileData = checkPermissions({
      canSendData: true
    }).validate(async (data) => {
      try {
        if (!this.joined) {
          throw new Error(
            "\u274C Cannot Send Volatile Data, You have not joined the room yet"
          );
        }
        if (!this.peerId) {
          throw new Error("\u274C Cannot Send Volatile Data, PeerId Not Found");
        }
        if (estimateSize(data) > MAX_DATA_MESSAGE_SIZE) {
          logger11.error("\u274C Data message exceeds 1kb in size");
          return;
        }
        this.room.bot?.sendData({
          from: this.peerId,
          label: data.label,
          payload: data.payload,
          to: "*"
        });
      } catch (error) {
        logger11.error("\u274C Error Sending Volatile Data", error);
      }
    });
    /**
     * Send Message to update the metadata of the Local Peer
     *
     * `NOTE: This will notify every user in the room about the metadata update`
     *
     * @emits `localPeer.on(metadata-updated)` on succesful metadata update
     *
     * @throws { Error } - if unable to update Metadata for the peer.
     */
    updateMetadata = checkPermissions({
      canUpdateMetadata: true
    }).validate(async (data) => {
      if (!this.joined) {
        logger11.error(
          "\u274C Cannot Update Metadata, You have not joined the room yet"
        );
        return;
      }
      const peerId = this.peerId;
      if (!peerId) {
        logger11.error("\u274C Cannot Update Metadata, PeerId Not Found");
        return;
      }
      const newMetadata = JSON.stringify(data);
      this.socket.publish("updatePeerMetadata", {
        peerId,
        metadata: newMetadata
      });
    });
    /**
     * Update the role of the Remote Peer in the Room, this will emit an event `updated` with the updated role.
     *
     * @emits `localPeer.on('role-updated') in case role update was successful.
     */
    updateRole = (data) => {
      try {
        if (!this.joined) {
          throw new Error(
            "\u274C Cannot Update Role, You have not joined the room yet"
          );
        }
        if (data.role === this.role) {
          logger11.warn("\u{1F514} Peer Role is already set to", data.role);
          return;
        }
        if (!this.peerId) {
          logger11.error(
            "\u274C Cannot Update Role, PeerId Not Found, (You have not joined the room yet)"
          );
          return;
        }
        this.socket.publish("updatePeerRole", {
          peerId: this.peerId,
          role: data.role,
          options: data.options
        });
      } catch (error) {
        logger11.error("\u{1F514} Error Updating Role", data);
        logger11.error(error);
      }
    };
    __handler = {
      error: (data) => {
        logger11.error("\u274C Error Event");
        logger11.error(data);
      },
      /**
       * When Huddle01 Node has successfully accepted the connection request
       * it sents back some usefull metadata for the client to use
       * at this point the socket is assumed to the connected and the localPeer is ready to join the room
       *
       * @param data - Data from server { peerId }
       */
      hello: (data) => {
        logger11.info("\u2705 Hello From Server, Connection Success", data);
        const { acl, peerId } = data;
        this.peerId = peerId;
        this.room.sessionId = data.sessionId;
        this.__permissions.updatePermissions(data.acl);
        if (data.role) this.__permissions.role = data.role;
        this.emit("permissions-updated", {
          permissions: acl,
          role: data.role
        });
        if (data.metadata) {
          this.__updateMetadata(data.metadata);
        }
      },
      waitingRoom: (data) => {
        logger11.info("\u{1F514} Waiting Room", data);
        this.room.emit("room-waiting", data);
      },
      /**
       * @description Uponn successful joining of the room, the server sends back some usefull metadata such as remotePeers in the room.
       * @emits "room-joined" - When the client has successfully joined the room.
       * @emits "join-error" - When the client has failed to join the room.
       * @param data - Data from server { roomId, roomInfo, routerRTPCapabilities, turnServer }
       */
      connectRoomResponse: async (data) => {
        logger11.info("\u2705 Join Success Event");
        try {
          const { roomInfo, routerRTPCapabilities, turnServers } = data;
          this.room.config = roomInfo.config;
          this.room.metadata = roomInfo.metadata ?? "{}";
          this.room.stats.startTime = roomInfo.startTime;
          const deviceType = (0, import_mediasoup_client.detectDevice)();
          if (!deviceType && !this.__handlerFactory) {
            logger11.error(
              "\u274C Device is not supported, valid devices are : 'Chrome111' | 'Chrome74' | 'Chrome70' | 'Chrome67' | 'Chrome55' | 'Firefox60' | 'Safari12' | 'Safari11' | 'Edge11' | 'ReactNativeUnifiedPlan' | 'ReactNative'"
            );
            throw new Error("\u274C Device is not supported");
          }
          this.__device = new import_mediasoup_client.Device({
            handlerName: deviceType,
            handlerFactory: this.__handlerFactory
          });
          const parsedRouterRtpCapabilites = parseRouterRtpCapabilities({
            codecs: routerRTPCapabilities.codecs,
            headerExtensions: routerRTPCapabilities.headerExtensions
          });
          await this.__device.load({
            routerRtpCapabilities: parsedRouterRtpCapabilites
          });
          if (!this.device.loaded) {
            throw new Error("\u274C Cannot Load Device");
          }
          this.emit("device-created", { device: this.__device });
          this.__setRemotePeers(roomInfo);
          this.__setLobbyPeers(roomInfo);
          if (turnServers?.length) {
            logger11.info("\u{1F514} Setting Turn Server", turnServers);
            this.__turn = [...turnServers, ...this.__turn];
          }
          this.room.state = "connected";
          this.joined = true;
          this.room.emit("room-joined");
        } catch (error) {
          logger11.error("\u274C Error Joining Room");
          logger11.error(error);
          this.room.emit("room-joined-failed", {
            message: "\u274C Error Joining Room",
            status: "ROOM_ERRORED"
          });
        }
        this.__handleWaitingToProduce();
      },
      /**
       * @description update the remote peers in the room , remove the remote peers which are not in the room anymore
       * @param roomInfo
       */
      syncMeetingStateResponse: async (data) => {
        try {
          logger11.info("\u2705 Client recovered after reconnecting", data);
          const { peers: latestPeers } = data.roomInfo;
          const latestPeersSet = new Set(latestPeers.map((p) => p.peerId));
          for (const [peerId, peer] of this.__remotePeers.entries()) {
            if (!latestPeersSet.has(peerId)) {
              for (const label of peer.labels) {
                this.__closeRemotePeerConsumer({
                  peerId,
                  label
                });
              }
              peer.close();
              this.__remotePeers.delete(peerId);
              this.room.emit("peer-left", {
                peerId,
                metadata: peer.getMetadata(),
                role: peer.role
              });
              continue;
            }
            const latestPeerInfo = latestPeers.find((p) => p.peerId === peerId);
            if (!latestPeerInfo) continue;
            const newProducerSet = new Set(
              latestPeerInfo.producers.map((p) => p.label)
            );
            for (const label of peer.labels) {
              if (!newProducerSet.has(label)) {
                this.__closeRemotePeerConsumer({ peerId, label });
              }
            }
            const currentProducerSet = new Set(peer.producerIds);
            for (const producer of latestPeerInfo.producers) {
              const addLabelData = () => {
                return peer._addLabelData({
                  producerId: producer.id,
                  label: producer.label
                });
              };
              if (!currentProducerSet.has(producer.id)) {
                if (!this.__recvTransport || this.__recvTransport.connectionState === "new" || this.__recvTransport.connectionState === "connected") {
                  addLabelData();
                } else {
                  this.__waitingToConsume.push(addLabelData);
                }
              } else {
                const consumer = peer.getConsumer(producer.label);
                const val = producer.paused ? consumer?.pause() : consumer?.resume();
                if (val && producer.paused) {
                  peer.emit("stream-paused", {
                    label: producer.label,
                    peerId,
                    producerId: producer.id
                  });
                } else if (val && !producer.paused && consumer) {
                  peer.emit("stream-playable", {
                    consumer,
                    label: producer.label
                  });
                }
              }
            }
          }
          const filteredPeers = latestPeers.filter(
            (latestPeer) => !this.__remotePeers.has(latestPeer.peerId) && latestPeer.peerId !== this.peerId
          ).values();
          for (const latestPeer of filteredPeers) {
            const remotePeer = new RemotePeer_default({
              peerId: latestPeer.peerId,
              role: latestPeer.role,
              metadata: latestPeer.metadata
            });
            this.__remotePeers.set(latestPeer.peerId, remotePeer);
            const remoteProducers = latestPeer.producers;
            for (const p of remoteProducers) {
              const addLabelData = () => {
                return remotePeer._addLabelData({
                  producerId: p.id,
                  label: p.label
                });
              };
              if (!this.__recvTransport || this.__recvTransport.connectionState === "new" || this.__recvTransport.connectionState === "connected") {
                addLabelData();
              } else {
                this.__waitingToConsume.push(addLabelData);
              }
            }
            this.room.emit("new-peer-joined", { peer: remotePeer });
          }
        } catch (error) {
          logger11.error("\u274C Error Syncing Meeting State, Can't Recover");
          logger11.error(error);
        }
      },
      /**
       * Upon creation of server side transport, the server sends back some usefull metadata for the client to use
       * to create a client side transport, i.e. `send | recv` Transport.
       * @param data - Data from server { transportSDPInfo, transportType }
       */
      createTransportOnClient: async (data) => {
        try {
          const device = this.device;
          if (!this.peerId) {
            throw new Error(
              "\u274C Cannot Create Transport, No PeerId Found for the user."
            );
          }
          const transport = Transport_default.create({
            device,
            peerId: this.peerId,
            socket: this.socket,
            sdpInfo: data.transportSDPInfo,
            iceServers: this.__turn,
            transportType: data.transportType
          });
          if (transport.transportType === "send") {
            this.__sendTransport = transport;
            this.__sendTransport.mediasoupTransport.on(
              "connectionstatechange",
              (connectionState) => {
                if (connectionState === "connected") {
                  this.__handleWaitingToProduce();
                }
              }
            );
            this.emit("new-send-transport", {
              transport
            });
          }
          if (transport.transportType === "recv") {
            this.__recvTransport = transport;
            this.__recvTransport.mediasoupTransport.on(
              "connectionstatechange",
              (connectionState) => {
                if (connectionState === "connected") {
                  this.__handleWaitingToConsume();
                }
              }
            );
            this.emit("new-recv-transport", {
              transport
            });
          }
        } catch (error) {
          logger11.error(
            "\u274C Error Creating MediasoupTransport On Client, transportType",
            data.transportType
          );
          logger11.error(error);
        }
      },
      /**
       * !Important
       * When the server has successfully connected the transport, it sends a ack back to the client
       * which handles the callback() function which triggers the process of creation of producer and consumer
       * for reference see: packages/nezuko/src/Transport.ts
       * @param data
       */
      connectTransportResponse: async (data) => {
        logger11.info(
          `\u2705 Connect ${data.transportType} Transport On Server Response`
        );
        try {
          const transportType = data.transportType;
          const transport = transportType === "send" ? this.__sendTransport : this.__recvTransport;
          if (!transport) {
            throw new Error(`${transportType} Transport Not Initialized`);
          }
          transport.emit("connectTransportResponse");
        } catch (error) {
          logger11.error("\u274C Error Connecting Transport On Server Response");
          logger11.error(error);
        }
      },
      produceResponse: async (data) => {
        logger11.info("\u2705 Produce Response", data);
        try {
          const { peerId, producerId, label } = data;
          if (peerId === this.peerId) {
            this.sendTransport.resolvePendingProducerTask({
              id: producerId,
              label,
              peerId
            });
          } else {
            const remotePeer = this.room.getRemotePeerById(peerId);
            if (!this.__recvTransport || this.__recvTransport.connectionState === "new" || this.__recvTransport.connectionState === "connected") {
              remotePeer._addLabelData({
                producerId,
                label
              });
            } else {
              this.__waitingToConsume.push(
                () => remotePeer._addLabelData({
                  producerId,
                  label
                })
              );
            }
          }
        } catch (error) {
          logger11.error("\u274C Error Produce Response");
          logger11.error(error);
        }
      },
      consumeResponse: async (data) => {
        logger11.info("\u2705 Consume Response", data);
        try {
          const remotePeer = this.room.getRemotePeerById(data.producerPeerId);
          if (!remotePeer.hasLabel(data.label)) {
            logger11.error("\u274C Remote Peer is not producing this label", {
              label: data.label
            });
            throw new Error(
              `\u274C Remote Peer is not producing this label: ${data.label}`
            );
          }
          const { consumer } = await this.recvTransport.consume({
            ...data,
            kind: data.kind,
            producerPaused: data?.producerPaused ?? false,
            rtpParameters: {
              codecs: data.rtpParameters.codecs,
              mid: data.rtpParameters.mid,
              encodings: data.rtpParameters.encodings,
              headerExtensions: data.rtpParameters.headerExtensions,
              rtcp: data.rtpParameters.rtcp
            }
          });
          this.socket.publish("resumeConsumer", {
            consumerId: data.consumerId,
            producerPeerId: data.producerPeerId
          });
          if (data?.producerPaused === false) {
            consumer.resume();
            this.room.emit("stream-added", {
              label: consumer.label,
              peerId: data.producerPeerId
            });
            remotePeer.emit("stream-playable", {
              consumer,
              label: consumer.label
            });
          } else {
            consumer.pause();
            remotePeer.emit("stream-available", {
              label: data.label,
              labelData: {
                producerId: data.producerId
              }
            });
          }
        } catch (error) {
          logger11.error("\u274C Error Consume Response");
          logger11.error(error);
          this.__pendingConsumerTasks.delete(data.producerId);
        }
      },
      resumeProducerSuccess: async (data) => {
        try {
          logger11.info("\u2705 Producer Resumed", data);
          if (data.peerId === this.peerId) return;
          const { peerId, label } = data;
          const remotePeer = this.room.getRemotePeerById(peerId);
          const consumer = this.recvTransport.getConsumer({ label, peerId });
          if (consumer && consumer.producerId === data.producerId) {
            consumer?.resume();
            remotePeer.emit("stream-playable", {
              label,
              consumer
            });
          }
        } catch (error) {
          logger11.error("\u274C Error Resuming Producer", error);
        }
      },
      pauseProducerSuccess: async (data) => {
        try {
          logger11.info("\u2705 Producer Paused", data);
          if (data.peerId === this.peerId) return;
          const { peerId, label, producerId } = data;
          const remotePeer = this.room.getRemotePeerById(peerId);
          const consumer = this.recvTransport.getConsumer({ label, peerId });
          if (consumer && consumer.producerId === producerId) {
            consumer?.pause();
            remotePeer.emit("stream-paused", {
              label,
              producerId,
              peerId
            });
          }
        } catch (error) {
          logger11.error("\u274C Error Pausing Producer", error);
        }
      },
      closeProducerSuccess: async (data) => {
        logger11.info("\u2705 Producer Closed", data);
        if (this.peerId === data.peerId) return;
        const { peerId, label } = data;
        try {
          this.__closeRemotePeerConsumer({
            peerId,
            label
          });
        } catch (err) {
          logger11.error("\u274C Error Closing Producer");
          logger11.error(err);
        }
      },
      closeConsumerSuccess: async (data) => {
        logger11.info("\u2705 Consumer Closed, ", data);
      },
      restartTransportIceResponse: async (data) => {
        const { transportType, iceParameters } = data;
        logger11.info("\u2705 Restart Transport Ice Response ", transportType);
        const transport = transportType === "send" ? this.__sendTransport : this.__recvTransport;
        if (!transport) {
          logger11.error(`\u274C ${transportType} Transport Not Found`);
          return;
        }
        try {
          await transport.mediasoupTransport.restartIce({
            iceParameters
          });
          logger11.info("\u2705 Restarted Ice for type: ", transportType);
          this.emit("ice-transport-restarted");
        } catch (error) {
          logger11.error("\u274C Error Restarting Ice for type: ", transportType);
          logger11.error(error);
        }
      },
      consumeDataResponse: async (data) => {
        logger11.info("\u2705 Consume Data Response, label", data.label);
        try {
          const {
            id,
            peerId,
            dataProducerId,
            label,
            protocol,
            sctpStreamParameters
          } = data;
          if (label === "bot") {
            const dataProducer = this.sendTransport.dataProducers.get("bot");
            const dataConsumer = await this.recvTransport.consumeData({
              id,
              dataProducerId,
              label,
              peerId,
              protocol,
              sctpStreamParameters,
              appData: {}
            });
            const bot = new Bot_default({ dataConsumer, dataProducer });
            const defaultSize = this.room.defaultActiveSpeakerSize;
            this.room.bot = bot;
            if (this.room.defaultActiveSpeakerSize > 0) {
              this.room.activeSpeakers = new ActiveSpeakers_default({
                bot,
                size: defaultSize
              });
            }
            this.__pendingTasks.delete("volatileMessaging");
          }
        } catch (error) {
          logger11.error("\u274C Error: Consume Data Response", error);
        }
      },
      produceDataResponse: async (data) => {
        logger11.info("\u2705 Produce Data Response consumerIdFromServer", data.id);
        try {
          const { peerId, dataProducerId, label } = data;
          if (peerId === this.peerId) {
            this.sendTransport.resolvePendingProducerTask({
              id: dataProducerId,
              label,
              peerId
            });
            const ongoinProducerTask = this.__pendingTasks.get("volatileMessaging");
            await ongoinProducerTask;
            if (label === "bot") {
              console.info(
                "\u{1F514} Bot Data Producer Created, Label 'bot'",
                this.sendTransport.dataProducers
              );
              const dataProducer = this.sendTransport.dataProducers.get("bot");
              const dataConsumer = await this.recvTransport.consumeData({
                id: data.id,
                dataProducerId,
                peerId,
                label,
                protocol: data.protocol,
                sctpStreamParameters: data.sctpStreamParameters,
                appData: {}
              });
              const defaultSize = this.room.defaultActiveSpeakerSize;
              this.room.bot = new Bot_default({ dataConsumer, dataProducer });
              if (this.room.defaultActiveSpeakerSize > 0) {
                this.room.activeSpeakers = new ActiveSpeakers_default({
                  bot: this.room.bot,
                  size: defaultSize
                });
              }
              this.__pendingTasks.delete("volatileMessaging");
            }
            return;
          }
          return;
        } catch (error) {
          logger11.error("\u274C Error Produce Data Response");
          logger11.error({ error });
        }
      },
      newPeerJoined: (data) => {
        if (this.peerId === data.peerId) return;
        logger11.info("\u2705 New Peer Joined", { data });
        try {
          const { peerId, role, metadata } = data;
          if (!peerId) {
            return;
          }
          const remotePeer = new RemotePeer_default({
            peerId,
            role,
            metadata
          });
          this.__remotePeers.set(peerId, remotePeer);
          const lobbyPeers = this.room.lobbyPeersMap;
          if (lobbyPeers.has(peerId)) {
            lobbyPeers.delete(peerId);
            this.room.lobbyPeersMap = lobbyPeers;
          }
          this.room.emit("new-peer-joined", { peer: remotePeer });
        } catch (error) {
          logger11.error("\u274C Error New Peer Joined");
          logger11.error(error);
        }
      },
      newLobbyPeer: (data) => {
        try {
          logger11.info("\u2705 New Lobby Peer", { data });
          const parsedData = data;
          this.room.newlobbyPeers = [parsedData];
        } catch (error) {
          logger11.error("\u274C Error New Lobby Peer");
          logger11.error(error);
        }
      },
      newPermissions: (data) => {
        try {
          const parsedData = data.acl;
          this.__permissions.updatePermissions(parsedData);
          this.emit("permissions-updated", {
            permissions: this.permissions
          });
        } catch (error) {
          logger11.error("\u274C Error Updating Permissions");
          logger11.error(error);
        }
      },
      newRoomControls: (data) => {
        logger11.info("\u2705 Received New Room Controls", { data });
        try {
          const { controls } = data;
          this.room.config = controls;
          this.room.emit("room-controls-updated");
        } catch (error) {
          logger11.error("\u274C Error Updating Room Controls");
          logger11.error(error);
        }
      },
      newPeerRole: (data) => {
        logger11.info("\u2705 Received New Peer's Role", { data });
        try {
          const { peerId, role } = data;
          if (peerId === this.peerId) {
            logger11.info("\u2705 Updating Local Peer's Role");
            this.__permissions.role = role;
            this.emit("role-updated", {
              role
            });
            return;
          }
          const remotePeer = this.room.getRemotePeerById(peerId);
          const prevRole = remotePeer.role ?? "";
          remotePeer.role = role;
          this.room.emit("room-role-updated", {
            peerId,
            newRole: role,
            prevRole
          });
        } catch (error) {
          logger11.error("\u274C Error Updating Peer's Role");
          logger11.error(error);
        }
      },
      roomClosedProducers: (data) => {
        logger11.info("\u2705 Received Room's Closed Producers", { data });
        try {
          const { producers, reason } = data;
          for (const producer of producers) {
            const { label, peerId } = producer;
            if (peerId === this.peerId && label) {
              this.stopProducing({ label });
              continue;
            }
            try {
              const remotePeer = this.room.getRemotePeerById(peerId);
              const consumer = this.recvTransport.getConsumer({
                label,
                peerId
              });
              if (consumer) {
                this.recvTransport.closeConsumer({ label, peerId });
                remotePeer._removeLabelData(label);
                this.room.emit("stream-closed", {
                  label,
                  peerId
                });
              }
            } catch (error) {
              logger11.error("\u274C Error Closing Producer");
              logger11.error(error);
            }
          }
          this.room.emit("room-notification", {
            code: reason?.code ?? 4004,
            message: reason?.message ?? "Room Closed",
            tag: reason?.tag ?? "ROOM_CLOSED"
          });
        } catch (error) {
          logger11.error("\u274C Error Updating Room's Closed Producers");
          logger11.error(error);
        }
      },
      receiveData: (data) => {
        logger11.info("\u2705 Received Data", { data });
        try {
          const { from, label, payload } = data;
          this.emit("receive-data", {
            from,
            label,
            payload
          });
        } catch (error) {
          logger11.error("\u274C Error Receive Data");
          logger11.error(error);
        }
      },
      peerMetadataUpdated: (data) => {
        try {
          logger11.info("\u2705 Metadata Updated", { data });
          const { peerId, metadata } = data;
          if (this.peerId === peerId) {
            this.__updateMetadata(metadata);
            return;
          }
          const remotePeer = this.room.getRemotePeerById(peerId);
          remotePeer.metadata = JSON.parse(metadata);
        } catch (error) {
          logger11.error("\u274C Error Updating Metadata");
          logger11.error(error);
        }
      },
      roomMetadataUpdated: (data) => {
        logger11.info("\u2705 Room Metadata Updated", { data });
        try {
          const { metadata } = data;
          this.room.metadata = metadata;
        } catch (error) {
          logger11.error("\u274C Error Updating Room Metadata");
          logger11.error(error);
        }
      },
      peerLeft: (data) => {
        logger11.info("\u2705 Peer Left", { peerId: data.peerId });
        try {
          const { peerId } = data;
          const remotePeer = this.room.getRemotePeerById(peerId);
          const labels = remotePeer.labels;
          for (const label of labels) {
            this.__closeRemotePeerConsumer({
              peerId: remotePeer.peerId,
              label
            });
          }
          remotePeer.close();
          this.__remotePeers.delete(peerId);
          this.room.emit("peer-left", {
            peerId,
            metadata: remotePeer.getMetadata(),
            role: remotePeer.role
          });
        } catch (error) {
          logger11.error("\u274C Error Peer Left");
          logger11.error(error);
        }
      },
      lobbyPeerLeft: (data) => {
        logger11.info("\u2705 Lobby Peer Left", { peerId: data.peerId });
        try {
          const { peerId } = data;
          const lobbyPeers = this.room.lobbyPeersMap;
          if (lobbyPeers.has(peerId)) {
            lobbyPeers.delete(peerId);
            this.room.lobbyPeersMap = lobbyPeers;
          }
        } catch (error) {
          logger11.error("\u274C Error Lobby Peer's Left");
          logger11.error(error);
        }
      }
    };
    /**
     * @description Registers the important internal listeners for the client, events such as reconnected, room-joined etc.
     */
    __registerInternalListeners = () => {
      this.room.on("room-joined", () => {
        if (this.__volatileMessaging || this.room.defaultActiveSpeakerSize > 0) {
          this.__activateVolatileMessaging().catch((error) => {
            logger11.error(
              "\u{1F534} Error while activating active speakers notification",
              error
            );
          });
        }
      });
      this.socket.on("reconnected", () => {
        if (!this.joined) {
          logger11.info("\u{1F514} Peer Reconnected, Peer Can Join Room", {
            roomState: this.room.state
          });
          if (this.roomId && this.room.state === "connecting") {
            this.room.connect({ roomId: this.roomId });
          }
          return;
        }
        logger11.info("\u{1F514} LocalPeer Reconnected, Syncing Meeting States");
        this.__syncMeetingState();
        if (this.__sendTransport) {
          this.socket.publish("restartTransportIce", {
            transportId: this.__sendTransport.mediasoupTransport.id,
            transportType: "send"
          });
        }
        if (this.__recvTransport) {
          this.socket.publish("restartTransportIce", {
            transportId: this.__recvTransport.mediasoupTransport.id,
            transportType: "recv"
          });
        }
      });
    };
    /**
     * @description Creates a Producer, if send transport is not initialized, it creates one and then creates a producer
     * @param data - Data to create a producer { label, stream, stopTrackOnClose, appData }
     * @returns - Producer
     */
    __createProducer = async (data) => {
      if (!this.__sendTransport) {
        throw new Error("\u274C Send Transport Not Initialized, Internal Error");
      }
      const producer = await this.__sendTransport.produce({
        stream: data.stream,
        stopTrackOnClose: data.stopTrackOnClose ?? true,
        label: data.label,
        prefferedCodec: data.prefferedCodec,
        appData: {
          ...data.appData,
          label: data.label
        }
      });
      producer.on("transportclose", () => {
        this.stopProducing({ label: data.label });
      });
      if (!data.stream?.active) {
        logger11.error("\u274C Stream is not active, Closing Producer");
        throw new Error("\u274C Stream is not active, Closing Producer");
      }
      this.emit("stream-playable", {
        label: data.label,
        producer
      });
      return producer;
    };
    /**
     * @description Create a DataProducer on the server, Data Producer is used to send data other than Media stream to the server
     * @throws Error if DataProducer cannot be created
     * @param data
     */
    __createDataProducer = async (data) => {
      try {
        if (!this.__sendTransport) {
          throw new Error("\u274C Send Transport Not Initialized, Internal Error");
        }
        const dataProducer = await this.__sendTransport.produceData(data);
        dataProducer.on("transportclose", () => {
          logger11.info("\u{1F514} Data Producer's Transport Closed");
        });
        dataProducer.on("bufferedamountlow", () => {
          logger11.info("\u{1F514} Data Producer Buffered Amount Low");
        });
        dataProducer.on("@close", () => {
          logger11.info("\u{1F514} Data Producer Closed");
        });
        return dataProducer;
      } catch (error) {
        if (error instanceof Error) {
          throw error;
        }
        logger11.error("\u274C Error Creating Data Producer", error);
        throw new Error("\u274C Error Creating Data Producer");
      }
    };
    /**
     * Create WebRTC Transport (Send/Recv) on Server
     * @throws Error if Transport cannot be created
     * @param data - Transport Data { transportType }
     * @returns - Transport ( WebRTC Transport )
     */
    __createTransportOnServer = async (data) => {
      const pendingPromise = this.__pendingTransportTasks.get(data.transportType);
      if (pendingPromise) {
        logger11.info(
          `\u{1F514} Transport Task Already Pending for this transportType ${data.transportType}`
        );
        return pendingPromise;
      }
      const { transportType } = data;
      const promise = new Promise((resolve, reject) => {
        const handleNewTransport = (data2) => {
          if (data2.transport.transportType === transportType) {
            this.__pendingTransportTasks.delete(transportType);
            resolve(data2.transport);
          }
        };
        if (transportType === "send") {
          this.once("new-send-transport", handleNewTransport);
        }
        if (transportType === "recv") {
          this.once("new-recv-transport", handleNewTransport);
        }
        const device = this.device;
        const transport = data.transportType === "send" ? this.__sendTransport : this.__recvTransport;
        if (transport) {
          reject(
            new Error(`\u274C Transport Already Initialized, type: ${transportType}`)
          );
        }
        logger11.info(`\u{1F514} Creating ${data.transportType} Transport On Server`);
        this.socket.publish("createTransport", {
          sctpCapabilities: device.sctpCapabilities,
          transportType: data.transportType
        });
      });
      this.__pendingTransportTasks.set(data.transportType, promise);
      return promise;
    };
    /**
     * Sets the Remote Peers in the Room
     * @param roomInfo
     */
    __setRemotePeers = (roomInfo) => {
      const { peers } = roomInfo;
      for (const peer of peers) {
        if (peer.peerId === this.peerId) continue;
        const remotePeer = new RemotePeer_default({
          peerId: peer.peerId,
          metadata: peer.metadata,
          role: peer.role
        });
        const producers = peer.producers;
        this.__remotePeers.set(peer.peerId, remotePeer);
        producers.map((p) => {
          if (!this.__recvTransport || this.__recvTransport.connectionState === "new" || this.__recvTransport.connectionState === "connected") {
            remotePeer._addLabelData({
              producerId: p.id,
              label: p.label
            });
          } else {
            this.__waitingToConsume.push(
              () => remotePeer._addLabelData({
                producerId: p.id,
                label: p.label
              })
            );
          }
        });
      }
    };
    /**
     * Sets the Lobby Peers in the Room
     * @param roomInfo - RoomInfo
     */
    __setLobbyPeers = (roomInfo) => {
      const { lobbyPeers } = roomInfo;
      this.room.newlobbyPeers = lobbyPeers;
    };
    /**
     * Helper Function to close the consumer of a remote peer
     * @param data - Data to close the consumer { peerId, label }
     */
    __closeRemotePeerConsumer = (data) => {
      try {
        const { peerId, label } = data;
        const remotePeer = this.room.getRemotePeerById(peerId);
        remotePeer._removeLabelData(label);
        const consumer = this.recvTransport.getConsumer({
          label,
          peerId
        });
        if (consumer) {
          this.recvTransport.closeConsumer({ label, peerId });
        }
        this.room.emit("stream-closed", {
          label,
          peerId: data.peerId
        });
      } catch (error) {
        logger11.error("\u274C Error Closing Remote Peer's Consumer");
        logger11.error(error);
      }
    };
    /**
     * !important
     * Handler Function to handle the waiting to produce tasks when user is joining
     * the room with active stream, check if the user has valid permissions and based on
     * that allows the user to produce the stream
     */
    __handleWaitingToProduce = () => {
      try {
        const permissions = this.permissions;
        const closeStream = (label) => {
          const stream = this.__activeStreams.get(label);
          if (stream) {
            this.deviceHandler.stopStream(stream);
            this.__activeStreams.delete(label);
            this.emit("stream-closed", {
              label,
              reason: {
                code: 4444,
                message: "User's Permissions Denied",
                tag: "CLOSED_BY_ADMIN"
              }
            });
          }
          this.__waitingToProduce.delete(label);
        };
        if (!permissions.canProduce) {
          for (const [label, _] of this.__waitingToProduce) {
            closeStream(label);
          }
          this.__waitingToProduce.clear();
          return;
        }
        for (const [label, pendingStreamTask] of this.__waitingToProduce) {
          if (label === "video" && !permissions.canProduceSources.cam) {
            closeStream(label);
            continue;
          }
          if (label === "audio" && !permissions.canProduceSources.mic) {
            closeStream(label);
            continue;
          }
          pendingStreamTask().catch((error) => {
            logger11.error(
              "\u274C Error Producing Stream which was waiting to be produced with label :",
              label
            );
            logger11.error(error);
            closeStream(label);
          });
        }
        this.__waitingToProduce.clear();
      } catch (error) {
        logger11.error("\u274C Error Handling Waiting To Produce");
        logger11.error(error);
      }
    };
    /**
     * Invoke the waiting to consume tasks and clear the waiting to consume array
     */
    __handleWaitingToConsume = () => {
      for (const consumeTask of this.__waitingToConsume) {
        consumeTask().catch(() => {
          logger11.error("Unable to Consume after ice restart");
        });
      }
      this.__waitingToConsume = [];
    };
    /**
     * SyncMeetingState - Sync the Meeting State with the server, information such as new remote peer, change in producers etc.
     */
    __syncMeetingState = () => {
      try {
        const localProducerIds = this.__sendTransport?.producerIds ?? [];
        this.socket.publish("syncMeetingState", {
          localProducerIds
        });
      } catch (error) {
        logger11.error("\u274C Error Syncing Meeting State", error);
      }
    };
  };
  var LocalPeer_default = LocalPeer;

  // src/HuddleClient.ts
  var logger12 = mainLogger.createSubLogger("HuddleClient");
  var HuddleClient = class {
    /**
     * Connection Manager Instance, Hanlder socket connection and stores information about the connection
     */
    __socket;
    /**
     * Room Instance, Handles the room and its connection
     */
    __room;
    /**
     * Local Peer Instance, Handles the local peer and its connection
     */
    __localPeer;
    /**
     * Project Id of the Huddle01 Project
     */
    projectId;
    /**
     * Returns the underlying socket connection
     * @throws { Error } If the socket connection is not initialized
     */
    get socket() {
      if (!this.__socket) {
        throw new Error(
          "Socket Is Not Initialized, You need to connect to the Huddle01 Socket Servers first"
        );
      }
      return this.__socket;
    }
    /**
     * Returns the room instance, throws an error if the room is not created
     * @throws { Error } If the room is not created, Call createRoom() method before you can access the room
     */
    get room() {
      return this.__room;
    }
    get localPeer() {
      return this.__localPeer;
    }
    /**
     * Room Id of the current room
     */
    get roomId() {
      return this.room.roomId;
    }
    /**
     * Set a new region for the Huddle01 Media Servers
     */
    setRegion = (region) => {
      logger12.info("Setting a new region, ", region);
      this.socket.setRegion(region);
    };
    constructor(data) {
      if (data.options?.logging) {
        setLogLevel("trace");
      }
      logger12.info("\u2705 Initializing HuddleClient");
      this.projectId = data.projectId;
      this.__socket = Socket_default.create(data.options?.wsPolyfill);
      this.__room = Room_default.create({
        autoConsume: data.options?.autoConsume,
        activeSpeakers: data.options?.activeSpeakers
      });
      this.__localPeer = LocalPeer_default.create({
        handlerFactory: data.options?.handlerFactory,
        volatileMessages: data.options?.volatileMessaging
      });
      const isLocalDev = this.projectId === "development";
      if (isLocalDev) {
        logger12.info("\u{1F534} Local Development Mode");
        this.socket.enableLocalDev();
      }
      this.__socket.on("closed", (code) => {
        logger12.info(
          "\u{1F50C} Socket Connection closed, closing the room and LocalPeer"
        );
        if (code === ESocketCloseCode.ROOM_CLOSED) {
          this.room.close("CLOSED");
        } else if (code === ESocketCloseCode.ROOM_ENTRY_DENIED) {
          this.room.close("DENIED");
        } else if (code === ESocketCloseCode.CONNECTION_EXPIRED) {
          logger12.info("\u{1F514} Room closed due to connection expired");
          this.room.close("CONNECTION_EXPIRED");
        } else if (code === ESocketCloseCode.KICKED) {
          this.room.close("KICKED");
        } else if (code === ESocketCloseCode.MAX_PEERS_REACHED) {
          logger12.info("\u{1F514} Room closed due to max peers reached");
          this.room.close("MAX_PEERS_REACHED");
        } else if (code === ESocketCloseCode.ROOM_EXPIRED) {
          logger12.info("\u{1F514} Room closed due to room expired");
          this.room.close("ROOM_EXPIRED");
        } else {
          this.room.close();
        }
        this.localPeer.close();
      });
    }
    /**
     * Default method to connect to the Huddle01 Media Room.
     *
     * This method connects to socket, creates a room, and then connects to the room;
     */
    joinRoom = async (data) => {
      logger12.info("\u{1F514} Joining the room with roomId,", data.roomId);
      if (this.socket.connectionState === "connecting") {
        logger12.warn(
          "\u{1F514} Socket is already connecting, waiting for the connection to be established"
        );
        return this.room;
      }
      if (this.room.state === "connecting") {
        logger12.warn("\u{1F514} Room join already in progress");
        return this.room;
      }
      if (this.localPeer.joined) {
        logger12.warn("\u{1F514} Already joined the room");
        return this.room;
      }
      try {
        await this.socket.connect({ token: data.token });
        const room = this.room.connect({ roomId: data.roomId });
        return room;
      } catch (error) {
        logger12.error("\u{1F534} Error While Joining the Room");
        logger12.error(error);
        throw error;
      }
    };
    /**
     * Leave the room and disconnect from the socket
     */
    leaveRoom = () => {
      logger12.info("Leaving the room");
      this.socket.close(ESocketCloseCode.NORMAL_CLOSURE);
    };
    /**
     * Close the room and disconnect from the socket
     */
    closeRoom = () => {
      logger12.info("Closing the room");
      this.socket.publish("closeRoom", void 0);
    };
  };
  var HuddleClient_default = HuddleClient;
  /*! Bundled license information:

  queue-microtask/index.js:
    (*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)
  */

  exports.Consumer = Consumer_default;
  exports.DeviceHandler = DeviceHandler_default;
  exports.HuddleClient = HuddleClient_default;
  exports.LocalPeer = LocalPeer_default;
  exports.Permissions = Permissions_default;
  exports.RemotePeer = RemotePeer_default;
  exports.Room = Room_default;
  exports.Socket = Socket_default;
  exports.Transport = Transport_default;

  return exports;

})({});
